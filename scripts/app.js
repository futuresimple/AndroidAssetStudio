(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _pages = require('./pages');

var _studio = require('./studio');

var _imagelib = require('./imagelib');

window.pages = _pages.pages; /*
                              * Copyright 2016 Google Inc.
                              *
                              * Licensed under the Apache License, Version 2.0 (the "License");
                              * you may not use this file except in compliance with the License.
                              * You may obtain a copy of the License at
                              *
                              *     http://www.apache.org/licenses/LICENSE-2.0
                              *
                              * Unless required by applicable law or agreed to in writing, software
                              * distributed under the License is distributed on an "AS IS" BASIS,
                              * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                              * See the License for the specific language governing permissions and
                              * limitations under the License.
                              */

},{"./imagelib":5,"./pages":12,"./studio":33}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Analysis = undefined;

var _Drawing = require('./Drawing');

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise; /*
                                                                                           * Copyright 2016 Google Inc.
                                                                                           *
                                                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                           * you may not use this file except in compliance with the License.
                                                                                           * You may obtain a copy of the License at
                                                                                           *
                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                           *
                                                                                           * Unless required by applicable law or agreed to in writing, software
                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                           * See the License for the specific language governing permissions and
                                                                                           * limitations under the License.
                                                                                           */

var Analysis = exports.Analysis = {};

Analysis.TRIM_RECT_WORKER_JS = '\n    self.onmessage = function(event) {\n      var l = event.data.size.w, t = event.data.size.h, r = 0, b = 0;\n\n      var alpha;\n      for (var y = 0; y < event.data.size.h; y++) {\n        for (var x = 0; x < event.data.size.w; x++) {\n          alpha = event.data.imageData.data[\n              ((y * event.data.size.w + x) << 2) + 3];\n          if (alpha >= event.data.minAlpha) {\n            l = Math.min(x, l);\n            t = Math.min(y, t);\n            r = Math.max(x, r);\n            b = Math.max(y, b);\n          }\n        }\n      }\n\n      if (l > r) {\n        // no pixels, couldn\'t trim\n        postMessage({ x: 0, y: 0, w: event.data.size.w, h: event.data.size.h });\n        return;\n      }\n\n      postMessage({ x: l, y: t, w: r - l + 1, h: b - t + 1 });\n    };';

Analysis.MAX_TRIM_SRC_SIZE = 500;

Analysis.getTrimRect = function (ctx, size, minAlpha) {
  if (!ctx.canvas) {
    // Likely an image
    var src = ctx;
    ctx = _Drawing.Drawing.context(size);
    ctx.drawImage(src, 0, 0);
  }

  var scale = 1;
  if (size.w > Analysis.MAX_TRIM_SRC_SIZE || size.h > Analysis.MAX_TRIM_SRC_SIZE) {
    scale = size.w > Analysis.MAX_TRIM_SRC_SIZE ? Analysis.MAX_TRIM_SRC_SIZE / size.w : Analysis.MAX_TRIM_SRC_SIZE / size.h;
    var scaledSize = { w: size.w * scale, h: size.h * scale };
    var tmpCtx = _Drawing.Drawing.context(scaledSize);
    tmpCtx.drawImage(ctx.canvas, 0, 0, size.w, size.h, 0, 0, scaledSize.w, scaledSize.h);
    ctx = tmpCtx;
    size = scaledSize;
  }

  var worker = void 0;
  var promise = new _Promise(function (resolve, reject) {
    if (minAlpha == 0) {
      resolve({ x: 0, y: 0, w: size.w, h: size.h });
    }

    minAlpha = minAlpha || 1;

    worker = runWorkerJs_(Analysis.TRIM_RECT_WORKER_JS, {
      imageData: ctx.getImageData(0, 0, size.w, size.h),
      size: size,
      minAlpha: minAlpha
    }, function (resultingRect) {
      resultingRect.x /= scale;
      resultingRect.y /= scale;
      resultingRect.w /= scale;
      resultingRect.h /= scale;
      resolve(resultingRect);
      worker = null;
    });
  });

  Object.defineProperty(promise, 'worker', {
    get: function get() {
      return worker;
    }
  });

  return promise;
};

Analysis.getCenterOfMass = function (ctx, size, minAlpha) {
  return new _Promise(function (resolve, reject) {
    if (!ctx.canvas) {
      // Likely an image
      var src = ctx;
      ctx = _Drawing.Drawing.context(size);
      ctx.drawImage(src, 0, 0);
    }

    if (minAlpha == 0) {
      resolve({ x: size.w / 2, y: size.h / 2 });
    }

    minAlpha = minAlpha || 1;

    var l = size.w,
        t = size.h,
        r = 0,
        b = 0;
    var imageData = ctx.getImageData(0, 0, size.w, size.h);

    var sumX = 0;
    var sumY = 0;
    var n = 0; // number of pixels > minAlpha
    var alpha;
    for (var y = 0; y < size.h; y++) {
      for (var x = 0; x < size.w; x++) {
        alpha = imageData.data[(y * size.w + x << 2) + 3];
        if (alpha >= minAlpha) {
          sumX += x;
          sumY += y;
          ++n;
        }
      }
    }

    if (n <= 0) {
      // no pixels > minAlpha, just use center
      resolve({ x: size.w / 2, h: size.h / 2 });
    }

    resolve({ x: Math.round(sumX / n), y: Math.round(sumY / n) });
  });
};

/**
 * Helper method for running inline Web Workers, if the browser can support
 * them. If the browser doesn't support inline Web Workers, run the script
 * on the main thread, with this function body's scope, using eval. Browsers
 * must provide BlobBuilder, URL.createObjectURL, and Worker support to use
 * inline Web Workers. Most features such as importScripts() are not
 * currently supported, so this only works for basic workers.
 * @param {String} js The inline Web Worker Javascript code to run. This code
 *     must use 'self' and not 'this' as the global context variable.
 * @param {Object} params The parameters object to pass to the worker.
 *     Equivalent to calling Worker.postMessage(params);
 * @param {Function} callback The callback to run when the worker calls
 *     postMessage. Equivalent to adding a 'message' event listener on a
 *     Worker object and running callback(event.data);
 */
function runWorkerJs_(js, params, callback) {
  var URL = window.URL || window.webkitURL || window.mozURL;
  var Worker = window.Worker;

  if (URL && Worker && hasBlobConstructor_()) {
    // The Blob constructor, Worker, and window.URL.createObjectURL are all available,
    // so we can use inline workers.
    var bb = new Blob([js], { type: 'text/javascript' });
    var worker = new Worker(URL.createObjectURL(bb));
    worker.onmessage = function (event) {
      callback(event.data);
    };
    worker.postMessage(params);
    return worker;
  } else {
    // We can't use inline workers, so run the worker JS on the main thread.
    (function () {
      var __DUMMY_OBJECT__ = {};
      // Proxy to Worker.onmessage
      var postMessage = function postMessage(result) {
        callback(result);
      };
      // Bind the worker to this dummy object. The worker will run
      // in this scope.
      eval('var self=__DUMMY_OBJECT__;\n' + js);
      // Proxy to Worker.postMessage
      __DUMMY_OBJECT__.onmessage({
        data: params
      });
    })();

    // Return a dummy Worker.
    return {
      terminate: function terminate() {}
    };
  }
};

// https://github.com/gildas-lormeau/zip.js/issues/17#issuecomment-8513258
// thanks Eric!
function hasBlobConstructor_() {
  try {
    return !!new Blob();
  } catch (e) {
    return false;
  }
}

},{"./Drawing":3,"es6-promise":34}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Drawing = undefined;

var _tinycolor = require('tinycolor2');

var _tinycolor2 = _interopRequireDefault(_tinycolor);

var _Effects = require('./Effects');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Drawing = exports.Drawing = {};

Drawing.context = function (size) {
  var canvas = document.createElement('canvas');
  canvas.width = size.w;
  canvas.height = size.h;
  canvas.style.setProperty('image-rendering', 'optimizeQuality', null);
  return canvas.getContext('2d');
};

Drawing.drawCenterInside = function (dstCtx, src, dstRect, srcRect) {
  if (srcRect.w / srcRect.h > dstRect.w / dstRect.h) {
    var h = srcRect.h * dstRect.w / srcRect.w;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x, dstRect.y + (dstRect.h - h) / 2, dstRect.w, h);
  } else {
    var w = srcRect.w * dstRect.h / srcRect.h;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x, srcRect.y, srcRect.w, srcRect.h, dstRect.x + (dstRect.w - w) / 2, dstRect.y, w, dstRect.h);
  }
};

Drawing.drawCenterCrop = function (dstCtx, src, dstRect, srcRect) {
  if (srcRect.w / srcRect.h > dstRect.w / dstRect.h) {
    var w = srcRect.h * dstRect.w / dstRect.h;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x + (srcRect.w - w) / 2, srcRect.y, w, srcRect.h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
  } else {
    var h = srcRect.w * dstRect.h / dstRect.w;
    Drawing.drawImageScaled(dstCtx, src, srcRect.x, srcRect.y + (srcRect.h - h) / 2, srcRect.w, h, dstRect.x, dstRect.y, dstRect.w, dstRect.h);
  }
};

Drawing.drawImageScaled = function (dstCtx, src, sx, sy, sw, sh, dx, dy, dw, dh) {
  if (dw <= 0 || dh <= 0 || sw <= 0 || sh <= 0) {
    console.error('Width/height must be at least 0');
    return;
  }

  src = src.canvas || src;

  // algorithm: when scaling down, downsample by at most a factor of 2 per iteration
  // to avoid poor browser downsampling
  while (dw < sw / 2 || dh < sh / 2) {
    var tmpDw = Math.ceil(Math.max(dw, sw / 2));
    var tmpDh = Math.ceil(Math.max(dh, sh / 2));
    var tmpCtx = Drawing.context({ w: tmpDw, h: tmpDh });

    tmpCtx.clearRect(0, 0, tmpDw, tmpDh);
    tmpCtx.drawImage(src, sx, sy, sw, sh, 0, 0, tmpDw, tmpDh);

    src = tmpCtx.canvas;
    sx = sy = 0;
    sw = tmpDw;
    sh = tmpDh;
  }

  dstCtx.drawImage(src, sx, sy, sw, sh, dx, dy, dw, dh);
};

Drawing.drawLayers = function (dstCtx, size, layerTree) {
  drawLayer_(dstCtx, layerTree);

  function drawLayer_(dstCtx, layer) {
    var layerCtx = Drawing.context(size);

    if (layer.children) {
      drawGroup_(layerCtx, layer);
    } else if (layer.draw) {
      layer.draw(layerCtx);
    }

    if (layer.effects) {
      // apply effects in a new buffer
      var effectsCtx = Drawing.context(size);
      _Effects.Effects.fx(layer.effects, effectsCtx, layerCtx, size);
      layerCtx = effectsCtx;
    }

    dstCtx.drawImage(layerCtx.canvas, 0, 0);
  }

  function drawGroup_(dstCtx, group) {
    var dstCtxStack = [dstCtx];

    group.children.filter(function (layer) {
      return !!layer;
    }).forEach(function (layer) {
      drawLayer_(dstCtxStack[dstCtxStack.length - 1], layer);
      if (layer.mask) {
        // draw future layers into a separate buffer (later gets masked)
        var maskedContentCtx = Drawing.context(size);
        dstCtxStack.push(maskedContentCtx);
      }
    });

    while (dstCtxStack.length > 1) {
      var targetCtx = dstCtxStack[dstCtxStack.length - 2];
      var contentCtx = dstCtxStack[dstCtxStack.length - 1];
      targetCtx.save();
      targetCtx.globalCompositeOperation = 'source-atop';
      targetCtx.drawImage(contentCtx.canvas, 0, 0);
      targetCtx.restore();
      dstCtxStack.pop();
    }
  }
};

},{"./Effects":4,"tinycolor2":36}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Effects = undefined;

var _Drawing = require('./Drawing');

var OUTER_EFFECTS = new Set(['outer-shadow', 'cast-shadow']); /*
                                                               * Copyright 2016 Google Inc.
                                                               *
                                                               * Licensed under the Apache License, Version 2.0 (the "License");
                                                               * you may not use this file except in compliance with the License.
                                                               * You may obtain a copy of the License at
                                                               *
                                                               *     http://www.apache.org/licenses/LICENSE-2.0
                                                               *
                                                               * Unless required by applicable law or agreed to in writing, software
                                                               * distributed under the License is distributed on an "AS IS" BASIS,
                                                               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                               * See the License for the specific language governing permissions and
                                                               * limitations under the License.
                                                               */

var INNER_EFFECTS = new Set(['inner-shadow', 'score']);
var FILL_EFFECTS = new Set(['fill-color', 'fill-lineargradient', 'fill-radialgradient']);

var Effects = exports.Effects = {
  fx: function fx(effects, dstCtx, src, size) {
    effects = effects || [];

    var outerEffects = effects.filter(function (e) {
      return OUTER_EFFECTS.has(e.effect);
    });
    var innerEffects = effects.filter(function (e) {
      return INNER_EFFECTS.has(e.effect);
    });
    var fillEffects = effects.filter(function (e) {
      return FILL_EFFECTS.has(e.effect);
    });

    var tmpCtx = void 0,
        bufferCtx = void 0;

    // First render outer effects
    var padLeft = void 0,
        padRight = void 0,
        padBottom = void 0,
        padTop = void 0;
    padLeft = padRight = padBottom = padTop = outerEffects.reduce(function (r, e) {
      return Math.max(r, e.blur || 0);
    }, 0);

    var paddedSize = {
      w: size.w + padLeft + padRight,
      h: size.h + padTop + padBottom
    };

    tmpCtx = _Drawing.Drawing.context(paddedSize);

    outerEffects.forEach(function (effect) {
      switch (effect.effect) {
        case 'cast-shadow':
          tmpCtx.clearRect(0, 0, paddedSize.w, paddedSize.h);
          tmpCtx.drawImage(src.canvas || src, padLeft, padTop);
          renderCastShadow_(tmpCtx, paddedSize.w, paddedSize.h, tinycolor(effect.color));
          dstCtx.drawImage(tmpCtx.canvas, padLeft, padTop, size.w, size.h, 0, 0, size.w, size.h);
          break;

        case 'outer-shadow':
          var tColor = tinycolor(effect.color || '#000');
          var alpha = tColor.getAlpha();
          tColor.setAlpha(1);

          if (supportsCanvasFilters_()) {
            tmpCtx.save();
            tmpCtx.clearRect(0, 0, paddedSize.w, paddedSize.h);
            tmpCtx.filter = 'blur(' + (effect.blur || 0) + 'px)';
            tmpCtx.drawImage(src.canvas || src, padLeft, padTop);
            tmpCtx.globalCompositeOperation = 'source-atop';
            tmpCtx.fillStyle = tColor.toRgbString();
            tmpCtx.fillRect(0, 0, paddedSize.w, paddedSize.h);
            tmpCtx.restore();

            dstCtx.save();
            dstCtx.translate(effect.translateX || 0, effect.translateY || 0);
            dstCtx.globalAlpha = alpha;
            dstCtx.drawImage(tmpCtx.canvas, padLeft, padTop, size.w, size.h, 0, 0, size.w, size.h);
            dstCtx.restore();
          } else {
            dstCtx.save();
            dstCtx.globalAlpha = alpha;
            dstCtx.shadowOffsetX = paddedSize.w;
            dstCtx.shadowOffsetY = 0;
            dstCtx.shadowColor = tColor.toRgbString();
            dstCtx.shadowBlur = canvasShadowBlurForRadius_(effect.blur || 0);
            dstCtx.drawImage(src.canvas || src, (effect.translateX || 0) - paddedSize.w, effect.translateY || 0);
            dstCtx.restore();
          }
          break;
      }
    });

    // Next, render the source, fill effects (first one), and inner effects
    // in a buffer (bufferCtx)
    bufferCtx = _Drawing.Drawing.context(size);
    tmpCtx = _Drawing.Drawing.context(size);
    tmpCtx.drawImage(src.canvas || src, 0, 0);
    tmpCtx.globalCompositeOperation = 'source-atop';

    // Fill effects
    var fillOpacity = 1.0;
    if (fillEffects.length) {
      var effect = fillEffects[0];
      fillOpacity = 'opacity' in effect ? effect.opacity : 1;

      tmpCtx.save();

      switch (effect.effect) {
        case 'fill-color':
          {
            tmpCtx.fillStyle = effect.color;
            break;
          }

        case 'fill-lineargradient':
          {
            var gradient = tmpCtx.createLinearGradient(effect.fromX, effect.fromY, effect.toX, effect.toY);
            effect.colors.forEach(function (_ref) {
              var offset = _ref.offset,
                  color = _ref.color;
              return gradient.addColorStop(offset, color);
            });
            tmpCtx.fillStyle = gradient;
            break;
          }

        case 'fill-radialgradient':
          {
            var _gradient = tmpCtx.createRadialGradient(effect.centerX, effect.centerY, 0, effect.centerX, effect.centerY, effect.radius);
            effect.colors.forEach(function (_ref2) {
              var offset = _ref2.offset,
                  color = _ref2.color;
              return _gradient.addColorStop(offset, color);
            });
            tmpCtx.fillStyle = _gradient;
            break;
          }
      }

      tmpCtx.fillRect(0, 0, size.w, size.h);
      tmpCtx.restore();
    }

    bufferCtx.save();
    bufferCtx.globalAlpha = fillOpacity;
    bufferCtx.drawImage(tmpCtx.canvas, 0, 0);
    bufferCtx.restore();

    // Render inner effects
    padLeft = padTop = padRight = padBottom = 0;
    innerEffects.forEach(function (effect) {
      padLeft = Math.max(padLeft, (effect.blur || 0) + Math.max(0, effect.translateX || 0));
      padTop = Math.max(padTop, (effect.blur || 0) + Math.max(0, effect.translateY || 0));
      padRight = Math.max(padRight, (effect.blur || 0) + Math.max(0, -(effect.translateX || 0)));
      padBottom = Math.max(padBottom, (effect.blur || 0) + Math.max(0, -(effect.translateY || 0)));
    });

    paddedSize = {
      w: size.w + padLeft + padRight,
      h: size.h + padTop + padBottom
    };

    tmpCtx = _Drawing.Drawing.context(paddedSize);

    innerEffects.forEach(function (effect) {
      switch (effect.effect) {
        case 'inner-shadow':
          tmpCtx.save();
          tmpCtx.clearRect(0, 0, paddedSize.w, paddedSize.h);
          if (supportsCanvasFilters_()) {
            tmpCtx.filter = 'blur(' + (effect.blur || 0) + 'px)';
            tmpCtx.drawImage(bufferCtx.canvas, padLeft + (effect.translateX || 0), padTop + (effect.translateY || 0));
          } else {
            tmpCtx.shadowOffsetX = paddedSize.w;
            tmpCtx.shadowOffsetY = 0;
            tmpCtx.shadowColor = '#000'; // color doesn't matter
            tmpCtx.shadowBlur = canvasShadowBlurForRadius_(effect.blur || 0);
            tmpCtx.drawImage(bufferCtx.canvas, padLeft + (effect.translateX || 0) - paddedSize.w, padTop + (effect.translateY || 0));
          }
          tmpCtx.globalCompositeOperation = 'source-out';
          tmpCtx.fillStyle = effect.color;
          tmpCtx.fillRect(0, 0, paddedSize.w, paddedSize.h);
          tmpCtx.restore();

          bufferCtx.save();
          bufferCtx.globalCompositeOperation = 'source-atop';
          bufferCtx.drawImage(tmpCtx.canvas, -padLeft, -padTop);
          bufferCtx.restore();
          break;
      }
    });

    // Draw buffer (source, fill, inner effects) on top of outer effects
    dstCtx.drawImage(bufferCtx.canvas, 0, 0);
  }
};

function renderCastShadow_(ctx, w, h, color) {
  var tmpCtx = _Drawing.Drawing.context({ w: w, h: h });
  // render the cast shadow
  for (var o = 1; o < Math.max(w, h); o++) {
    tmpCtx.drawImage(ctx.canvas, o, o);
  }
  tmpCtx.globalCompositeOperation = 'source-in';
  tmpCtx.fillStyle = '#000';
  tmpCtx.fillRect(0, 0, w, h);
  var gradient = tmpCtx.createLinearGradient(0, 0, w, h);
  gradient.addColorStop(0, color.toRgbString());
  gradient.addColorStop(1, color.setAlpha(0).toRgbString());
  tmpCtx.fillStyle = gradient;
  tmpCtx.fillRect(0, 0, w, h);
  ctx.clearRect(0, 0, w, h);
  ctx.drawImage(tmpCtx.canvas, 0, 0);
}

function supportsCanvasFilters_() {
  if (!supportsCanvasFilters_.hasOwnProperty('cached')) {
    supportsCanvasFilters_.cached = document.createElement('canvas').getContext('2d').filter == 'none';
  }

  return supportsCanvasFilters_.cached;
}

// determined empirically: http://codepen.io/anon/pen/ggLOqJ
var BLUR_MULTIPLIER = [{ re: /chrome/i, mult: 2.7 }, { re: /safari/i, mult: 1.8 }, { re: /firefox/i, mult: 1.7 }, { re: /./i, mult: 1.7 }].find(function (x) {
  return x.re.test(navigator.userAgent);
}).mult;

function canvasShadowBlurForRadius_(radius) {
  return radius * BLUR_MULTIPLIER;
}

},{"./Drawing":3}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.imagelib = undefined;

var _Effects = require('./Effects');

var _Drawing = require('./Drawing');

var _Analysis = require('./Analysis');

var imagelib = exports.imagelib = {
  Drawing: _Drawing.Drawing,
  Effects: _Effects.Effects,
  Analysis: _Analysis.Analysis
}; /*
    * Copyright 2016 Google Inc.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

},{"./Analysis":2,"./Drawing":3,"./Effects":4}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActionBarIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _BaseGenerator2 = require('./BaseGenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 0, y: 0, w: 24, h: 24 };

var GRID_OVERLAY_SVG = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n        <g fill="none" fill-rule="evenodd">\n            <rect vector-effect="non-scaling-stroke" x="4" y="2" width="16" height="20" rx="2"/>\n            <rect vector-effect="non-scaling-stroke" x="3" y="3" width="18" height="18" rx="2"/>\n            <rect vector-effect="non-scaling-stroke" x="2" y="4" width="20" height="16" rx="2"/>\n            <circle vector-effect="non-scaling-stroke" cx="12" cy="12" r="5"/>\n            <circle vector-effect="non-scaling-stroke" cx="12" cy="12" r="10"/>\n            <path vector-effect="non-scaling-stroke" d="M0 24L24 0M0 0l24 24m-12 0V0M8 0v24m8-24v24m8-12H0m0 4h24M0 8h24"/>\n        </g>\n    </svg>';

var ActionBarIconGenerator = exports.ActionBarIconGenerator = function (_BaseGenerator) {
  _inherits(ActionBarIconGenerator, _BaseGenerator);

  function ActionBarIconGenerator() {
    _classCallCheck(this, ActionBarIconGenerator);

    return _possibleConstructorReturn(this, (ActionBarIconGenerator.__proto__ || Object.getPrototypeOf(ActionBarIconGenerator)).apply(this, arguments));
  }

  _createClass(ActionBarIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(ActionBarIconGenerator.prototype.__proto__ || Object.getPrototypeOf(ActionBarIconGenerator.prototype), 'setupForm', this).call(this);

      var defaultNameForSourceValue_ = function defaultNameForSourceValue_(v) {
        var name = _studio.studio.Util.sanitizeResourceName(v.name || 'example');
        return 'ic_action_' + name;
      };

      var nameField = void 0,
          customColorField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 128, h: 128 },
          clipartNoTrimPadding: true,
          defaultValueClipart: 'add_circle',
          dropTarget: document.body,
          onChange: function onChange(newValue, oldValue) {
            if (nameField.getValue() == defaultNameForSourceValue_(oldValue)) {
              nameField.setValue(defaultNameForSourceValue_(newValue));
            }
          }
        }), nameField = new _studio.studio.TextField('name', {
          newGroup: true,
          title: 'Name',
          helpText: 'Used when generating ZIP files.',
          defaultValue: defaultNameForSourceValue_({})
        }), new _studio.studio.EnumField('theme', {
          title: 'Theme',
          buttons: true,
          options: [{ id: 'light', title: 'Light' }, { id: 'dark', title: 'Dark' }, { id: 'custom', title: 'Custom' }],
          defaultValue: 'light'
        }), customColorField = new _studio.studio.ColorField('color', {
          title: 'Color',
          defaultValue: 'rgba(33, 150, 243, .6)',
          alpha: true
        })]
      });
      this.form.onChange(function (field) {
        var values = _this2.form.getValues();
        $('.outputs-panel').attr('data-theme', values.theme);
        customColorField.setEnabled(values.theme == 'custom');
        _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, _studio.studio.Util.mult(TARGET_RECT, mult), { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        var color = values.color;
        if (values.theme == 'light') {
          color = tinycolor('rgba(0, 0, 0, .54)');
        } else if (values.theme == 'dark') {
          color = tinycolor('#fff');
        }

        var alpha = color.getAlpha();
        color.setAlpha(1);

        _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: color.toRgbString(), opacity: alpha }], outCtx, tmpCtx, iconSize);

        color.setAlpha(alpha);

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }, {
    key: 'gridOverlaySvg',
    get: function get() {
      return GRID_OVERLAY_SVG;
    }
  }]);

  return ActionBarIconGenerator;
}(_BaseGenerator2.BaseGenerator);

},{"../imagelib":5,"../studio":33,"./BaseGenerator":8}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AppShortcutIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _BaseGenerator2 = require('./BaseGenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2017 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 48, h: 48 };
var TARGET_RECT = { x: 12, y: 12, w: 24, h: 24 };

var GRID_OVERLAY_SVG = '<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">\n        <g fill="none" fill-rule="evenodd">\n            <rect vector-effect="non-scaling-stroke" x="12" y="12" width="24" height="24"/>\n        </g>\n    </svg>';

var AppShortcutIconGenerator = exports.AppShortcutIconGenerator = function (_BaseGenerator) {
  _inherits(AppShortcutIconGenerator, _BaseGenerator);

  function AppShortcutIconGenerator() {
    _classCallCheck(this, AppShortcutIconGenerator);

    return _possibleConstructorReturn(this, (AppShortcutIconGenerator.__proto__ || Object.getPrototypeOf(AppShortcutIconGenerator)).apply(this, arguments));
  }

  _createClass(AppShortcutIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(AppShortcutIconGenerator.prototype.__proto__ || Object.getPrototypeOf(AppShortcutIconGenerator.prototype), 'setupForm', this).call(this);

      var defaultNameForSourceValue_ = function defaultNameForSourceValue_(v) {
        var name = _studio.studio.Util.sanitizeResourceName(v.name || 'example');
        return 'ic_shortcut_' + name;
      };

      var nameField = void 0,
          customColorField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 128, h: 128 },
          clipartNoTrimPadding: true,
          defaultValueClipart: 'search',
          dropTarget: document.body,
          onChange: function onChange(newValue, oldValue) {
            if (nameField.getValue() == defaultNameForSourceValue_(oldValue)) {
              nameField.setValue(defaultNameForSourceValue_(newValue));
            }
          }
        }), nameField = new _studio.studio.TextField('name', {
          newGroup: true,
          title: 'Name',
          helpText: 'Used when generating ZIP files.',
          defaultValue: defaultNameForSourceValue_({})
        }), new _studio.studio.ColorField('foreColor', {
          title: 'Color',
          defaultValue: '#448aff'
        }), new _studio.studio.ColorField('backColor', {
          title: 'Background color',
          defaultValue: '#f5f5f5'
        })]
      });
      this.form.onChange(function () {
        return _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        outCtx.save();
        outCtx.beginPath();
        outCtx.arc(24 * mult, 24 * mult, 22 * mult, 0, Math.PI * 2);
        outCtx.closePath();
        values.backColor.setAlpha(1);
        outCtx.fillStyle = values.backColor.toRgbString();
        outCtx.fill();
        outCtx.restore();

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, _studio.studio.Util.mult(TARGET_RECT, mult), { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        values.foreColor.setAlpha(1);
        _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: values.foreColor.toRgbString() }], outCtx, tmpCtx, iconSize);

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }, {
    key: 'gridOverlaySvg',
    get: function get() {
      return GRID_OVERLAY_SVG;
    }
  }]);

  return AppShortcutIconGenerator;
}(_BaseGenerator2.BaseGenerator);

},{"../imagelib":5,"../studio":33,"./BaseGenerator":8}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _studio = require('../studio');

var _imagelib = require('../imagelib');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DENSITIES = new Set(['xxxhdpi', 'xxhdpi', 'xhdpi', 'hdpi', 'mdpi']);
var REGENERATE_DEBOUNCE_TIME = 200;

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 0, y: 0, w: 24, h: 24 };

var BaseGenerator = exports.BaseGenerator = function () {
  function BaseGenerator() {
    var _this = this;

    _classCallCheck(this, BaseGenerator);

    this.regenerateDebounced_ = _studio.studio.Util.debounce(REGENERATE_DEBOUNCE_TIME, function () {
      return _this.regenerate();
    });

    this.setupZipper();
    this.setupOutputUi();
    this.setupOutputSlots();
    this.setupForm();
    _studio.studio.Hash.bindFormToDocumentHash(this.form);
    setTimeout(function () {
      return _this.regenerate();
    }, 0);
  }

  _createClass(BaseGenerator, [{
    key: 'setupZipper',
    value: function setupZipper() {
      this.zipper = _studio.studio.Zip.createDownloadifyZipButton($('#download-zip-button'));
    }
  }, {
    key: 'setupOutputUi',
    value: function setupOutputUi() {
      // grid toggle
      if (this.gridOverlaySvg) {
        var defaultChecked = 'assetStudioShowGrid' in localStorage ? localStorage.assetStudioShowGrid === 'true' : true;
        $('#grid-toggle').prop('checked', defaultChecked);
        $('.outputs-panel').toggleClass('show-grid', defaultChecked);

        $('#grid-toggle').click(function (ev) {
          var checked = $(ev.currentTarget).is(':checked');
          localStorage.assetStudioShowGrid = String(checked);
          $('.outputs-panel').toggleClass('show-grid', checked);
        });
      } else {
        $('#grid-toggle-container').hide();
      }

      // additional slots toggle
      $('.outputs-additional-toggle').click(function () {
        return $('.outputs-panel').toggleClass('is-showing-all');
      });
    }
  }, {
    key: 'setupOutputSlots',
    value: function setupOutputSlots() {
      var _this2 = this;

      this.densities.forEach(function (density) {
        _this2.createImageOutputSlot_({
          container: density == 'xxxhdpi' ? $('.outputs-main') : $('.outputs-additional'),
          id: density,
          label: density
        });
      });
    }
  }, {
    key: 'createImageOutputSlot_',
    value: function createImageOutputSlot_(params) {
      var $imageContainer = $('<div>').addClass('outputs-image-container').append($('<img>').addClass('outputs-image').attr('data-id', 'out-icon-' + params.id));

      if (this.gridOverlaySvg) {
        $('<div>').addClass('outputs-image-overlay').html(this.gridOverlaySvg).appendTo($imageContainer);
      }

      var $block = $('<div>').addClass('outputs-image-block').append($('<div>').addClass('outputs-label').text(params.label)).append($imageContainer).appendTo(params.container);

      return $block;
    }
  }, {
    key: 'setImageForSlot_',
    value: function setImageForSlot_(id, url) {
      _studio.studio.Util.loadImageFromUri(url).then(function (img) {
        return $('[data-id="out-icon-' + id + '"]').attr('src', img.src);
      });
    }
  }, {
    key: 'setupForm',
    value: function setupForm() {}
  }, {
    key: 'regenerate',
    value: function regenerate() {}
  }, {
    key: 'densities',
    get: function get() {
      return DENSITIES;
    }
  }]);

  return BaseGenerator;
}();

},{"../imagelib":5,"../studio":33}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _BaseGenerator2 = require('./BaseGenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 1, y: 1, w: 22, h: 22 };

var GenericIconGenerator = exports.GenericIconGenerator = function (_BaseGenerator) {
  _inherits(GenericIconGenerator, _BaseGenerator);

  function GenericIconGenerator() {
    _classCallCheck(this, GenericIconGenerator);

    return _possibleConstructorReturn(this, (GenericIconGenerator.__proto__ || Object.getPrototypeOf(GenericIconGenerator)).apply(this, arguments));
  }

  _createClass(GenericIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(GenericIconGenerator.prototype.__proto__ || Object.getPrototypeOf(GenericIconGenerator.prototype), 'setupForm', this).call(this);

      var defaultNameForSourceValue_ = function defaultNameForSourceValue_(v) {
        var name = _studio.studio.Util.sanitizeResourceName(v.name || 'example');
        return 'ic_' + name;
      };

      var nameField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 720, h: 720 }, // max render size, for SVGs
          defaultValueClipart: 'ac_unit',
          dropTarget: document.body,
          onChange: function onChange(newValue, oldValue) {
            if (nameField.getValue() == defaultNameForSourceValue_(oldValue)) {
              nameField.setValue(defaultNameForSourceValue_(newValue));
            }
          }
        }), new _studio.studio.RangeField('size', {
          newGroup: true,
          title: 'Asset size',
          helpText: 'Size of the final asset',
          min: 4,
          max: 200,
          defaultValue: 32,
          textFn: function textFn(d) {
            return d + 'dp';
          }
        }), new _studio.studio.RangeField('padding', {
          title: 'Asset padding',
          helpText: 'Padding around the icon asset',
          defaultValue: 8,
          textFn: function textFn(d) {
            return d + 'dp';
          }
        }), new _studio.studio.ColorField('color', {
          title: 'Color',
          helpText: 'Set to transparent to retain original colors',
          defaultValue: 'rgba(0, 0, 0, 0.54)',
          alpha: true
        }), nameField = new _studio.studio.TextField('name', {
          title: 'Name',
          helpText: 'Used when generating ZIP files as the resource name.',
          defaultValue: defaultNameForSourceValue_({})
        })]
      });
      this.form.onChange(function (field) {
        return _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var totalSize = values.size;
        var padding = Math.min(values.size / 2 - 1, values.padding);
        var iconSize = _studio.studio.Util.multRound({ w: totalSize, h: totalSize }, mult);
        var targetRect = _studio.studio.Util.multRound({ x: padding, y: padding, w: totalSize - padding * 2, h: totalSize - padding * 2 }, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, targetRect, { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        var color = values.color;
        var alpha = color.getAlpha();
        if (alpha > 0) {
          color.setAlpha(1);

          _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: color.toRgbString(), opacity: alpha }], outCtx, tmpCtx, iconSize);

          color.setAlpha(alpha);
        } else {
          outCtx.drawImage(tmpCtx.canvas, 0, 0);
        }

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }]);

  return GenericIconGenerator;
}(_BaseGenerator2.BaseGenerator);

},{"../imagelib":5,"../studio":33,"./BaseGenerator":8}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LauncherIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _BaseGenerator2 = require('./BaseGenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 48, h: 48 };

var TARGET_RECTS_BY_SHAPE = {
  none: { x: 3, y: 3, w: 42, h: 42 },
  circle: { x: 2, y: 2, w: 44, h: 44 },
  square: { x: 5, y: 5, w: 38, h: 38 },
  vrect: { x: 8, y: 2, w: 32, h: 44 },
  hrect: { x: 2, y: 8, w: 44, h: 32 }
};

var GRID_OVERLAY_SVG = '<svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">\n        <g fill="none" fill-rule="evenodd">\n            <rect vector-effect="non-scaling-stroke" x="8" y="2" width="32" height="44" rx="3"/>\n            <rect vector-effect="non-scaling-stroke" x="5" y="5" width="38" height="38" rx="3"/>\n            <rect vector-effect="non-scaling-stroke" x="2" y="8" width="44" height="32" rx="3"/>\n            <circle vector-effect="non-scaling-stroke" cx="24" cy="24" r="10"/>\n            <circle vector-effect="non-scaling-stroke" cx="24" cy="24" r="22"/>\n            <path vector-effect="non-scaling-stroke" d="M0 48L48 0M0 0l48 48M24 48V0M17 0v48M31 0v48M48 24H0M0 31h48M0 17h48"/>\n        </g>\n    </svg>';

var DEFAULT_EFFECT_OPTIONS = [{ id: 'none', title: 'None' }, { id: 'elevate', title: 'Elevate' }, { id: 'shadow', title: 'Cast shadow' }, { id: 'score', title: 'Score' }];

var NO_SHAPE_EFFECT_OPTIONS = [{ id: 'none', title: 'None' }, { id: 'score', title: 'Score' }];

var LauncherIconGenerator = exports.LauncherIconGenerator = function (_BaseGenerator) {
  _inherits(LauncherIconGenerator, _BaseGenerator);

  function LauncherIconGenerator() {
    _classCallCheck(this, LauncherIconGenerator);

    return _possibleConstructorReturn(this, (LauncherIconGenerator.__proto__ || Object.getPrototypeOf(LauncherIconGenerator)).apply(this, arguments));
  }

  _createClass(LauncherIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      var backColorType = void 0,
          backColorField = void 0,
          backGradientField = void 0,
          backGradientDirection = void 0,
          effectsField = void 0;
      var shadowColorField = void 0,
          shadowAlphaField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('foreground', {
          title: 'Foreground',
          maxFinalSize: { w: 720, h: 720 }, // max render size, for SVGs
          defaultValueTrim: 1,
          defaultValuePadding: .25,
          defaultValueTop: 0,
          defaultValueLeft: 0,
          defaultValueClipart: 'android',
          dropTarget: document.body
        }), new _studio.studio.ColorField('foreColor', {
          newGroup: true,
          title: 'Color',
          helpText: 'Set to transparent to use original colors',
          alpha: true,
          defaultValue: 'rgba(96, 125, 139, 0)'
        }), backColorType = new _studio.studio.EnumField('backgroundType', {
          title: 'Background type',
          buttons: true,
          options: [{ id: 'solid', title: 'Solid' }, { id: 'gradient', title: 'Gradient' }],
          defaultValue: 'solid',
          onChange: function onChange(newValue) {
            backColorField.setEnabled(newValue == 'solid');
            backGradientField.setEnabled(newValue == 'gradient');
            backGradientDirection.setEnabled(newValue == 'gradient');
          }
        }), backColorField = new _studio.studio.ColorField('backColor', {
          title: 'Background color',
          defaultValue: '#448aff'
        }), backGradientField = new _studio.studio.GradientField('backGradient', {
          title: 'Background gradient',
          defaultFrom: '#9cb2e1',
          defaultTo: '#3c4769'
        }), backGradientDirection = new _studio.studio.EnumField('backGradientDirection', {
          title: 'Background gradient direction',
          options: [{ id: 't-t-b', title: 'Top to bottom' }, { id: 'l-t-r', title: 'Left to right' }, { id: 'ltc-t-rbc', title: 'Left top corner to right bottom corner' }, { id: 'lbc-t-rtc', title: 'Left bottom corner to right top corner' }],
          defaultValue: 't-t-b'
        }), new _studio.studio.BooleanField('crop', {
          title: 'Scaling',
          defaultValue: false,
          offText: 'Center',
          onText: 'Crop'
        }), new _studio.studio.EnumField('backgroundShape', {
          title: 'Shape',
          options: [{ id: 'none', title: 'None' }, { id: 'square', title: 'Square' }, { id: 'circle', title: 'Circle' }, { id: 'vrect', title: 'Tall rect' }, { id: 'hrect', title: 'Wide rect' }],
          defaultValue: 'square',
          onChange: function onChange(newValue) {
            backColorType.setEnabled(newValue != 'null');
            backColorField.setEnabled(newValue != 'none' && backColorType.getValue() == 'solid');
            backGradientField.setEnabled(newValue != 'none' && backColorType.getValue() == 'gradient');
            backGradientDirection.setEnabled(newValue != 'none' && backColorType.getValue() == 'gradient');
            var newEffectsOptions = newValue == 'none' ? NO_SHAPE_EFFECT_OPTIONS : DEFAULT_EFFECT_OPTIONS;
            if (!newEffectsOptions.find(function (e) {
              return e.id == effectsField.getValue();
            })) {
              effectsField.setValue(newEffectsOptions[0].id);
            }
            effectsField.setOptions(newEffectsOptions);
          }
        }), effectsField = new _studio.studio.EnumField('effects', {
          title: 'Effect',
          buttons: true,
          options: DEFAULT_EFFECT_OPTIONS,
          defaultValue: 'none',
          onChange: function onChange(newValue) {
            shadowColorField.setEnabled(newValue == 'shadow');
            shadowAlphaField.setEnabled(newValue == 'shadow');
          }
        }), shadowColorField = new _studio.studio.ColorField('shadowColor', {
          title: 'Shadow color',
          defaultValue: '#000000'
        }), shadowAlphaField = new _studio.studio.RangeField('shadowAlpha', {
          title: "Shadow alpha",
          min: 0,
          max: 1,
          step: 0.01,
          defaultValue: 0.2,
          showText: true
        }), new _studio.studio.TextField('name', {
          title: 'Name',
          defaultValue: 'ic_launcher'
        })]
      });
      this.form.onChange(function (field) {
        return _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      var xxxhdpiCtx = null;

      this.densities.forEach(function (density) {
        var ctx = void 0;
        if (density == 'xxxhdpi' || density == 'web') {
          ctx = _this3.regenerateRawAtDensity_(density);
          if (density == 'xxxhdpi') {
            xxxhdpiCtx = ctx;
          }
        } else {
          // just scale down xxxhdpi
          var mult = _studio.studio.Util.getMultBaseMdpi(density);
          var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);
          ctx = _imagelib.imagelib.Drawing.context(iconSize);
          _imagelib.imagelib.Drawing.drawImageScaled(ctx, xxxhdpiCtx, 0, 0, 192, 192, 0, 0, iconSize.w, iconSize.h);
        }

        _this3.zipper.add({
          name: density == 'web' ? 'web_hi_res_512.png' : 'res/mipmap-' + density + '/' + values.name + '.png',
          canvas: ctx.canvas
        });

        _this3.setImageForSlot_(density, ctx.canvas.toDataURL());
      });
    }
  }, {
    key: 'regenerateRawAtDensity_',
    value: function regenerateRawAtDensity_(density) {
      var values = this.form.getValues();
      var foreSrcCtx = values.foreground ? values.foreground.ctx : null;
      var mult = _studio.studio.Util.getMultBaseMdpi(density);
      if (density == 'web') {
        mult = 512 / 48;
      }

      var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);
      var targetRect = TARGET_RECTS_BY_SHAPE[values.backgroundShape];

      var outCtx = _imagelib.imagelib.Drawing.context(iconSize);

      var roundRectPath_ = function roundRectPath_(ctx, _ref, r) {
        var x = _ref.x,
            y = _ref.y,
            w = _ref.w,
            h = _ref.h;

        ctx.beginPath();
        ctx.moveTo(x + w - r, y);
        ctx.arcTo(x + w, y, x + w, y + r, r);
        ctx.lineTo(x + w, y + h - r);
        ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
        ctx.lineTo(x + r, y + h);
        ctx.arcTo(x, y + h, x, y + h - r, r);
        ctx.lineTo(x, y + r);
        ctx.arcTo(x, y, x + r, y, r);
        ctx.closePath();
      };

      var backgroundLayer = {
        // background layer
        draw: function draw(ctx) {
          ctx.scale(mult, mult);

          var targetRect = TARGET_RECTS_BY_SHAPE[values.backgroundShape];

          if (values.backgroundType == 'solid') {
            values.backColor.setAlpha(1);
            ctx.fillStyle = values.backColor.toRgbString();
          } else if (values.backgroundType == 'gradient') {
            values.backGradient.from.setAlpha(1);
            values.backGradient.to.setAlpha(1);

            var gradientDirection = values.backGradientDirection;
            var gradient = void 0;

            if (gradientDirection == 'ltc-t-rbc') {
              gradient = ctx.createLinearGradient(0, 0, targetRect.w, targetRect.h);
            } else if (gradientDirection == 'lbc-t-rtc') {
              gradient = ctx.createLinearGradient(0, targetRect.h, targetRect.w, 0);
            } else if (gradientDirection == 'l-t-r') {
              gradient = ctx.createLinearGradient(0, targetRect.h, targetRect.w, targetRect.h);
            } else {
              gradient = ctx.createLinearGradient(0, 0, 0, targetRect.h);
            }

            gradient.addColorStop(0, values.backGradient.from.toRgbString());
            gradient.addColorStop(1, values.backGradient.to.toRgbString());

            ctx.fillStyle = gradient;
          }

          switch (values.backgroundShape) {
            case 'square':
            case 'vrect':
            case 'hrect':
              roundRectPath_(ctx, targetRect, 3);
              ctx.fill();
              break;

            case 'circle':
              ctx.beginPath();
              ctx.arc(targetRect.x + targetRect.w / 2, targetRect.y + targetRect.h / 2, targetRect.w / 2, 0, 2 * Math.PI, false);
              ctx.closePath();
              ctx.fill();
              break;
          }
        },
        mask: true
      };

      var foregroundLayer = {
        // foreground content layer
        draw: function draw(ctx) {
          if (!foreSrcCtx) {
            return;
          }

          var drawFn_ = _imagelib.imagelib.Drawing[values.crop ? 'drawCenterCrop' : 'drawCenterInside'];
          drawFn_(ctx, foreSrcCtx, _studio.studio.Util.mult(targetRect, mult), { x: 0, y: 0, w: foreSrcCtx.canvas.width, h: foreSrcCtx.canvas.height });
        },
        effects: [],
        mask: !!(values.backgroundShape == 'none')
      };

      var shadowColorValue = values.shadowColor.toRgbString();

      var shadowColor = tinycolor(shadowColorValue).setAlpha(values.shadowAlpha).toRgbString();

      if (values.backgroundShape != 'none' && values.effects == 'shadow') {
        foregroundLayer.effects.push({ effect: 'cast-shadow', color: shadowColor });
      }

      if (values.foreColor.getAlpha()) {
        foregroundLayer.effects.push({
          effect: 'fill-color',
          color: values.foreColor.toRgbString()
        });
      }

      if (values.backgroundShape != 'none' && (values.effects == 'elevate' || values.effects == 'shadow')) {
        foregroundLayer.effects = foregroundLayer.effects.concat([{
          effect: 'outer-shadow',
          color: 'rgba(0, 0, 0, 0.2)',
          translateY: .25 * mult
        }, {
          effect: 'outer-shadow',
          color: 'rgba(0, 0, 0, 0.2)',
          blur: 1 * mult,
          translateY: 1 * mult
        }]);
      }

      var scoreLayer = {
        draw: function draw(ctx) {
          ctx.fillStyle = 'rgba(0, 0, 0, .1)';
          ctx.fillRect(0, 0, iconSize.w, iconSize.h / 2);
        }
      };

      _imagelib.imagelib.Drawing.drawLayers(outCtx, iconSize, {
        children: [values.backgroundShape != 'none' ? backgroundLayer : null, foregroundLayer, values.effects == 'score' ? scoreLayer : null],
        effects: [{
          effect: 'inner-shadow',
          color: 'rgba(255, 255, 255, 0.2)',
          translateY: .25 * mult
        }, {
          effect: 'inner-shadow',
          color: 'rgba(0, 0, 0, 0.2)',
          translateY: -.25 * mult
        }, {
          effect: 'fill-radialgradient',
          centerX: 0,
          centerY: 0,
          radius: iconSize.w,
          colors: [{ offset: 0, color: 'rgba(255,255,255,.1)' }, { offset: 1.0, color: 'rgba(255,255,255,0)' }]
        }, {
          effect: 'outer-shadow',
          color: 'rgba(0, 0, 0, 0.3)',
          blur: .7 * mult,
          translateY: .7 * mult
        }]
      });

      return outCtx;
    }
  }, {
    key: 'densities',
    get: function get() {
      return new Set(['xxxhdpi' /* must be first */, 'web', 'xxhdpi', 'xhdpi', 'hdpi', 'mdpi']);
    }
  }, {
    key: 'gridOverlaySvg',
    get: function get() {
      return GRID_OVERLAY_SVG;
    }
  }]);

  return LauncherIconGenerator;
}(_BaseGenerator2.BaseGenerator);

},{"../imagelib":5,"../studio":33,"./BaseGenerator":8}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotificationIconGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../studio');

var _imagelib = require('../imagelib');

var _BaseGenerator2 = require('./BaseGenerator');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ICON_SIZE = { w: 24, h: 24 };
var TARGET_RECT = { x: 1, y: 1, w: 22, h: 22 };

var NotificationIconGenerator = exports.NotificationIconGenerator = function (_BaseGenerator) {
  _inherits(NotificationIconGenerator, _BaseGenerator);

  function NotificationIconGenerator() {
    _classCallCheck(this, NotificationIconGenerator);

    return _possibleConstructorReturn(this, (NotificationIconGenerator.__proto__ || Object.getPrototypeOf(NotificationIconGenerator)).apply(this, arguments));
  }

  _createClass(NotificationIconGenerator, [{
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(NotificationIconGenerator.prototype.__proto__ || Object.getPrototypeOf(NotificationIconGenerator.prototype), 'setupForm', this).call(this);
      $('.outputs-panel').attr('data-theme', 'dark');

      var defaultNameForSourceValue_ = function defaultNameForSourceValue_(v) {
        var name = _studio.studio.Util.sanitizeResourceName(v.name || 'example');
        return 'ic_stat_' + name;
      };

      var nameField = void 0;
      this.form = new _studio.studio.Form({
        id: 'iconform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source',
          helpText: 'Must be transparent',
          maxFinalSize: { w: 128, h: 128 },
          defaultValueClipart: 'ac_unit',
          dropTarget: document.body,
          onChange: function onChange(newValue, oldValue) {
            if (nameField.getValue() == defaultNameForSourceValue_(oldValue)) {
              nameField.setValue(defaultNameForSourceValue_(newValue));
            }
          }
        }), nameField = new _studio.studio.TextField('name', {
          newGroup: true,
          title: 'Name',
          helpText: 'Used when generating ZIP files.',
          defaultValue: defaultNameForSourceValue_({})
        })]
      });
      this.form.onChange(function (field) {
        return _this2.regenerateDebounced_();
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.zip');

      this.densities.forEach(function (density) {
        var mult = _studio.studio.Util.getMultBaseMdpi(density);
        var iconSize = _studio.studio.Util.multRound(ICON_SIZE, mult);

        var outCtx = _imagelib.imagelib.Drawing.context(iconSize);
        var tmpCtx = _imagelib.imagelib.Drawing.context(iconSize);

        if (values.source.ctx) {
          var srcCtx = values.source.ctx;
          _imagelib.imagelib.Drawing.drawCenterInside(tmpCtx, srcCtx, _studio.studio.Util.mult(TARGET_RECT, mult), { x: 0, y: 0, w: srcCtx.canvas.width, h: srcCtx.canvas.height });
        }

        _imagelib.imagelib.Effects.fx([{ effect: 'fill-color', color: '#fff' }], outCtx, tmpCtx, iconSize);

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }]);

  return NotificationIconGenerator;
}(_BaseGenerator2.BaseGenerator);

},{"../imagelib":5,"../studio":33,"./BaseGenerator":8}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pages = undefined;

var _LauncherIconGenerator = require('./LauncherIconGenerator');

var _AppShortcutIconGenerator = require('./AppShortcutIconGenerator');

var _ActionBarIconGenerator = require('./ActionBarIconGenerator');

var _NotificationIconGenerator = require('./NotificationIconGenerator');

var _GenericIconGenerator = require('./GenericIconGenerator');

var _NinePatchGenerator = require('./ninepatch/NinePatchGenerator');

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var pages = exports.pages = {
  LauncherIconGenerator: _LauncherIconGenerator.LauncherIconGenerator,
  AppShortcutIconGenerator: _AppShortcutIconGenerator.AppShortcutIconGenerator,
  ActionBarIconGenerator: _ActionBarIconGenerator.ActionBarIconGenerator,
  NotificationIconGenerator: _NotificationIconGenerator.NotificationIconGenerator,
  GenericIconGenerator: _GenericIconGenerator.GenericIconGenerator,
  NinePatchGenerator: _NinePatchGenerator.NinePatchGenerator
};

},{"./ActionBarIconGenerator":6,"./AppShortcutIconGenerator":7,"./GenericIconGenerator":9,"./LauncherIconGenerator":10,"./NotificationIconGenerator":11,"./ninepatch/NinePatchGenerator":13}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _studio = require('../../studio');

var _imagelib = require('../../imagelib');

var _BaseGenerator2 = require('../BaseGenerator');

var _NinePatchStage = require('./NinePatchStage');

var _NinePatchPreview = require('./NinePatchPreview');

var _NinePatchLoader = require('./NinePatchLoader');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var DENSITIES = new Set(['xxxhdpi', 'xxhdpi', 'xhdpi', 'hdpi', 'mdpi']);
var SOURCE_DENSITY_OPTIONS = [{ id: '160', title: 'mdpi<br><small>(160)</small>' }, { id: '240', title: 'hdpi<br><small>(240)</small>' }, { id: '320', title: 'xhdpi<br><small>(320)</small>' }, { id: '480', title: 'xxhdpi<br><small>(480)</small>' }, { id: '640', title: 'xxxhdpi<br><small>(640)</small>' }];

if (document.location.search.indexOf('extradensities') >= 0) {
  DENSITIES.add('ldpi');
  DENSITIES.add('tvdpi');
  // SOURCE_DENSITY_OPTIONS.push({ id: '120', title:   'ldpi<br><small>(120)</small>' });
  // SOURCE_DENSITY_OPTIONS.push({ id: '213', title:  'tvdpi<br><small>(213)</small>' });
}

var NinePatchGenerator = exports.NinePatchGenerator = function (_BaseGenerator) {
  _inherits(NinePatchGenerator, _BaseGenerator);

  function NinePatchGenerator() {
    _classCallCheck(this, NinePatchGenerator);

    var _this = _possibleConstructorReturn(this, (NinePatchGenerator.__proto__ || Object.getPrototypeOf(NinePatchGenerator)).call(this));

    _this.stage = new _NinePatchStage.NinePatchStage();
    _this.preview = new _NinePatchPreview.NinePatchPreview(_this.stage);

    _this.stage.onChange(function () {
      _this.regenerate();
      _this.preview.redraw();
    });

    _this.setupOutputsPreviewTabs();
    return _this;
  }

  _createClass(NinePatchGenerator, [{
    key: 'setupOutputsPreviewTabs',
    value: function setupOutputsPreviewTabs() {
      $('.outputs-preview-tabs input').on('change', function (ev) {
        $('.outputs-preview-sidebar').attr('data-view', $(ev.currentTarget).val());
        $('.outputs-preview-tabs input').prop('checked', false);
        $(ev.currentTarget).prop('checked', true);
      });
    }
  }, {
    key: 'setupForm',
    value: function setupForm() {
      var _this2 = this;

      _get(NinePatchGenerator.prototype.__proto__ || Object.getPrototypeOf(NinePatchGenerator.prototype), 'setupForm', this).call(this);
      var nameField = void 0;
      this.form = new _studio.studio.Form({
        id: 'ninepatchform',
        container: '#inputs-form',
        fields: [new _studio.studio.ImageField('source', {
          title: 'Source graphic',
          imageOnly: true,
          noTrimForm: true,
          noPreview: true,
          dropTarget: document.body
        }), new _studio.studio.EnumField('sourceDensity', {
          title: 'Source density',
          buttons: true,
          options: SOURCE_DENSITY_OPTIONS,
          defaultValue: '320'
        }), nameField = new _studio.studio.TextField('name', {
          title: 'Drawable name',
          helpText: 'Used when generating ZIP files. Becomes <code>&lt;name&gt;.9.png</code>.',
          defaultValue: 'example'
        })]
      });
      this.form.onChange(function (field) {
        var values = _this2.form.getValues();
        if (!field || field.id_ == 'source') {
          if (values.source) {
            if (!values.source.ctx) {
              return;
            }
            var src = values.source;
            var size = { w: src.ctx.canvas.width, h: src.ctx.canvas.height };
            _this2.stage.name = src.name + '-' + size.w + 'x' + size.h;
            // let isSvg = !!src.name.match(/\.svg$/i);
            if (src.name && src.name.match(/\.9\.png$/i)) {
              _NinePatchLoader.NinePatchLoader.loadNinePatchIntoStage(src.ctx, _this2.stage);
            } else {
              _this2.stage.loadSourceImage(src.ctx);
            }
            if (src.name) {
              var name = _studio.studio.Util.sanitizeResourceName(src.name);
              if (name != nameField.getValue()) {
                nameField.setValue(name);
              }
            }
          } else {
            _this2.stage.loadSourceImage(null);
          }
        } else {
          _this2.regenerate();
        }
      });
    }
  }, {
    key: 'regenerate',
    value: function regenerate() {
      var _this3 = this;

      // this.preview.update();

      if (!this.stage.srcCtx) {
        return;
      }

      var values = this.form.getValues();

      this.zipper.clear();
      this.zipper.setZipFilename(values.name + '.9.zip');

      this.densities.forEach(function (density) {
        var dpi = _studio.studio.Util.getDpiForDensity(density);

        // scale source graphic
        // TODO: support better-smoothing option
        var scale = dpi / values.sourceDensity;
        var outSize = {
          w: Math.ceil(_this3.stage.srcSize.w * scale) + 2,
          h: Math.ceil(_this3.stage.srcSize.h * scale) + 2
        };
        var outCtx = _imagelib.imagelib.Drawing.context(outSize);
        _imagelib.imagelib.Drawing.drawImageScaled(outCtx, _this3.stage.srcCtx, 0, 0, _this3.stage.srcSize.w, _this3.stage.srcSize.h, 1, 1, outSize.w - 2, outSize.h - 2);

        // draw Android 4.3 optical bounds
        outCtx.strokeStyle = '#f00';
        outCtx.lineWidth = 1;
        outCtx.beginPath();

        outCtx.moveTo(1, outSize.h - 0.5);
        outCtx.lineTo(1 + Math.floor(scale * _this3.stage.opticalBoundsRect.x), outSize.h - 0.5);
        outCtx.stroke();

        outCtx.moveTo(Math.ceil(scale * (_this3.stage.opticalBoundsRect.x + _this3.stage.opticalBoundsRect.w)) + 1, outSize.h - 0.5);
        outCtx.lineTo(outSize.w - 1, outSize.h - 0.5);
        outCtx.stroke();

        outCtx.moveTo(outSize.w - 0.5, 1);
        outCtx.lineTo(outSize.w - 0.5, 1 + Math.floor(scale * _this3.stage.opticalBoundsRect.y));
        outCtx.stroke();

        outCtx.moveTo(outSize.w - 0.5, Math.ceil(scale * (_this3.stage.opticalBoundsRect.y + _this3.stage.opticalBoundsRect.h)) + 1);
        outCtx.lineTo(outSize.w - 0.5, outSize.h - 1);
        outCtx.stroke();

        outCtx.closePath();

        // draw nine-patch tick marks
        outCtx.strokeStyle = '#000';
        outCtx.beginPath();

        outCtx.moveTo(1 + Math.floor(scale * _this3.stage.stretchRect.x), 0.5);
        outCtx.lineTo(1 + Math.ceil(scale * (_this3.stage.stretchRect.x + _this3.stage.stretchRect.w)), 0.5);
        outCtx.stroke();

        outCtx.moveTo(0.5, 1 + Math.floor(scale * _this3.stage.stretchRect.y));
        outCtx.lineTo(0.5, 1 + Math.ceil(scale * (_this3.stage.stretchRect.y + _this3.stage.stretchRect.h)));
        outCtx.stroke();

        outCtx.moveTo(1 + Math.floor(scale * _this3.stage.contentRect.x), outSize.h - 0.5);
        outCtx.lineTo(1 + Math.ceil(scale * (_this3.stage.contentRect.x + _this3.stage.contentRect.w)), outSize.h - 0.5);
        outCtx.stroke();

        outCtx.moveTo(outSize.w - 0.5, 1 + Math.floor(scale * _this3.stage.contentRect.y));
        outCtx.lineTo(outSize.w - 0.5, 1 + Math.ceil(scale * (_this3.stage.contentRect.y + _this3.stage.contentRect.h)));
        outCtx.stroke();

        outCtx.closePath();

        // add to zip and show preview

        _this3.zipper.add({
          name: 'res/drawable-' + density + '/' + values.name + '.9.png',
          canvas: outCtx.canvas
        });

        _this3.setImageForSlot_(density, outCtx.canvas.toDataURL());
      });
    }
  }, {
    key: 'densities',
    get: function get() {
      return DENSITIES;
    }
  }]);

  return NinePatchGenerator;
}(_BaseGenerator2.BaseGenerator);

},{"../../imagelib":5,"../../studio":33,"../BaseGenerator":8,"./NinePatchLoader":14,"./NinePatchPreview":15,"./NinePatchStage":16}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchLoader = undefined;

var _imagelib = require('../../imagelib');

var numberForRGBA = function numberForRGBA(r, g, b, a) {
  return (r << 16) + (g << 8) + (b << 0) + (a << 24);
}; /*
    * Copyright 2016 Google Inc.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

var BLACK = numberForRGBA(0, 0, 0, 255);
var RED = numberForRGBA(255, 0, 0, 255);

var NinePatchLoader = exports.NinePatchLoader = {
  loadNinePatchIntoStage: function loadNinePatchIntoStage(ctx, stage) {
    var srcSize = { w: ctx.canvas.width, h: ctx.canvas.height };
    var imgData = ctx.getImageData(0, 0, srcSize.w, srcSize.h);
    var size = { w: srcSize.w - 2, h: srcSize.h - 2 };
    var rects = {
      contentRect: { x: 0, y: 0, w: size.w, h: size.h },
      stretchRect: { x: 0, y: 0, w: size.w, h: size.h },
      opticalBoundsRect: { x: 0, y: 0, w: size.w, h: size.h }
    };

    function _getPixel(x, y) {
      return (imgData.data[(y * srcSize.w + x) * 4 + 0] << 16) + ( // r
      imgData.data[(y * srcSize.w + x) * 4 + 1] << 8) // g
      + (imgData.data[(y * srcSize.w + x) * 4 + 2] << 0) // b
      + (imgData.data[(y * srcSize.w + x) * 4 + 3] << 24); // a
    }

    var inRegion = void 0;

    // Read stretch rect
    inRegion = false;
    for (var x = 0; x < size.w; x++) {
      var p = _getPixel(x + 1, 0);
      if (!inRegion && p == BLACK) {
        rects.stretchRect.x = x;
        inRegion = true;
      } else if (inRegion && p != BLACK) {
        rects.stretchRect.w = x - rects.stretchRect.x;
        inRegion = false;
      }
    }

    inRegion = false;
    for (var y = 0; y < size.h; y++) {
      var _p = _getPixel(0, y + 1);
      if (!inRegion && _p == BLACK) {
        rects.stretchRect.y = y;
        inRegion = true;
      } else if (inRegion && _p != BLACK) {
        rects.stretchRect.h = y - rects.stretchRect.y;
        inRegion = false;
      }
    }

    // Read content rect
    inRegion = false;
    for (var _x = 0; _x < size.w; _x++) {
      var _p2 = _getPixel(_x + 1, srcSize.h - 1);
      if (!inRegion && _p2 == BLACK) {
        rects.contentRect.x = _x;
        inRegion = true;
      } else if (inRegion && _p2 != BLACK) {
        rects.contentRect.w = _x - rects.contentRect.x;
        inRegion = false;
      }
    }

    inRegion = false;
    for (var _y = 0; _y < size.h; _y++) {
      var _p3 = _getPixel(srcSize.w - 1, _y + 1);
      if (!inRegion && _p3 == BLACK) {
        rects.contentRect.y = _y;
        inRegion = true;
      } else if (inRegion && _p3 != BLACK) {
        rects.contentRect.h = _y - rects.contentRect.y;
        inRegion = false;
      }
    }

    // Read optical bounds rect
    inRegion = false;
    for (var _x2 = 0; _x2 < size.w; _x2++) {
      var _p4 = _getPixel(_x2 + 1, srcSize.h - 1);
      if (!inRegion && _p4 != RED) {
        rects.opticalBoundsRect.x = _x2;
        inRegion = true;
      } else if (inRegion && _p4 == RED) {
        rects.opticalBoundsRect.w = _x2 - rects.opticalBoundsRect.x;
        inRegion = false;
      }
    }
    for (var _y2 = 0; _y2 < size.h; _y2++) {
      var _p5 = _getPixel(srcSize.w - 1, _y2 + 1);
      if (!inRegion && _p5 != RED) {
        rects.opticalBoundsRect.y = _y2;
        inRegion = true;
      } else if (inRegion && _p5 == RED) {
        rects.opticalBoundsRect.h = _y2 - rects.opticalBoundsRect.y;
        inRegion = false;
      }
    }

    // Inset the context
    var newCtx = _imagelib.imagelib.Drawing.context(size);
    newCtx.drawImage(ctx.canvas, 1, 1, size.w, size.h, 0, 0, size.w, size.h);
    stage.loadSourceImage(newCtx, rects);
  }
};

},{"../../imagelib":5}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var NinePatchPreview = exports.NinePatchPreview = function () {
  function NinePatchPreview(stage) {
    _classCallCheck(this, NinePatchPreview);

    this.stage = stage;
    this.size = { w: 200, h: 200 };
    this.setupUi();
    this.redraw();
  }

  _createClass(NinePatchPreview, [{
    key: 'setupUi',
    value: function setupUi() {
      var _this = this;

      var startWidth = void 0,
          startHeight = void 0,
          startX = void 0,
          startY = void 0;

      var mouseMoveHandler_ = function mouseMoveHandler_(ev) {
        _this.size.w = Math.max(1, startWidth + (ev.pageX - startX) * 2);
        _this.size.h = Math.max(1, startHeight + (ev.pageY - startY) * 2);
        _this.redraw();
      };

      var mouseUpHandler_ = function mouseUpHandler_(ev) {
        $(window).off('mousemove', mouseMoveHandler_).off('mouseup', mouseUpHandler_);
      };

      $('.preview-area').on('mousedown', function (ev) {
        startWidth = _this.size.w;
        startHeight = _this.size.h;
        startX = ev.pageX;
        startY = ev.pageY;

        $(window).on('mousemove', mouseMoveHandler_).on('mouseup', mouseUpHandler_);
      });

      $('#preview-with-content').click(function (ev) {
        return $('.text-preview').toggle($(ev.currentTarget).is(':checked'));
      });
    }
  }, {
    key: 'redraw',
    value: function redraw() {
      var canvas = $('.preview-area canvas').get(0);
      canvas.width = this.size.w;
      canvas.height = this.size.h;

      if (this.stage.srcCtx) {
        var ctx = canvas.getContext('2d');

        var fixed = {
          l: this.stage.stretchRect.x,
          t: this.stage.stretchRect.y,
          r: this.stage.srcSize.w - this.stage.stretchRect.x - this.stage.stretchRect.w,
          b: this.stage.srcSize.h - this.stage.stretchRect.y - this.stage.stretchRect.h
        };

        // TL
        if (fixed.l && fixed.t) ctx.drawImage(this.stage.srcCtx.canvas, 0, 0, fixed.l, fixed.t, 0, 0, fixed.l, fixed.t);

        // BL
        if (fixed.l && fixed.b) ctx.drawImage(this.stage.srcCtx.canvas, 0, this.stage.srcSize.h - fixed.b, fixed.l, fixed.b, 0, this.size.h - fixed.b, fixed.l, fixed.b);

        // TR
        if (fixed.r && fixed.t) ctx.drawImage(this.stage.srcCtx.canvas, this.stage.srcSize.w - fixed.r, 0, fixed.r, fixed.t, this.size.w - fixed.r, 0, fixed.r, fixed.t);

        // BR
        if (fixed.r && fixed.b) ctx.drawImage(this.stage.srcCtx.canvas, this.stage.srcSize.w - fixed.r, this.stage.srcSize.h - fixed.b, fixed.r, fixed.b, this.size.w - fixed.r, this.size.h - fixed.b, fixed.r, fixed.b);

        // Top
        if (fixed.t) ctx.drawImage(this.stage.srcCtx.canvas, fixed.l, 0, this.stage.stretchRect.w, fixed.t, fixed.l, 0, this.size.w - fixed.l - fixed.r, fixed.t);

        // Left
        if (fixed.l) ctx.drawImage(this.stage.srcCtx.canvas, 0, fixed.t, fixed.l, this.stage.stretchRect.h, 0, fixed.t, fixed.l, this.size.h - fixed.t - fixed.b);

        // Right
        if (fixed.r) ctx.drawImage(this.stage.srcCtx.canvas, this.stage.srcSize.w - fixed.r, fixed.t, fixed.r, this.stage.stretchRect.h, this.size.w - fixed.r, fixed.t, fixed.r, this.size.h - fixed.t - fixed.b);

        // Bottom
        if (fixed.b) ctx.drawImage(this.stage.srcCtx.canvas, fixed.l, this.stage.srcSize.h - fixed.b, this.stage.stretchRect.w, fixed.b, fixed.l, this.size.h - fixed.b, this.size.w - fixed.l - fixed.r, fixed.b);

        // Middle
        ctx.drawImage(this.stage.srcCtx.canvas, fixed.l, fixed.t, this.stage.stretchRect.w, this.stage.stretchRect.h, fixed.l, fixed.t, this.size.w - fixed.l - fixed.r, this.size.h - fixed.t - fixed.b);

        // preview content
        $('.preview-area .text-preview').css({
          left: this.stage.contentRect.x + "px",
          top: this.stage.contentRect.y + "px",
          width: this.size.w - this.stage.srcSize.w + this.stage.contentRect.w + "px",
          height: this.size.h - this.stage.srcSize.h + this.stage.contentRect.h + "px"
        });
      }
    }
  }]);

  return NinePatchPreview;
}();

},{}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchStage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _imagelib = require('../../imagelib');

var _NinePatchTrimming = require('./NinePatchTrimming');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EMPTY_RECT = { x: 0, y: 0, w: 0, h: 0 };

var SLOP_PIXELS = 10;

var NinePatchStage = exports.NinePatchStage = function () {
  function NinePatchStage() {
    var _this = this;

    _classCallCheck(this, NinePatchStage);

    this.zoom = 1;
    this.matteColor = 'light';
    this.editMode = 'stretch';
    this.stretchRect = Object.assign({}, EMPTY_RECT);
    this.contentRect = Object.assign({}, EMPTY_RECT);
    this.opticalBoundsRect = Object.assign({}, EMPTY_RECT);
    this.name = 'default';
    this.changeListeners_ = [];

    this.$stage = $('.nine-patch-stage');
    this.$canvasContainer = $('.stage-canvas-container');

    this.setupUi();
    this.setupDragging();

    $(window).on('resize', function () {
      _this.relayout();
      _this.redrawOverlay();
    });
  }

  _createClass(NinePatchStage, [{
    key: 'onChange',
    value: function onChange(listener) {
      this.changeListeners_.push(listener);
    }
  }, {
    key: 'notifyChange_',
    value: function notifyChange_() {
      this.changeListeners_.forEach(function (fn) {
        return fn();
      });
    }
  }, {
    key: 'setupUi',
    value: function setupUi() {
      var _this2 = this;

      // Stage code
      this.$topLabel = $('<div>').addClass('canvas-label label-vertical').hide().appendTo('body');
      this.$leftLabel = $('<div>').addClass('canvas-label label-horizontal').hide().appendTo('body');
      this.$rightLabel = $('<div>').addClass('canvas-label label-horizontal').hide().appendTo('body');
      this.$bottomLabel = $('<div>').addClass('canvas-label label-vertical').hide().appendTo('body');

      $('.stage-which input').on('change', function (ev) {
        _this2.editMode = $(ev.currentTarget).val();
        $('.trim-button').toggle(_this2.editMode == 'stretch');
        $('.find-region-button').text({
          stretch: 'Auto-stretch',
          padding: 'Auto-padding',
          opticalbounds: 'Auto-bounds'
        }[_this2.editMode]);
        $('.stage-which input').prop('checked', false);
        $(ev.currentTarget).prop('checked', true);
        _this2.redrawOverlay();
      });

      $('.stage-matte-color input').on('change', function (ev) {
        _this2.matteColor = $(ev.currentTarget).val();
        $(document.body).attr('data-theme', _this2.matteColor);
        $('.stage-matte-color input').prop('checked', false);
        $(ev.currentTarget).prop('checked', true);
        _this2.redrawImage();
      });

      $('.trim-edge-button').click(function () {
        return _NinePatchTrimming.NinePatchTrimming.trimEdges(_this2);
      });
      $('.trim-stretch-button').click(function () {
        return _NinePatchTrimming.NinePatchTrimming.trimStretchRegion(_this2);
      });
      $('.find-region-button').click(function () {
        var rect = _NinePatchTrimming.NinePatchTrimming.detectRegion(_this2, _this2.editMode);
        if (!rect) {
          return;
        }

        if (_this2.editMode == 'stretch') {
          _this2.stretchRect = rect;
        } else if (_this2.editMode == 'opticalbounds') {
          _this2.opticalBoundsRect = rect;
        } else if (_this2.editMode == 'padding') {
          _this2.contentRect = rect;
        }

        _this2.saveRects();
        _this2.redrawOverlay();
        _this2.notifyChange_();
      });
    }
  }, {
    key: 'setupDragging',
    value: function setupDragging() {
      var _this3 = this;

      var _mouseUpHandler_ = void 0,
          draggingMouseMoveHandler_ = void 0;

      var getEditRect_ = function getEditRect_() {
        return {
          stretch: _this3.stretchRect,
          padding: _this3.contentRect,
          opticalbounds: _this3.opticalBoundsRect
        }[_this3.editMode];
      };

      this.$canvasContainer.on('mousedown', function (ev) {
        _this3.dragging = true;
        _this3.redrawOverlay();
        $(window).on('mouseup', _mouseUpHandler_).on('mousemove', draggingMouseMoveHandler_);
      }).on('mousemove', function (ev) {
        if (!_this3.$imageCanvas) {
          return;
        }

        if (_this3.dragging) {
          return; // handled by other mousemove handler
        }

        var editRect = getEditRect_();
        var offs = _this3.$canvasContainer.offset();
        var offsetX = ev.pageX - offs.left;
        var offsetY = ev.pageY - offs.top;

        _this3.editLeft = _this3.editRight = _this3.editTop = _this3.editBottom = false;

        if (offsetX >= editRect.x * _this3.zoom - SLOP_PIXELS && offsetX <= editRect.x * _this3.zoom + SLOP_PIXELS) {
          _this3.editLeft = true;
        } else if (offsetX >= (editRect.x + editRect.w) * _this3.zoom - SLOP_PIXELS && offsetX <= (editRect.x + editRect.w) * _this3.zoom + SLOP_PIXELS) {
          _this3.editRight = true;
        }

        if (offsetY >= editRect.y * _this3.zoom - SLOP_PIXELS && offsetY <= editRect.y * _this3.zoom + SLOP_PIXELS) {
          _this3.editTop = true;
        } else if (offsetY >= (editRect.y + editRect.h) * _this3.zoom - SLOP_PIXELS && offsetY <= (editRect.y + editRect.h) * _this3.zoom + SLOP_PIXELS) {
          _this3.editBottom = true;
        }

        var cursor = 'default';
        if (_this3.editLeft) {
          if (_this3.editTop) {
            cursor = 'nw-resize';
          } else if (_this3.editBottom) {
            cursor = 'sw-resize';
          } else {
            cursor = 'w-resize';
          }
        } else if (_this3.editRight) {
          if (_this3.editTop) {
            cursor = 'ne-resize';
          } else if (_this3.editBottom) {
            cursor = 'se-resize';
          } else {
            cursor = 'e-resize';
          }
        } else if (_this3.editTop) {
          cursor = 'n-resize';
        } else if (_this3.editBottom) {
          cursor = 's-resize';
        }
        _this3.$canvasContainer.css('cursor', cursor);
      });

      _mouseUpHandler_ = function mouseUpHandler_(ev) {
        if (_this3.dragging) {
          _this3.dragging = false;
          _this3.redrawOverlay();
          _this3.saveRects();
        }

        $(window).off('mousemove', draggingMouseMoveHandler_).off('mouseup', _mouseUpHandler_);
      };

      draggingMouseMoveHandler_ = function draggingMouseMoveHandler_(ev) {
        ev.preventDefault();
        ev.stopPropagation();

        var editRect = getEditRect_();
        var offs = _this3.$canvasContainer.offset();
        var offsetX = ev.pageX - offs.left;
        var offsetY = ev.pageY - offs.top;

        if (_this3.editLeft) {
          var newX = Math.max(0, Math.min(editRect.x + editRect.w - 1, Math.round(offsetX / _this3.zoom)));
          editRect.w = editRect.w + editRect.x - newX;
          editRect.x = newX;
        }
        if (_this3.editTop) {
          var newY = Math.max(0, Math.min(editRect.y + editRect.h - 1, Math.round(offsetY / _this3.zoom)));
          editRect.h = editRect.h + editRect.y - newY;
          editRect.y = newY;
        }
        if (_this3.editRight) {
          editRect.w = Math.min(_this3.srcSize.w - editRect.x, Math.max(1, Math.round(offsetX / _this3.zoom) - editRect.x));
        }
        if (_this3.editBottom) {
          editRect.h = Math.min(_this3.srcSize.h - editRect.y, Math.max(1, Math.round(offsetY / _this3.zoom) - editRect.y));
        }

        _this3.redrawOverlay();
        _this3.notifyChange_();
      };
    }
  }, {
    key: 'loadSourceImage',
    value: function loadSourceImage(srcCtx) {
      var initRects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.$canvasContainer.empty();
      $('.editor-button').attr('disabled', srcCtx ? null : 'disabled');

      if (!srcCtx) {
        return;
      }

      this.srcCtx = srcCtx;

      // Update the stage source size
      var srcSizeChanged = false;
      var newSrcSize = { w: this.srcCtx.canvas.width, h: this.srcCtx.canvas.height };
      srcSizeChanged = !this.srcSize || this.srcSize.w != newSrcSize.w || this.srcSize.h != newSrcSize.h;
      this.srcSize = newSrcSize;

      // Reset the stretch, padding/content, and optical bounds regions
      if (srcSizeChanged) {
        this.stretchRect = initRects.stretchRect || {
          x: Math.floor(this.srcSize.w / 3),
          y: Math.floor(this.srcSize.h / 3),
          w: Math.ceil(this.srcSize.w / 3),
          h: Math.ceil(this.srcSize.h / 3)
        };

        this.contentRect = initRects.contentRect || { x: 0, y: 0, w: this.srcSize.w, h: this.srcSize.h };
        this.opticalBoundsRect = initRects.opticalBoundsRect || { x: 0, y: 0, w: this.srcSize.w, h: this.srcSize.h };
      }

      if (!initRects.stretchRect) {
        this.loadLastRects();
      }

      // Create the stage canvas
      this.$imageCanvas = $('<canvas>').attr({
        width: this.srcSize.w,
        height: this.srcSize.h
      }).appendTo(this.$canvasContainer);

      this.$overlayCanvas = $('<canvas>').addClass('overlay').appendTo(this.$canvasContainer);

      this.relayout();
      this.redrawImage();
      this.redrawOverlay();
      this.notifyChange_();
    }
  }, {
    key: 'relayout',
    value: function relayout() {
      if (!this.$imageCanvas) {
        return;
      }

      // Compute a zoom level that'll show the stage as large as possible
      var horizMaxZoom = Math.floor(this.$stage.width() / this.srcSize.w);
      var vertMaxZoom = Math.floor(this.$stage.height() / this.srcSize.h);
      this.zoom = Math.max(1, Math.min(horizMaxZoom, vertMaxZoom));
      this.zoomedSize = {
        w: this.srcSize.w * this.zoom,
        h: this.srcSize.h * this.zoom
      };

      this.$imageCanvas.css({
        width: this.zoomedSize.w,
        height: this.zoomedSize.h
      });
      this.$overlayCanvas.attr({
        width: this.zoomedSize.w,
        height: this.zoomedSize.h
      });
    }
  }, {
    key: 'redrawImage',
    value: function redrawImage() {
      if (!this.$imageCanvas) {
        return;
      }

      var imgCtx = this.$imageCanvas.get(0).getContext('2d');
      imgCtx.fillStyle = this.matteColor == 'light' ? '#eee' : '#555';
      imgCtx.fillRect(0, 0, this.srcSize.w, this.srcSize.h);

      // draw source graphic
      imgCtx.drawImage(this.srcCtx.canvas, 0, 0);
    }
  }, {
    key: 'redrawOverlay',
    value: function redrawOverlay() {
      if (!this.srcCtx) {
        return;
      }

      var editRect = {
        stretch: this.stretchRect,
        padding: this.contentRect,
        opticalbounds: this.opticalBoundsRect
      }[this.editMode];

      var ctx = this.$overlayCanvas.get(0).getContext('2d');
      ctx.clearRect(0, 0, this.zoomedSize.w, this.zoomedSize.h);
      ctx.save();

      // draw current edit region
      if (editRect === this.stretchRect) {
        ctx.beginPath();

        ctx.moveTo(0, editRect.y * this.zoom + .5);
        ctx.lineTo(this.zoomedSize.w, editRect.y * this.zoom + .5);

        ctx.moveTo(0, (editRect.y + editRect.h) * this.zoom - .5);
        ctx.lineTo(this.zoomedSize.w, (editRect.y + editRect.h) * this.zoom - .5);

        ctx.moveTo(editRect.x * this.zoom + .5, 0);
        ctx.lineTo(editRect.x * this.zoom + .5, this.zoomedSize.h);

        ctx.moveTo((editRect.x + editRect.w) * this.zoom - .5, 0);
        ctx.lineTo((editRect.x + editRect.w) * this.zoom - .5, this.zoomedSize.h);
      } else {
        ctx.beginPath();
        ctx.rect(editRect.x * this.zoom + .5, editRect.y * this.zoom + .5, editRect.w * this.zoom - 1, editRect.h * this.zoom - 1);
        ctx.closePath();
      }

      if (this.dragging) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.strokeStyle = 'rgba(255, 23, 68, 1)';
        ctx.lineWidth = 1;
        ctx.stroke();
      } else {
        ctx.strokeStyle = 'rgba(255, 255, 255, .5)';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.strokeStyle = 'rgba(0, 0, 0, .5)';
        ctx.setLineDash([3, 3]);
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      ctx.restore();

      // draw distance labels
      if (this.dragging) {
        var stageOffset = this.$canvasContainer.offset();

        this.$leftLabel.text(editRect.x).css({
          left: stageOffset.left,
          width: editRect.x * this.zoom,
          top: stageOffset.top + (editRect.y + editRect.h / 2) * this.zoom
        }).show();

        this.$rightLabel.text(this.srcSize.w - editRect.x - editRect.w).css({
          left: stageOffset.left + (editRect.x + editRect.w) * this.zoom,
          width: (this.srcSize.w - editRect.x - editRect.w) * this.zoom,
          top: stageOffset.top + (editRect.y + editRect.h / 2) * this.zoom
        }).show();

        this.$topLabel.text(editRect.y).css({
          top: stageOffset.top,
          height: editRect.y * this.zoom,
          left: stageOffset.left + (editRect.x + editRect.w / 2) * this.zoom
        }).show();

        this.$bottomLabel.text(this.srcSize.h - editRect.y - editRect.h).css({
          top: stageOffset.top + (editRect.y + editRect.h) * this.zoom,
          height: (this.srcSize.h - editRect.y - editRect.h) * this.zoom,
          left: stageOffset.left + (editRect.x + editRect.w / 2) * this.zoom
        }).show();
      } else {
        this.$topLabel.hide();
        this.$leftLabel.hide();
        this.$rightLabel.hide();
        this.$bottomLabel.hide();
      }
    }
  }, {
    key: 'saveRects',
    value: function saveRects() {
      localStorage[this.localStorageKey] = JSON.stringify({
        stretchRect: this.stretchRect,
        contentRect: this.contentRect,
        opticalBoundsRect: this.opticalBoundsRect
      });
    }
  }, {
    key: 'loadLastRects',
    value: function loadLastRects() {
      try {
        var store = JSON.parse(localStorage[this.localStorageKey]);
        if (store.stretchRect && store.contentRect && store.opticalBoundsRect) {
          this.stretchRect = fitRect_(store.stretchRect, this.srcSize);
          this.contentRect = fitRect_(store.contentRect, this.srcSize);
          this.opticalBoundsRect = fitRect_(store.opticalBoundsRect, this.srcSize);
        }
      } catch (e) {}
    }
  }, {
    key: 'localStorageKey',
    get: function get() {
      return 'assetStudioNinePatchStage-' + this.name;
    }
  }]);

  return NinePatchStage;
}();

function fitRect_(rect, size) {
  var newRect = {};
  newRect.x = Math.max(0, rect.x);
  newRect.y = Math.max(0, rect.y);
  newRect.w = Math.min(size.w - rect.x, rect.w);
  newRect.h = Math.min(size.h - rect.y, rect.h);
  return newRect;
}

},{"../../imagelib":5,"./NinePatchTrimming":17}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NinePatchTrimming = undefined;

var _imagelib = require('../../imagelib');

var _Summer = require('./Summer');

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var NinePatchTrimming = exports.NinePatchTrimming = {
  /**
   * Trims excess edges of the nine patch... any pixels that are the same
   * as the top-left most pixel color. Same as Photoshop's Trim feature.
   */
  trimEdges: function trimEdges(stage) {
    if (!stage.srcCtx) {
      return;
    }

    var srcData = stage.srcCtx.getImageData(0, 0, stage.srcSize.w, stage.srcSize.h);

    // Always trim by top-left pixel color
    var trimPixel = getPixel_(stage, srcData, 0, 0);

    var insetRect = { l: 0, t: 0, r: 0, b: 0 };
    var x = void 0,
        y = void 0;

    // Trim top
    trimTop: for (y = 0; y < stage.srcSize.h; y++) {
      for (x = 0; x < stage.srcSize.w; x++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimTop;
        }
      }
    }
    insetRect.t = y;
    // Trim left
    trimLeft: for (x = 0; x < stage.srcSize.w; x++) {
      for (y = 0; y < stage.srcSize.h; y++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimLeft;
        }
      }
    }
    insetRect.l = x;
    // Trim bottom
    trimBottom: for (y = stage.srcSize.h - 1; y >= 0; y--) {
      for (x = 0; x < stage.srcSize.w; x++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimBottom;
        }
      }
    }
    insetRect.b = stage.srcSize.h - y - 1;
    // Trim right
    trimRight: for (x = stage.srcSize.w - 1; x >= 0; x--) {
      for (y = 0; y < stage.srcSize.h; y++) {
        if (getPixel_(stage, srcData, x, y) != trimPixel) {
          break trimRight;
        }
      }
    }
    insetRect.r = stage.srcSize.w - x - 1;

    if (insetRect.l <= 0 && insetRect.t <= 0 && insetRect.r <= 0 && insetRect.b <= 0) {
      // No-op
      return;
    }

    // Build a new stage with inset values
    var size = {
      w: stage.srcSize.w - insetRect.l - insetRect.r,
      h: stage.srcSize.h - insetRect.t - insetRect.b
    };

    var rects = {
      contentRect: constrain_(size, {
        x: stage.contentRect.x - insetRect.l,
        y: stage.contentRect.y - insetRect.t,
        w: stage.contentRect.w,
        h: stage.contentRect.h
      }),
      stretchRect: constrain_(size, {
        x: stage.stretchRect.x - insetRect.l,
        y: stage.stretchRect.y - insetRect.t,
        w: stage.stretchRect.w,
        h: stage.stretchRect.h
      }),
      opticalBoundsRect: constrain_(size, {
        x: stage.opticalBoundsRect.x - insetRect.l,
        y: stage.opticalBoundsRect.y - insetRect.t,
        w: stage.opticalBoundsRect.w,
        h: stage.opticalBoundsRect.h
      })
    };

    stage.name = stage.name + '-EDGES_TRIMMED';
    var newCtx = _imagelib.imagelib.Drawing.context(size);
    newCtx.drawImage(stage.srcCtx.canvas, insetRect.l, insetRect.t, size.w, size.h, 0, 0, size.w, size.h);
    stage.loadSourceImage(newCtx, rects);
  },


  /**
   * Trims excess rows and columns from the stretch region of the given
   * nine patch stage.
   */
  trimStretchRegion: function trimStretchRegion(stage) {
    if (!stage.srcCtx) {
      return;
    }

    var srcData = stage.srcCtx.getImageData(0, 0, stage.srcSize.w, stage.srcSize.h);

    var collapseX = stage.stretchRect.w > 4; // generally going to start as true
    var collapseY = stage.stretchRect.h > 4; // generally going to start as true
    var x = void 0,
        y = void 0;

    // See if collapse is possible in either direction by comparing row/column sums.
    var summer = new _Summer.Summer();

    // See if can be horizontally collapsed.
    var first = true;
    var firstSum = -1;
    for (x = stage.stretchRect.x; x < stage.stretchRect.x + stage.stretchRect.w; x++) {
      // Compute column
      summer.reset();
      for (y = 0; y < stage.srcSize.h; y++) {
        summer.addNext(getPixel_(stage, srcData, x, y));
      }
      if (first) {
        firstSum = summer.compute();
        first = false;
      } else if (summer.compute() != firstSum) {
        collapseX = false;
        break;
      }
    }

    first = true;
    for (y = stage.stretchRect.y; y < stage.stretchRect.y + stage.stretchRect.h; y++) {
      // Compute row
      summer.reset();
      for (x = 0; x < stage.srcSize.w; x++) {
        summer.addNext(getPixel_(stage, srcData, x, y));
      }
      if (first) {
        firstSum = summer.compute();
        first = false;
      } else if (summer.compute() != firstSum) {
        collapseY = false;
        break;
      }
    }

    if (!collapseX && !collapseY) {
      // No-op
      return;
    }

    var fixed = {
      l: stage.stretchRect.x,
      t: stage.stretchRect.y,
      r: stage.srcSize.w - stage.stretchRect.x - stage.stretchRect.w,
      b: stage.srcSize.h - stage.stretchRect.y - stage.stretchRect.h
    };

    var middle = {
      w: collapseX ? 4 : stage.stretchRect.w,
      h: collapseY ? 4 : stage.stretchRect.h
    };

    var size = {
      w: fixed.l + middle.w + fixed.r,
      h: fixed.t + middle.h + fixed.b
    };

    // Redraw components
    var ctx = _imagelib.imagelib.Drawing.context(size);

    // TL
    if (fixed.l && fixed.t) ctx.drawImage(stage.srcCtx.canvas, 0, 0, fixed.l, fixed.t, 0, 0, fixed.l, fixed.t);

    // BL
    if (fixed.l && fixed.b) ctx.drawImage(stage.srcCtx.canvas, 0, stage.srcSize.h - fixed.b, fixed.l, fixed.b, 0, size.h - fixed.b, fixed.l, fixed.b);

    // TR
    if (fixed.r && fixed.t) ctx.drawImage(stage.srcCtx.canvas, stage.srcSize.w - fixed.r, 0, fixed.r, fixed.t, size.w - fixed.r, 0, fixed.r, fixed.t);

    // BR
    if (fixed.r && fixed.b) ctx.drawImage(stage.srcCtx.canvas, stage.srcSize.w - fixed.r, stage.srcSize.h - fixed.b, fixed.r, fixed.b, size.w - fixed.r, size.h - fixed.b, fixed.r, fixed.b);

    // Top
    if (fixed.t) ctx.drawImage(stage.srcCtx.canvas, fixed.l, 0, stage.stretchRect.w, fixed.t, fixed.l, 0, size.w - fixed.l - fixed.r, fixed.t);

    // Left
    if (fixed.l) ctx.drawImage(stage.srcCtx.canvas, 0, fixed.t, fixed.l, stage.stretchRect.h, 0, fixed.t, fixed.l, size.h - fixed.t - fixed.b);

    // Right
    if (fixed.r) ctx.drawImage(stage.srcCtx.canvas, stage.srcSize.w - fixed.r, fixed.t, fixed.r, stage.stretchRect.h, size.w - fixed.r, fixed.t, fixed.r, size.h - fixed.t - fixed.b);

    // Bottom
    if (fixed.b) ctx.drawImage(stage.srcCtx.canvas, fixed.l, stage.srcSize.h - fixed.b, stage.stretchRect.w, fixed.b, fixed.l, size.h - fixed.b, size.w - fixed.l - fixed.r, fixed.b);

    // Middle
    ctx.drawImage(stage.srcCtx.canvas, fixed.l, fixed.t, stage.stretchRect.w, stage.stretchRect.h, fixed.l, fixed.t, size.w - fixed.l - fixed.r, size.h - fixed.t - fixed.b);

    var rects = {
      stretchRect: {
        x: stage.stretchRect.x,
        y: stage.stretchRect.y,
        w: middle.w,
        h: middle.h
      },
      contentRect: {
        x: stage.contentRect.x,
        y: stage.contentRect.y,
        w: stage.contentRect.w + middle.w - stage.stretchRect.w,
        h: stage.contentRect.h + middle.h - stage.stretchRect.h
      },
      opticalBoundsRect: {
        x: stage.opticalBoundsRect.x,
        y: stage.opticalBoundsRect.y,
        w: stage.opticalBoundsRect.w + middle.w - stage.stretchRect.w,
        h: stage.opticalBoundsRect.h + middle.h - stage.stretchRect.h
      }
    };

    stage.name = stage.name + '-STRETCH_TRIMMED';
    stage.loadSourceImage(ctx, rects);
  },


  /**
   * Tries to automatically detect the given region.
   *
   * Region should be one of 'stretch', 'padding', or 'opticalbounds'
   */
  detectRegion: function detectRegion(stage, regionToFind) {
    if (!stage.srcCtx) {
      return null;
    }

    var srcData = stage.srcCtx.getImageData(0, 0, stage.srcSize.w, stage.srcSize.h);

    var x = void 0,
        y = void 0;

    // First find optical bounds
    // This works by taking an alpha value histogram and finding two maxima to determine
    // low and high alphas.
    var alphaHistogram = [];
    for (x = 0; x < stage.srcSize.w; x++) {
      for (y = 0; y < stage.srcSize.h; y++) {
        var _alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        alphaHistogram[_alpha] = alphaHistogram[_alpha] ? alphaHistogram[_alpha] + 1 : 1;
      }
    }

    var max1 = 0,
        max1Freq = 0,
        max2 = 0,
        max2Freq = 0;
    for (var i = 0; i < 256; i++) {
      if (alphaHistogram[i] > max1Freq) {
        max2 = max1;
        max2Freq = max1Freq;
        max1 = i;
        max1Freq = alphaHistogram[i];
      } else if (alphaHistogram[i] > max2Freq) {
        max2 = i;
        max2Freq = alphaHistogram[i];
      }
    }

    var alphaMin = max1 < max2 ? max1 : max2;
    var alphaMax = max1 > max2 ? max1 : max2;

    var ALPHA_THRESHOLD = 5;

    var opticalBoundsRect = { l: -1, r: -1, t: -1, b: -1 };

    // Find left optical bound
    obrLeft: for (x = 0; x < stage.srcSize.w; x++) {
      for (y = 0; y < stage.srcSize.h; y++) {
        var alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (alpha >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.l = x;
          break obrLeft;
        }
      }
    }
    // Find right optical bound
    obrRight: for (x = stage.srcSize.w - 1; x >= 0; x--) {
      for (y = 0; y < stage.srcSize.h; y++) {
        var alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (alpha >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.r = x;
          break obrRight;
        }
      }
    }
    // Find top optical bound
    obrTop: for (y = 0; y < stage.srcSize.h; y++) {
      for (x = 0; x < stage.srcSize.w; x++) {
        var alpha = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (alpha >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.t = y;
          break obrTop;
        }
      }
    }
    // Find bottom optical bound
    obrBottom: for (y = stage.srcSize.h - 1; y >= 0; y--) {
      for (x = 0; x < stage.srcSize.w; x++) {
        var _alpha2 = srcData.data[(y * stage.srcSize.w + x) * 4 + 3];
        if (_alpha2 >= alphaMax - ALPHA_THRESHOLD) {
          opticalBoundsRect.b = y;
          break obrBottom;
        }
      }
    }

    var returnRect = void 0;

    if (opticalBoundsRect.l >= 0 && opticalBoundsRect.r > opticalBoundsRect.l && opticalBoundsRect.t >= 0 && opticalBoundsRect.b > opticalBoundsRect.t) {
      var rect = {
        x: opticalBoundsRect.l,
        y: opticalBoundsRect.t,
        w: opticalBoundsRect.r - opticalBoundsRect.l + 1,
        h: opticalBoundsRect.b - opticalBoundsRect.t + 1
      };

      if (regionToFind == 'opticalbounds' || regionToFind == 'padding') {
        return rect;
      }
    }

    // Next find stretch regions. Only use them if they're within the optical bounds
    if (regionToFind == 'stretch') {
      var newStretchRect = Object.assign({}, stage.stretchRect);

      var summer = new _Summer.Summer();
      var sums = [];
      for (y = 0; y < stage.srcSize.h; y++) {
        // Compute row
        summer.reset();
        for (var _x = 0; _x < stage.srcSize.w; _x++) {
          summer.addNext(getPixel_(stage, srcData, _x, y));
        }
        sums.push(summer.compute());
      }

      var ranges = getEqualRanges_(sums);
      for (var _i = 0; _i < ranges.length; _i++) {
        var range = ranges[_i];
        var passesThreshold = false;
        // Check if this row has a minimum alpha
        for (x = 0; x < stage.srcSize.w; x++) {
          var _alpha3 = srcData.data[(range.start * stage.srcSize.w + x) * 4 + 3];
          if (_alpha3 >= alphaMax - ALPHA_THRESHOLD) {
            passesThreshold = true;
            break;
          }
        }
        if (passesThreshold) {
          newStretchRect.y = range.start;
          newStretchRect.h = range.length;
          if (range.length >= 4) {
            // inset a bit to prevent scaling artifacts
            newStretchRect.y++;
            newStretchRect.h -= 2;
          }
          break;
        }
      }

      summer.reset();
      sums = [];
      for (x = 0; x < stage.srcSize.w; x++) {
        // Compute column
        summer.reset();
        for (y = 0; y < stage.srcSize.h; y++) {
          summer.addNext(getPixel_(stage, srcData, x, y));
        }
        sums.push(summer.compute());
      }

      ranges = getEqualRanges_(sums);
      for (var _i2 = 0; _i2 < ranges.length; _i2++) {
        var _range = ranges[_i2];
        var _passesThreshold = false;
        // Check if this column has a minimum alpha
        for (y = 0; y < stage.srcSize.h; y++) {
          var _alpha4 = srcData.data[(y * stage.srcSize.w + _range.start) * 4 + 3];
          if (_alpha4 >= alphaMax - ALPHA_THRESHOLD) {
            _passesThreshold = true;
            break;
          }
        }

        if (_passesThreshold) {
          newStretchRect.x = _range.start;
          newStretchRect.w = _range.length;
          if (_range.length >= 4) {
            // inset a bit to prevent scaling artifacts
            newStretchRect.x++;
            newStretchRect.w -= 2;
          }
          break;
        }
      }

      return newStretchRect;
    }

    return null;
  }
};

function getPixel_(stage, srcData, x, y) {
  return (srcData.data[(y * stage.srcSize.w + x) * 4 + 0] << 16) + ( // r
  srcData.data[(y * stage.srcSize.w + x) * 4 + 1] << 8) // g
  + (srcData.data[(y * stage.srcSize.w + x) * 4 + 2] << 0) // b
  + (srcData.data[(y * stage.srcSize.w + x) * 4 + 3] << 24); // a
}

function constrain_(size, rect) {
  if (rect.x < 0) {
    rect.w += rect.x;
    rect.x += -rect.x;
  }
  if (rect.x + rect.w > size.w) {
    rect.w = size.w - rect.x;
  }
  if (rect.y < 0) {
    rect.h += rect.y;
    rect.y += -rect.y;
  }
  if (rect.y + rect.h > size.h) {
    rect.h = size.h - rect.y;
  }
  return rect;
}

// Finds ranges of equal values within an array
function getEqualRanges_(arr) {
  var equalRanges = [];
  var start = -1;
  var startVal = 0;
  for (var i = 0; i < arr.length; i++) {
    if (start < 0) {
      start = i;
      startVal = arr[i];
    } else if (arr[i] != startVal) {
      if (start != i - 1) {
        equalRanges.push({ start: start, length: i - start });
      }

      start = i;
      startVal = arr[i];
    }
  }
  if (start != arr.length - 1) {
    equalRanges.push({ start: start, length: arr.length - start });
  }
  return equalRanges.sort(function (x, y) {
    return y.length - x.length;
  });
}

},{"../../imagelib":5,"./Summer":18}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// http://en.wikipedia.org/wiki/Adler32
var MOD_ADLER = 65521;

var Adler32 = function () {
  function Adler32() {
    _classCallCheck(this, Adler32);

    this.reset();
  }

  _createClass(Adler32, [{
    key: "reset",
    value: function reset() {
      this._a = 1;
      this._b = 0;
      this._index = 0;
    }
  }, {
    key: "addNext",
    value: function addNext(value) {
      this._a = (this._a + value) % MOD_ADLER;
      this._b = (this._b + this._a) % MOD_ADLER;
    }
  }, {
    key: "compute",
    value: function compute() {
      return this._b << 16 | this._a;
    }
  }]);

  return Adler32;
}();

var Summer = exports.Summer = Adler32;

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hash = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

var _Util = require('./Util');

var Hash = exports.Hash = {
  bindFormToDocumentHash: function bindFormToDocumentHash(form) {
    var _this = this;

    if (this.boundForm_) {
      console.error('already bound to a form');
      return;
    }

    this.boundForm_ = form;

    form.onChange(_Util.Util.debounce(100, function () {
      _this.currentHash_ = paramsToHash_(form.getValuesSerialized());
      window.history.replaceState({}, '', '#' + _this.currentHash_);
    }));

    var maybeUpdateHash_ = function maybeUpdateHash_() {
      // Don't use document.location.hash because it automatically
      // resolves URI-escaped entities.
      var newHash = paramsToHash_(hashToParams_((document.location.href.match(/#.*/) || [''])[0]));
      if (newHash != _this.currentHash_) {
        form.setValuesSerialized(hashToParams_(newHash));
        _this.currentHash_ = newHash;
      }
    };

    $(window).on('hashchange', maybeUpdateHash_);

    maybeUpdateHash_();
  }
};

function hashToParams_(hash) {
  var params = {};
  hash = hash.replace(/^[?#]/, '');

  hash.split('&').forEach(function (entry) {
    var _entry$split = entry.split('=', 2),
        _entry$split2 = _slicedToArray(_entry$split, 2),
        path = _entry$split2[0],
        val = _entry$split2[1];

    path = decodeURIComponent(path || '');
    val = decodeURIComponent(val || '');

    // Most of the time path == key, but for objects like a.b=1, we need to
    // descend into the hierachy.
    var pathArr = path.split('.');
    var obj = params;
    pathArr.slice(0, -1).forEach(function (pathPart) {
      obj[pathPart] = obj[pathPart] || {};
      obj = obj[pathPart];
    });
    var key = pathArr[pathArr.length - 1];
    if (key in obj) {
      // Handle array values.
      if (Array.isArray(obj[key])) {
        obj[key].push(val);
      } else {
        obj[key] = [obj[key], val];
      }
    } else {
      obj[key] = val;
    }
  });

  return params;
}

function paramsToHash_(params, prefix) {
  var hashArr = [];
  var keyPath_ = function keyPath_(k) {
    return encodeURIComponent((prefix ? prefix + '.' : '') + k);
  };
  var pushKeyValue_ = function pushKeyValue_(k, v) {
    if (v === false) v = 0;
    if (v === true) v = 1;
    hashArr.push(keyPath_(k) + '=' + encodeURIComponent(v.toString()));
  };

  var _loop = function _loop(key) {
    var val = params[key];
    if (val === undefined || val === null) {
      return 'continue';
    }

    if (Array.isArray(val)) {
      val.forEach(function (v) {
        return pushKeyValue_(key, v);
      });
    } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object') {
      hashArr.push(paramsToHash_(val, keyPath_(key)));
    } else {
      pushKeyValue_(key, val);
    }
  };

  for (var key in params) {
    var _ret = _loop(key);

    if (_ret === 'continue') continue;
  }

  return hashArr.join('&');
}

},{"./Util":20}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = exports.Util = {
  getMultBaseMdpi: function getMultBaseMdpi(density) {
    switch (density) {
      case 'xxxhdpi':
        return 4.00;
      case 'xxhdpi':
        return 3.00;
      case 'xhdpi':
        return 2.00;
      case 'hdpi':
        return 1.50;
      case 'tvdpi':
        return 1.33125;
      case 'mdpi':
        return 1.00;
      case 'ldpi':
        return 0.75;
    }
    return 1.0;
  },
  getDpiForDensity: function getDpiForDensity(density) {
    switch (density) {
      case 'xxxhdpi':
        return 640;
      case 'xxhdpi':
        return 480;
      case 'xhdpi':
        return 320;
      case 'hdpi':
        return 240;
      case 'tvdpi':
        return 213;
      case 'mdpi':
        return 160;
      case 'ldpi':
        return 120;
    }
    return 160;
  },
  mult: function mult(s, _mult) {
    var d = {};
    for (var k in s) {
      d[k] = s[k] * _mult;
    }
    return d;
  },
  multRound: function multRound(s, mult) {
    var d = {};
    for (var k in s) {
      d[k] = Math.round(s[k] * mult);
    }
    return d;
  },
  sanitizeResourceName: function sanitizeResourceName(s) {
    return s.toLowerCase().replace(/[\s-\.]/g, '_').replace(/[^\w_]/g, '');
  },


  // TODO: support Safari
  downloadFile: function downloadFile(content, filename) {
    var anchor = $('<a>').hide().appendTo(document.body);
    var blob = content;
    if (!(content instanceof Blob)) {
      blob = new Blob([content], { type: 'application/octet-stream' });
    }
    var url = window.URL.createObjectURL(blob);
    anchor.attr({
      href: url,
      download: filename
    });
    anchor.get(0).click();
    setTimeout(function () {
      anchor.remove();
      window.URL.revokeObjectURL(url);
    }, 5000);
  },
  loadImageFromUri: function loadImageFromUri(uri) {
    return new _Promise(function (resolve, reject) {
      var img = document.createElement('img');
      img.onload = function () {
        return resolve(img);
      };
      img.onerror = function () {
        return reject();
      };
      img.src = uri;
    });
  },
  debugCtx: function debugCtx(ctx) {
    if (Util.debugCtx.$lastEl) {
      Util.debugCtx.$lastEl.remove();
    }

    Util.debugCtx.$lastEl = $('<img>').css({
      position: 'fixed',
      top: 0,
      right: 0,
      zIndex: 100,
      backgroundColor: 'rgba(255, 0, 0, 0.5)',
      pointerEvents: 'none'
    }).attr('src', ctx.canvas.toDataURL()).appendTo(document.body);
  },
  debounce: function debounce(delay, fn) {
    var timeout = void 0;

    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(function () {
        fn.apply(undefined, args);
        timeout = null;
      }, delay);
    };
  }
};

},{"es6-promise":34}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Zip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _zipjsBrowserify = require('zipjs-browserify');

var _zipjsBrowserify2 = _interopRequireDefault(_zipjsBrowserify);

var _Util = require('./Util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var URL = window.URL || window.webkitURL || window.mozURL;

var Zip = exports.Zip = {
  createDownloadifyZipButton: function createDownloadifyZipButton(element, options) {
    return new DownloadZipButton(element, options);
  }
};

var DownloadZipButton = function () {
  function DownloadZipButton(element, options) {
    var _this = this;

    _classCallCheck(this, DownloadZipButton);

    this.fileSpecs_ = [];
    this.el_ = element;
    this.el_.click(function () {
      return _this.generateAndDownloadZipFile_();
    });
    this.updateUI_();
  }

  _createClass(DownloadZipButton, [{
    key: 'setZipFilename',
    value: function setZipFilename(zipFilename) {
      this.zipFilename_ = zipFilename;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.fileSpecs_ = [];
      this.updateUI_();
    }
  }, {
    key: 'add',
    value: function add(spec) {
      this.fileSpecs_.push(spec);
      this.updateUI_();
    }
  }, {
    key: 'updateUI_',
    value: function updateUI_() {
      if (this.fileSpecs_.length && !this.generating_) {
        this.el_.removeAttr('disabled');
      } else {
        this.el_.attr('disabled', 'disabled');
      }
    }
  }, {
    key: 'generateAndDownloadZipFile_',
    value: function generateAndDownloadZipFile_() {
      var _this2 = this;

      var filename = this.zipFilename_ || 'output.zip';
      if (!this.fileSpecs_.length) {
        return;
      }

      this.isGenerating_ = true;
      this.updateUI_();

      _zipjsBrowserify2.default.createWriter(new _zipjsBrowserify2.default.BlobWriter(), function (writer) {
        var i = -1;
        var nextFile_ = function nextFile_() {
          ++i;
          if (i >= _this2.fileSpecs_.length) {
            // close
            writer.close(function (blob) {
              return _Util.Util.downloadFile(blob, filename);
            });
            _this2.isGenerating_ = false;
            _this2.updateUI_();
          } else {
            // add next file
            var fileSpec = _this2.fileSpecs_[i];
            writer.add(fileSpec.name, fileSpec.canvas ? new _zipjsBrowserify2.default.Data64URIReader(fileSpec.canvas.toDataURL()) : new _zipjsBrowserify2.default.TextReader(fileSpec.textData), nextFile_);
          }
        };
        nextFile_();
      }, function (error) {
        console.error(error);
        _this2.isGenerating_ = false;
        _this2.updateUI_();
      });
    }
  }]);

  return DownloadZipButton;
}();

},{"./Util":20,"zipjs-browserify":38}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BooleanField = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _EnumField2 = require('./EnumField');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var BooleanField = exports.BooleanField = function (_EnumField) {
  _inherits(BooleanField, _EnumField);

  function BooleanField(id, params) {
    _classCallCheck(this, BooleanField);

    var _this = _possibleConstructorReturn(this, (BooleanField.__proto__ || Object.getPrototypeOf(BooleanField)).call(this, id, params));

    params.options = [{ id: '1', title: params.onText || 'Yes' }, { id: '0', title: params.offText || 'No' }];
    params.defaultValue = params.defaultValue ? '1' : '0';
    params.buttons = true;
    return _this;
  }

  _createClass(BooleanField, [{
    key: 'getValue',
    value: function getValue() {
      return _get(BooleanField.prototype.__proto__ || Object.getPrototypeOf(BooleanField.prototype), 'getValue', this).call(this) == '1';
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      _get(BooleanField.prototype.__proto__ || Object.getPrototypeOf(BooleanField.prototype), 'setValue', this).call(this, val ? '1' : '0', pauseUi);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue() ? '1' : '0';
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s == '1');
    }
  }]);

  return BooleanField;
}(_EnumField2.EnumField);

},{"./EnumField":24}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorField = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _tinycolor = require('tinycolor2');

var _tinycolor2 = _interopRequireDefault(_tinycolor);

var _Field2 = require('./Field');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ColorField = exports.ColorField = function (_Field) {
  _inherits(ColorField, _Field);

  function ColorField() {
    _classCallCheck(this, ColorField);

    return _possibleConstructorReturn(this, (ColorField.__proto__ || Object.getPrototypeOf(ColorField)).apply(this, arguments));
  }

  _createClass(ColorField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldContainer = $('.form-field-container', _get(ColorField.prototype.__proto__ || Object.getPrototypeOf(ColorField.prototype), 'createUi', this).call(this, container));

      this.el_ = $('<input>').attr('type', 'text').attr('id', this.getHtmlId()).appendTo(fieldContainer);

      var update_ = function update_(color) {
        return _this2.setValue(color, true);
      };

      this.el_.spectrum({
        color: this.getValue().toRgbString(),
        showInput: true,
        showPalette: true,
        showAlpha: this.params_.alpha,
        preferredFormat: 'hex',
        palette: [['#ffffff', '#000000'], ['#f44336', '#e91e63'], ['#9c27b0', '#673ab7'], ['#3f51b5', '#2196f3'], ['#03a9f4', '#00bcd4'], ['#009688', '#4caf50'], ['#8bc34a', '#cddc39'], ['#ffeb3b', '#ffc107'], ['#ff9800', '#ff5722'], ['#9e9e9e', '#607d8b']],
        localStorageKey: 'recentcolors',
        showInitial: true,
        showButtons: false,
        change: update_,
        move: update_
      });
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.value_ || (0, _tinycolor2.default)(this.params_.defaultValue || '#000');
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      var oldValue = this.value_;
      this.value_ = val.hasOwnProperty('_r') ? val : (0, _tinycolor2.default)(val || this.params_.defaultValue || '#000');
      if (!pauseUi) {
        this.el_.spectrum('set', this.value_.toRgbString());
      }
      this.notifyChanged_(val, oldValue);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue().toRgbString();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s);
    }
  }]);

  return ColorField;
}(_Field2.Field);

},{"./Field":25,"tinycolor2":36}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnumField = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Field2 = require('./Field');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var EnumField = exports.EnumField = function (_Field) {
  _inherits(EnumField, _Field);

  function EnumField() {
    _classCallCheck(this, EnumField);

    return _possibleConstructorReturn(this, (EnumField.__proto__ || Object.getPrototypeOf(EnumField)).apply(this, arguments));
  }

  _createClass(EnumField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldContainer = $('.form-field-container', _get(EnumField.prototype.__proto__ || Object.getPrototypeOf(EnumField.prototype), 'createUi', this).call(this, container));

      if (this.params_.buttons) {
        this.el_ = $('<div>').attr('id', this.getHtmlId()).addClass('form-field-buttonset').appendTo(fieldContainer);
      } else {
        this.el_ = $('<div>').addClass('form-field-select').attr('id', this.getHtmlId()).appendTo(fieldContainer);

        this.selectEl_ = $('<select>').attr('id', this.getHtmlId()).on('input', function (ev) {
          return _this2.setValueInternal_($(ev.currentTarget).val(), true);
        }).appendTo(this.el_);
      }

      this.setOptions(this.params_.options);
    }
  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var _this3 = this;

      if (!this.el_) {
        return;
      }

      options = (options || []).map(function (option) {
        return typeof option == 'string' ? { id: option, title: String(option) } : option;
      });

      if (this.params_.buttons) {
        this.el_.empty();
        (options || []).forEach(function (option) {
          $('<input>').attr({
            type: 'radio',
            name: _this3.getHtmlId(),
            id: _this3.getHtmlId() + '-' + option.id,
            value: option.id
          }).on('change', function (ev) {
            return _this3.setValueInternal_($(ev.currentTarget).val(), false);
          }).appendTo(_this3.el_);
          $('<label>').attr('for', _this3.getHtmlId() + '-' + option.id).attr('tabindex', 0).html(option.title).appendTo(_this3.el_);
        });
      } else {
        this.selectEl_.empty();
        (options || []).forEach(function (option) {
          return $('<option>').attr('value', option.id).text(option.title).appendTo(_this3.selectEl_);
        });
      }

      this.setValueInternal_(this.getValue());
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = this.value_;
      if (value === undefined) {
        value = this.params_.defaultValue;
        if (value === undefined && this.params_.options && this.params_.options.length) {
          var firstOption = this.params_.options[0];
          value = 'id' in firstOption ? firstOption.id : String(firstOption);
        }
      }
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      this.setValueInternal_(val, pauseUi);
    }
  }, {
    key: 'setValueInternal_',
    value: function setValueInternal_(val, pauseUi) {
      var oldValue = this.value_;
      // Note, this needs to be its own function because setValue gets
      // overridden in BooleanField and we need access to this method
      // from createUi.
      this.value_ = val;
      if (!pauseUi) {
        if (this.params_.buttons) {
          this.el_.find('input').each(function (i, el) {
            return $(el).prop('checked', $(el).val() == val);
          });
        } else {
          this.selectEl_.val(val);
        }
      }
      this.notifyChanged_(val, oldValue);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s);
    }
  }]);

  return EnumField;
}(_Field2.Field);

},{"./Field":25}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Represents a form field and its associated UI elements. This should be
 * broken out into a more MVC-like architecture in the future.
 */
var Field = exports.Field = function () {
  /**
   * Instantiates a new field with the given ID and parameters.
   * @constructor
   */
  function Field(id, params) {
    _classCallCheck(this, Field);

    this.id_ = id;
    this.params_ = params;
    if (this.params_.onChange) {
      this.onChange(this.params_.onChange);
    }
    this.enabled_ = true;
  }

  /**
   * Sets the form owner of the field. Internally called by
   * {@link studio.forms.Form}.
   * @private
   * @param {studio.forms.Form} form The owner form.
   */


  _createClass(Field, [{
    key: 'setForm_',
    value: function setForm_(form) {
      var _this = this;

      this.form_ = form;
      this.onChange(function (newValue, oldValue) {
        _this.form_.notifyChanged_(_this, newValue, oldValue);
      });
    }

    /**
     * Returns a complete ID.
     * @type String
     */

  }, {
    key: 'getLongId',
    value: function getLongId() {
      return this.form_.id_ + '-' + this.id_;
    }

    /**
     * Returns the ID for the form's UI element (or container).
     * @type String
     */

  }, {
    key: 'getHtmlId',
    value: function getHtmlId() {
      return '_frm-' + this.getLongId();
    }

    /**
     * Generates the UI elements for a form field container. Not very portable
     * outside the Asset Studio UI. Intended to be overriden by descendents.
     * @private
     * @param {HTMLElement} container The destination element to contain the
     * field.
     */

  }, {
    key: 'createUi',
    value: function createUi(container) {
      var formFieldClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'form-field-container';

      container = $(container);
      this.baseEl_ = $('<div>').addClass('form-field-outer').addClass(this.params_.newGroup ? 'is-new-group' : '').append($('<label>').attr('for', this.getHtmlId()).text(this.params_.title).append($('<div>').addClass('form-field-help-text').css('display', this.params_.helpText ? '' : 'none').html(this.params_.helpText))).append($('<div>').addClass(formFieldClass)).appendTo(container);
      return this.baseEl_;
    }
  }, {
    key: 'getEnabled',
    value: function getEnabled() {
      return this.enabled_;
    }

    /**
     * Enables or disables the form field.
     */

  }, {
    key: 'setEnabled',
    value: function setEnabled(enabled) {
      this.enabled_ = enabled;
      if (this.baseEl_) {
        if (enabled) {
          this.baseEl_.removeAttr('disabled');
        } else {
          this.baseEl_.attr('disabled', 'disabled');
        }
      }
    }
  }, {
    key: 'onChange',
    value: function onChange(listener) {
      this.changeListeners_ = (this.changeListeners_ || []).concat([listener]);
    }
  }, {
    key: 'notifyChanged_',
    value: function notifyChanged_(newValue, oldValue) {
      (this.changeListeners_ || []).forEach(function (listener) {
        return listener(newValue, oldValue);
      });
    }
  }]);

  return Field;
}();

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Class defining a data entry form for use in the Asset Studio.
 */
var Form = exports.Form = function () {
  /**
   * Creates a new form with the given parameters.
   * @constructor
   * @param {Array} [params.inputs] A list of inputs
   */
  function Form(params) {
    var _this = this;

    _classCallCheck(this, Form);

    this.id_ = params.id;
    this.params_ = params;
    this.fields_ = params.fields;
    this.fields_.forEach(function (field) {
      return field.setForm_(_this);
    });
    this.fields_.forEach(function (field) {
      return field.createUi(params.container);
    });
  }

  /**
   * Adds an onchange listener.
   */


  _createClass(Form, [{
    key: "onChange",
    value: function onChange(listener) {
      this.changeListeners_ = (this.changeListeners_ || []).concat([listener]);
    }

    /**
     * Notifies that the form contents have changed;
     * @private
     */

  }, {
    key: "notifyChanged_",
    value: function notifyChanged_(field, newValue, oldValue) {
      if (this.pauseNotify_) {
        return;
      }
      (this.changeListeners_ || []).forEach(function (listener) {
        return listener(field, newValue, oldValue);
      });
    }

    /**
     * Returns the current values of the form fields, as an object.
     * @type Object
     */

  }, {
    key: "getValues",
    value: function getValues() {
      var values = {};
      this.fields_.forEach(function (field) {
        return values[field.id_] = field.getValue();
      });
      return values;
    }

    /**
     * Returns all available serialized values of the form fields, as an object.
     * All values in the returned object are either strings or objects.
     * @type Object
     */

  }, {
    key: "getValuesSerialized",
    value: function getValuesSerialized() {
      var values = {};
      this.fields_.forEach(function (field) {
        var value = field.serializeValue ? field.serializeValue() : undefined;
        if (value !== undefined) {
          values[field.id_] = field.serializeValue();
        }
      });

      return values;
    }

    /**
     * Sets the form field values for the key/value pairs in the given object.
     * Values must be serialized forms of the form values. The form must be
     * initialized before calling this method.
     */

  }, {
    key: "setValuesSerialized",
    value: function setValuesSerialized(serializedValues) {
      this.pauseNotify_ = true;
      this.fields_.filter(function (field) {
        return field.id_ in serializedValues && field.deserializeValue;
      }).forEach(function (field) {
        return field.deserializeValue(serializedValues[field.id_]);
      });
      this.pauseNotify_ = false;
      this.notifyChanged_();
    }
  }]);

  return Form;
}();

},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GradientField = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _tinycolor = require('tinycolor2');

var _tinycolor2 = _interopRequireDefault(_tinycolor);

var _Field2 = require('./Field');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GradientField = exports.GradientField = function (_Field) {
  _inherits(GradientField, _Field);

  function GradientField() {
    _classCallCheck(this, GradientField);

    return _possibleConstructorReturn(this, (GradientField.__proto__ || Object.getPrototypeOf(GradientField)).apply(this, arguments));
  }

  _createClass(GradientField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldContainer = $('.form-field-container-row', _get(GradientField.prototype.__proto__ || Object.getPrototypeOf(GradientField.prototype), 'createUi', this).call(this, container, 'form-field-container-row'));

      this.from_el_ = $('<input>').attr('type', 'text').attr('id', this.getHtmlId() + "-from").appendTo(fieldContainer);

      this.to_el_ = $('<input>').attr('type', 'text').attr('id', this.getHtmlId() + "-to").appendTo(fieldContainer);

      var from_update_ = function from_update_(color) {
        return _this2.setFromValue(color, true);
      };
      var to_update_ = function to_update_(color) {
        return _this2.setToValue(color, true);
      };

      var palette = [['#ffffff', '#000000'], ['#f44336', '#e91e63'], ['#9c27b0', '#673ab7'], ['#3f51b5', '#2196f3'], ['#03a9f4', '#00bcd4'], ['#009688', '#4caf50'], ['#8bc34a', '#cddc39'], ['#ffeb3b', '#ffc107'], ['#ff9800', '#ff5722'], ['#9e9e9e', '#607d8b']];

      this.from_el_.spectrum({
        color: this.getValue().from.toRgbString(),
        showInput: true,
        showPalette: true,
        showAlpha: this.params_.alpha,
        preferredFormat: 'hex',
        palette: palette,
        localStorageKey: 'recentcolors',
        showInitial: true,
        showButtons: false,
        change: from_update_,
        move: from_update_
      });

      this.to_el_.spectrum({
        color: this.getValue().to.toRgbString(),
        showInput: true,
        showPalette: true,
        showAlpha: this.params_.alpha,
        preferredFormat: 'hex',
        palette: palette,
        localStorageKey: 'recentcolors',
        showInitial: true,
        showButtons: false,
        change: to_update_,
        move: to_update_
      });
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return {
        'from': this.from_value_ || (0, _tinycolor2.default)(this.params_.defaultFrom || '#000'),
        'to': this.to_value_ || (0, _tinycolor2.default)(this.params_.defaultTo || '#000')
      };
    }
  }, {
    key: 'setFromValue',
    value: function setFromValue(val, pauseUi) {
      var oldValue = this.from_value_;
      this.from_value_ = val.hasOwnProperty('_r') ? val : (0, _tinycolor2.default)(val || this.params_.defaultFrom || '#000');
      if (!pauseUi) {
        this.from_el_.spectrum('set', this.from_value_.toRgbString());
      }
      this.notifyChanged_(val, oldValue);
    }
  }, {
    key: 'setToValue',
    value: function setToValue(val, pauseUi) {
      var oldValue = this.to_value_;
      this.to_value_ = val.hasOwnProperty('_r') ? val : (0, _tinycolor2.default)(val || this.params_.defaultTo || '#000');
      if (!pauseUi) {
        this.to_el_.spectrum('set', this.to_value_.toRgbString());
      }
      this.notifyChanged_(val, oldValue);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue().from.toRgbString() + " " + this.getValue().to.toRgbString();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      var split = s.split();
      if (split[0] !== undefined) {
        this.setFromValue(split[0]);
      }
      if (split[1] !== undefined) {
        this.setToValue(split[1]);
      }
    }
  }]);

  return GradientField;
}(_Field2.Field);

},{"./Field":25,"tinycolor2":36}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CLIPART_NAMES = exports.CLIPART_NAMES = ['3d_rotation', 'ac_unit', 'access_alarm', 'access_alarms', 'access_time', 'accessibility', 'accessible', 'account_balance', 'account_balance_wallet', 'account_box', 'account_circle', 'adb', 'add', 'add_a_photo', 'add_alarm', 'add_alert', 'add_box', 'add_circle', 'add_circle_outline', 'add_location', 'add_shopping_cart', 'add_to_photos', 'add_to_queue', 'adjust', 'airline_seat_flat', 'airline_seat_flat_angled', 'airline_seat_individual_suite', 'airline_seat_legroom_extra', 'airline_seat_legroom_normal', 'airline_seat_legroom_reduced', 'airline_seat_recline_extra', 'airline_seat_recline_normal', 'airplanemode_active', 'airplanemode_inactive', 'airplay', 'airport_shuttle', 'alarm', 'alarm_add', 'alarm_off', 'alarm_on', 'album', 'all_inclusive', 'all_out', 'android', 'announcement', 'apps', 'archive', 'arrow_back', 'arrow_downward', 'arrow_drop_down', 'arrow_drop_down_circle', 'arrow_drop_up', 'arrow_forward', 'arrow_upward', 'art_track', 'aspect_ratio', 'assessment', 'assignment', 'assignment_ind', 'assignment_late', 'assignment_return', 'assignment_returned', 'assignment_turned_in', 'assistant', 'assistant_photo', 'attach_file', 'attach_money', 'attachment', 'audiotrack', 'autorenew', 'av_timer', 'backspace', 'backup', 'battery_alert', 'battery_charging_full', 'battery_full', 'battery_std', 'battery_unknown', 'beach_access', 'beenhere', 'block', 'bluetooth', 'bluetooth_audio', 'bluetooth_connected', 'bluetooth_disabled', 'bluetooth_searching', 'blur_circular', 'blur_linear', 'blur_off', 'blur_on', 'book', 'bookmark', 'bookmark_border', 'border_all', 'border_bottom', 'border_clear', 'border_color', 'border_horizontal', 'border_inner', 'border_left', 'border_outer', 'border_right', 'border_style', 'border_top', 'border_vertical', 'branding_watermark', 'brightness_1', 'brightness_2', 'brightness_3', 'brightness_4', 'brightness_5', 'brightness_6', 'brightness_7', 'brightness_auto', 'brightness_high', 'brightness_low', 'brightness_medium', 'broken_image', 'brush', 'bubble_chart', 'bug_report', 'build', 'burst_mode', 'business', 'business_center', 'cached', 'cake', 'call', 'call_end', 'call_made', 'call_merge', 'call_missed', 'call_missed_outgoing', 'call_received', 'call_split', 'call_to_action', 'camera', 'camera_alt', 'camera_enhance', 'camera_front', 'camera_rear', 'camera_roll', 'cancel', 'card_giftcard', 'card_membership', 'card_travel', 'casino', 'cast', 'cast_connected', 'center_focus_strong', 'center_focus_weak', 'change_history', 'chat', 'chat_bubble', 'chat_bubble_outline', 'check', 'check_box', 'check_box_outline_blank', 'check_circle', 'chevron_left', 'chevron_right', 'child_care', 'child_friendly', 'chrome_reader_mode', 'class', 'clear', 'clear_all', 'close', 'closed_caption', 'cloud', 'cloud_circle', 'cloud_done', 'cloud_download', 'cloud_off', 'cloud_queue', 'cloud_upload', 'code', 'collections', 'collections_bookmark', 'color_lens', 'colorize', 'comment', 'compare', 'compare_arrows', 'computer', 'confirmation_number', 'contact_mail', 'contact_phone', 'contacts', 'content_copy', 'content_cut', 'content_paste', 'control_point', 'control_point_duplicate', 'copyright', 'create', 'create_new_folder', 'credit_card', 'crop', 'crop_16_9', 'crop_3_2', 'crop_5_4', 'crop_7_5', 'crop_din', 'crop_free', 'crop_landscape', 'crop_original', 'crop_portrait', 'crop_rotate', 'crop_square', 'dashboard', 'data_usage', 'date_range', 'dehaze', 'delete', 'delete_forever', 'delete_sweep', 'description', 'desktop_mac', 'desktop_windows', 'details', 'developer_board', 'developer_mode', 'device_hub', 'devices', 'devices_other', 'dialer_sip', 'dialpad', 'directions', 'directions_bike', 'directions_boat', 'directions_bus', 'directions_car', 'directions_railway', 'directions_run', 'directions_subway', 'directions_transit', 'directions_walk', 'disc_full', 'dns', 'do_not_disturb', 'do_not_disturb_alt', 'do_not_disturb_off', 'do_not_disturb_on', 'dock', 'domain', 'done', 'done_all', 'donut_large', 'donut_small', 'drafts', 'drag_handle', 'drive_eta', 'dvr', 'edit', 'edit_location', 'eject', 'email', 'enhanced_encryption', 'equalizer', 'error', 'error_outline', 'euro_symbol', 'ev_station', 'event', 'event_available', 'event_busy', 'event_note', 'event_seat', 'exit_to_app', 'expand_less', 'expand_more', 'explicit', 'explore', 'exposure', 'exposure_neg_1', 'exposure_neg_2', 'exposure_plus_1', 'exposure_plus_2', 'exposure_zero', 'extension', 'face', 'fast_forward', 'fast_rewind', 'favorite', 'favorite_border', 'featured_play_list', 'featured_video', 'feedback', 'fiber_dvr', 'fiber_manual_record', 'fiber_new', 'fiber_pin', 'fiber_smart_record', 'file_download', 'file_upload', 'filter', 'filter_1', 'filter_2', 'filter_3', 'filter_4', 'filter_5', 'filter_6', 'filter_7', 'filter_8', 'filter_9', 'filter_9_plus', 'filter_b_and_w', 'filter_center_focus', 'filter_drama', 'filter_frames', 'filter_hdr', 'filter_list', 'filter_none', 'filter_tilt_shift', 'filter_vintage', 'find_in_page', 'find_replace', 'fingerprint', 'first_page', 'fitness_center', 'flag', 'flare', 'flash_auto', 'flash_off', 'flash_on', 'flight', 'flight_land', 'flight_takeoff', 'flip', 'flip_to_back', 'flip_to_front', 'folder', 'folder_open', 'folder_shared', 'folder_special', 'font_download', 'format_align_center', 'format_align_justify', 'format_align_left', 'format_align_right', 'format_bold', 'format_clear', 'format_color_fill', 'format_color_reset', 'format_color_text', 'format_indent_decrease', 'format_indent_increase', 'format_line_spacing', 'format_list_bulleted', 'format_list_numbered', 'format_paint', 'format_quote', 'format_shapes', 'format_size', 'format_strikethrough', 'format_textdirection_l_to_r', 'format_textdirection_r_to_l', 'format_underlined', 'forum', 'forward', 'forward_10', 'forward_30', 'forward_5', 'free_breakfast', 'fullscreen', 'fullscreen_exit', 'functions', 'g_translate', 'gamepad', 'games', 'gavel', 'gesture', 'get_app', 'gif', 'golf_course', 'gps_fixed', 'gps_not_fixed', 'gps_off', 'grade', 'gradient', 'grain', 'grid_off', 'grid_on', 'group', 'group_add', 'group_work', 'hd', 'hdr_off', 'hdr_on', 'hdr_strong', 'hdr_weak', 'headset', 'healing', 'hearing', 'help', 'help_outline', 'high_quality', 'highlight', 'highlight_off', 'history', 'home', 'hot_tub', 'hotel', 'hourglass_empty', 'hourglass_full', 'http', 'https', 'image', 'image_aspect_ratio', 'import_contacts', 'import_export', 'important_devices', 'inbox', 'indeterminate_check_box', 'info', 'info_outline', 'input', 'insert_chart', 'insert_comment', 'insert_drive_file', 'insert_emoticon', 'insert_invitation', 'insert_link', 'insert_photo', 'invert_colors', 'invert_colors_off', 'iso', 'keyboard', 'keyboard_arrow_down', 'keyboard_arrow_left', 'keyboard_arrow_right', 'keyboard_arrow_up', 'keyboard_backspace', 'keyboard_capslock', 'keyboard_hide', 'keyboard_return', 'keyboard_tab', 'keyboard_voice', 'kitchen', 'label', 'label_outline', 'landscape', 'language', 'laptop', 'laptop_chromebook', 'laptop_mac', 'laptop_windows', 'last_page', 'launch', 'layers', 'layers_clear', 'leak_add', 'leak_remove', 'lens', 'library_add', 'library_books', 'lightbulb_outline', 'line_style', 'line_weight', 'linear_scale', 'link', 'linked_camera', 'list', 'live_help', 'live_tv', 'local_activity', 'local_airport', 'local_atm', 'local_bar', 'local_cafe', 'local_car_wash', 'local_convenience_store', 'local_dining', 'local_drink', 'local_florist', 'local_gas_station', 'local_grocery_store', 'local_hospital', 'local_hotel', 'local_laundry_service', 'local_library', 'local_mall', 'local_movies', 'local_offer', 'local_parking', 'local_pharmacy', 'local_phone', 'local_pizza', 'local_play', 'local_post_office', 'local_printshop', 'local_see', 'local_shipping', 'local_taxi', 'location_city', 'location_disabled', 'location_off', 'location_on', 'location_searching', 'lock', 'lock_open', 'lock_outline', 'looks', 'looks_3', 'looks_4', 'looks_5', 'looks_6', 'looks_one', 'looks_two', 'loop', 'loupe', 'low_priority', 'loyalty', 'mail', 'mail_outline', 'map', 'markunread', 'markunread_mailbox', 'memory', 'menu', 'merge_type', 'message', 'mms', 'mode_comment', 'mode_edit', 'monetization_on', 'money_off', 'monochrome_photos', 'mood', 'mood_bad', 'more', 'more_horiz', 'more_vert', 'motorcycle', 'mouse', 'move_to_inbox', 'movie', 'movie_creation', 'movie_filter', 'multiline_chart', 'my_location', 'nature', 'nature_people', 'navigate_before', 'navigate_next', 'navigation', 'near_me', 'network_cell', 'network_check', 'network_locked', 'network_wifi', 'new_releases', 'next_week', 'nfc', 'no_encryption', 'no_sim', 'not_interested', 'note', 'note', 'note_add', 'notifications', 'notifications_active', 'notifications_none', 'notifications_off', 'notifications_paused', 'offline_pin', 'ondemand_video', 'opacity', 'open_in_browser', 'open_in_new', 'open_with', 'pages', 'pageview', 'palette', 'pan_tool', 'panorama', 'panorama_fish_eye', 'panorama_horizontal', 'panorama_vertical', 'panorama_wide_angle', 'party_mode', 'pause', 'pause_circle_filled', 'pause_circle_outline', 'payment', 'people', 'people_outline', 'perm_contact_calendar', 'perm_data_setting', 'perm_device_information', 'perm_identity', 'perm_media', 'perm_phone_msg', 'perm_scan_wifi', 'person', 'person_add', 'person_outline', 'person_pin', 'person_pin_circle', 'personal_video', 'pets', 'phone', 'phone_android', 'phone_bluetooth_speaker', 'phone_forwarded', 'phone_in_talk', 'phone_iphone', 'phone_locked', 'phone_missed', 'phone_paused', 'phonelink', 'phonelink_erase', 'phonelink_lock', 'phonelink_off', 'phonelink_ring', 'phonelink_setup', 'photo', 'photo_album', 'photo_camera', 'photo_filter', 'photo_library', 'photo_size_select_actual', 'photo_size_select_large', 'photo_size_select_small', 'picture_as_pdf', 'picture_in_picture', 'picture_in_picture_alt', 'pie_chart', 'pie_chart_outlined', 'pin_drop', 'place', 'play_arrow', 'play_circle_filled', 'play_circle_outline', 'play_for_work', 'playlist_add', 'playlist_add_check', 'playlist_play', 'plus_one', 'poll', 'polymer', 'pool', 'portable_wifi_off', 'portrait', 'power', 'power_input', 'power_settings_new', 'pregnant_woman', 'present_to_all', 'print', 'priority_high', 'publish', 'query_builder', 'question_answer', 'queue', 'queue_play_next', 'radio', 'radio_button_checked', 'radio_button_unchecked', 'rate_review', 'receipt', 'recent_actors', 'record_voice_over', 'redeem', 'redo', 'refresh', 'remove', 'remove_circle', 'remove_circle_outline', 'remove_from_queue', 'remove_red_eye', 'remove_shopping_cart', 'reorder', 'repeat', 'repeat_one', 'replay', 'replay_10', 'replay_30', 'replay_5', 'reply', 'reply_all', 'report', 'report_problem', 'restaurant', 'restaurant_menu', 'restore', 'restore_page', 'ring_volume', 'room', 'room_service', 'rotate_90_degrees_ccw', 'rotate_left', 'rotate_right', 'rounded_corner', 'router', 'rowing', 'rss_feed', 'rv_hookup', 'rv_hookup', 'satellite', 'save', 'scanner', 'schedule', 'school', 'screen_lock_landscape', 'screen_lock_portrait', 'screen_lock_rotation', 'screen_rotation', 'screen_share', 'sd_card', 'sd_storage', 'search', 'security', 'select_all', 'send', 'sentiment_dissatisfied', 'sentiment_neutral', 'sentiment_satisfied', 'sentiment_very_dissatisfied', 'sentiment_very_satisfied', 'settings', 'settings_applications', 'settings_backup_restore', 'settings_bluetooth', 'settings_brightness', 'settings_cell', 'settings_ethernet', 'settings_input_antenna', 'settings_input_component', 'settings_input_composite', 'settings_input_hdmi', 'settings_input_svideo', 'settings_overscan', 'settings_phone', 'settings_power', 'settings_remote', 'settings_system_daydream', 'settings_voice', 'share', 'shop', 'shop_two', 'shopping_basket', 'shopping_cart', 'short_text', 'show_chart', 'shuffle', 'signal_cellular_4_bar', 'signal_cellular_connected_no_internet_4_bar', 'signal_cellular_no_sim', 'signal_cellular_null', 'signal_cellular_off', 'signal_wifi_4_bar', 'signal_wifi_4_bar_lock', 'signal_wifi_off', 'sim_card', 'sim_card_alert', 'skip_next', 'skip_previous', 'slideshow', 'slow_motion_video', 'smartphone', 'smoke_free', 'smoking_rooms', 'sms', 'sms_failed', 'snooze', 'sort', 'sort_by_alpha', 'spa', 'space_bar', 'speaker', 'speaker_group', 'speaker_notes', 'speaker_notes_off', 'speaker_phone', 'spellcheck', 'star', 'star_border', 'star_half', 'stars', 'stay_current_landscape', 'stay_current_portrait', 'stay_primary_landscape', 'stay_primary_portrait', 'stop', 'stop_screen_share', 'storage', 'store', 'store_mall_directory', 'straighten', 'streetview', 'strikethrough_s', 'style', 'subdirectory_arrow_left', 'subdirectory_arrow_right', 'subject', 'subscriptions', 'subtitles', 'subway', 'supervisor_account', 'surround_sound', 'swap_calls', 'swap_horiz', 'swap_vert', 'swap_vertical_circle', 'switch_camera', 'switch_video', 'sync', 'sync_disabled', 'sync_problem', 'system_update', 'system_update_alt', 'tab', 'tab_unselected', 'tablet', 'tablet_android', 'tablet_mac', 'tag_faces', 'tap_and_play', 'terrain', 'text_fields', 'text_format', 'textsms', 'texture', 'theaters', 'thumb_down', 'thumb_up', 'thumbs_up_down', 'time_to_leave', 'timelapse', 'timeline', 'timer', 'timer_10', 'timer_3', 'timer_off', 'title', 'toc', 'today', 'toll', 'tonality', 'touch_app', 'toys', 'track_changes', 'train', 'tram', 'transfer_within_a_station', 'transform', 'translate', 'trending_down', 'trending_flat', 'trending_up', 'tune', 'turned_in', 'turned_in_not', 'tv', 'unarchive', 'undo', 'unfold_less', 'unfold_more', 'update', 'usb', 'verified_user', 'vertical_align_bottom', 'vertical_align_center', 'vertical_align_top', 'vibration', 'video_call', 'video_label', 'video_library', 'videocam', 'videocam_off', 'videogame_asset', 'view_agenda', 'view_array', 'view_carousel', 'view_column', 'view_comfy', 'view_compact', 'view_day', 'view_headline', 'view_list', 'view_module', 'view_quilt', 'view_stream', 'view_week', 'vignette', 'visibility', 'visibility_off', 'voice_chat', 'voicemail', 'volume_down', 'volume_mute', 'volume_off', 'volume_up', 'vpn_key', 'vpn_lock', 'wallpaper', 'warning', 'watch', 'watch_later', 'wb_auto', 'wb_cloudy', 'wb_incandescent', 'wb_iridescent', 'wb_sunny', 'wc', 'web', 'web_asset', 'weekend', 'whatshot', 'widgets', 'wifi', 'wifi_lock', 'wifi_tethering', 'work', 'wrap_text', 'youtube_searched_for', 'zoom_in', 'zoom_out', 'zoom_out_map'];

},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageField = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _webfontloader = require('webfontloader');

var _webfontloader2 = _interopRequireDefault(_webfontloader);

var _Form = require('./Form');

var _Field2 = require('./Field');

var _TextField = require('./TextField');

var _RangeField = require('./RangeField');

var _BooleanField = require('./BooleanField');

var _EnumField = require('./EnumField');

var _Util = require('../Util');

var _imagelib = require('../../imagelib');

var _ImageFieldClipart = require('./ImageField-clipart');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise; /*
                                                                                           * Copyright 2016 Google Inc.
                                                                                           *
                                                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                           * you may not use this file except in compliance with the License.
                                                                                           * You may obtain a copy of the License at
                                                                                           *
                                                                                           *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                           *
                                                                                           * Unless required by applicable law or agreed to in writing, software
                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                           * See the License for the specific language governing permissions and
                                                                                           * limitations under the License.
                                                                                           */

var WEB_FONTS_API_KEY = 'AIzaSyAtSe8wlXPCUaLQ4LTyPKpbzBBPJAzEXmU';
var WEB_FONTS_API_URL = 'https://www.googleapis.com/webfonts/v1/webfonts?key=' + WEB_FONTS_API_KEY + '&fields=items(family)';
var WEB_FONTS_CACHE_TIME = 60 * 60 * 1000; // 1 hour


/**
 * Represents a form field for image values.
 */

var ImageField = exports.ImageField = function (_Field) {
  _inherits(ImageField, _Field);

  function ImageField(id, params) {
    _classCallCheck(this, ImageField);

    var _this = _possibleConstructorReturn(this, (ImageField.__proto__ || Object.getPrototypeOf(ImageField)).call(this, id, params));

    _this.valueType_ = null;
    _this.textParams_ = {};
    _this.imageParams_ = {};
    _this.clipartSrc_ = null;
    _this.lastNotifiedValue_ = {};
    _this.spaceFormValues_ = {}; // cache
    return _this;
  }

  _createClass(ImageField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldUI = _get(ImageField.prototype.__proto__ || Object.getPrototypeOf(ImageField.prototype), 'createUi', this).call(this, container);
      var fieldContainer = $('.form-field-container', fieldUI);

      // Set up drag+drop on the entire field container
      fieldUI.addClass('form-field-image');
      this.setupDropTarget_(fieldUI);

      // Create radio buttons
      this.el_ = $('<div>').attr('id', this.getHtmlId()).addClass('form-field-buttonset').appendTo(fieldContainer);

      var types;
      if (this.params_.imageOnly) {
        types = [['image', 'Select image']];
      } else {
        types = [['image', 'Image'], ['clipart', 'Clipart'], ['text', 'Text']];
      }

      var typeEls = {};

      types.forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            id = _ref2[0],
            label = _ref2[1];

        $('<input>').attr({
          type: 'radio',
          name: _this2.getHtmlId(),
          id: _this2.getHtmlId() + '-' + id,
          value: id
        }).appendTo(_this2.el_);
        typeEls[id] = $('<label>').attr('for', _this2.getHtmlId() + '-' + id).attr('tabindex', 0).text(label).appendTo(_this2.el_);
      });

      // Prepare UI for the 'image' type
      this.fileEl_ = $('<input>').addClass('form-image-hidden-file-field').attr({
        id: this.getHtmlId(),
        type: 'file',
        accept: 'image/*'
      }).on('change', function () {
        return _this2.loadImage_(_this2.fileEl_.get(0).files);
      }).appendTo(this.el_);

      typeEls.image.click(function (evt) {
        _this2.fileEl_.trigger('click');
        _this2.setValueType_(null);
        _this2.renderValueAndNotifyChanged_();
        evt.preventDefault();
        return false;
      });

      // Prepare UI for the 'clipart' type
      if (!this.params_.imageOnly) {
        var clipartParamsEl = $('<div>').addClass('form-image-type-params form-image-type-params-clipart is-hidden').appendTo(fieldContainer);

        var clipartListEl = $('<div>').addClass('form-image-clipart-list').addClass('cancel-parent-scroll').appendTo(clipartParamsEl);

        _ImageFieldClipart.CLIPART_NAMES.forEach(function (clipartSrc) {
          $('<div>').addClass('form-image-clipart-item').attr('data-name', clipartSrc).attr('title', clipartSrc).text(clipartSrc).click(function () {
            return _this2.loadClipart_(clipartSrc);
          }).appendTo(clipartListEl);
        });

        this.$clipartItems = clipartListEl.find('.form-image-clipart-item');

        var clipartFilterEl = $('<input>').addClass('form-image-clipart-filter').attr('placeholder', 'Find clipart').on('input', function (ev) {
          var $filter = $(ev.currentTarget);
          var val = $filter.val().toLowerCase().replace(/[^\w]+/g, '');
          if (!val) {
            _this2.$clipartItems.show();
          } else {
            _this2.$clipartItems.each(function (_, item) {
              $(item).toggle($(item).attr('title').indexOf(val) >= 0);
            });
          }
        }).prependTo(clipartParamsEl);

        var clipartAttributionEl = $('<div>').addClass('form-image-clipart-attribution').html('\n              For clipart sources, visit\n              <a target="_blank"\n                 class="external-link"\n                 href="https://github.com/google/material-design-icons">\n              Material Design Icons on GitHub</a>\n              ').appendTo(clipartParamsEl);

        typeEls.clipart.click(function (evt) {
          _this2.setValueType_('clipart');
          _this2.renderValueAndNotifyChanged_();
        });

        // Prepare UI for the 'text' type
        var textParamsEl = $('<div>').addClass('form-subform form-image-type-params form-image-type-params-text is-hidden').appendTo(fieldContainer);

        var fontFamilyField = void 0;
        this.textForm_ = new _Form.Form({
          id: this.form_.id_ + '-' + this.id_ + '-textform',
          container: textParamsEl,
          fields: [new _TextField.TextField('text', {
            title: 'Text'
          }), fontFamilyField = new _EnumField.EnumField('font', {
            title: 'Font',
            helpText: 'From fonts.google.com'
          })]
        });
        this.loadGoogleWebFontsList_().then(function (fonts) {
          return fontFamilyField.setOptions([''].concat(fonts));
        });

        var tryLoadWebFontDebounced_ = _Util.Util.debounce(500, function () {
          return _this2.tryLoadWebFont_();
        });
        this.textForm_.onChange(function () {
          var values = _this2.textForm_.getValues();
          _this2.textParams_.text = values.text;
          _this2.textParams_.fontStack = values.font || 'Roboto, sans-serif';
          tryLoadWebFontDebounced_();
          _this2.renderValueAndNotifyChanged_();
        });

        typeEls.text.click(function (evt) {
          _this2.setValueType_('text');
          _this2.renderValueAndNotifyChanged_();
        });
      }

      // Create spacing subform
      if (!this.params_.noTrimForm) {
        var spaceFormContainer = $('<div>').addClass('form-subform').appendTo(fieldContainer);
        this.spaceFormValues_ = {};
        this.spaceForm_ = new _Form.Form({
          id: this.form_.id_ + '-' + this.id_ + '-spaceform',
          container: spaceFormContainer,
          fields: [this.spaceFormTrimField_ = new _BooleanField.BooleanField('trim', {
            title: 'Trim whitespace',
            defaultValue: true,
            offText: 'Don\'t trim',
            onText: 'Trim'
          }), this.spaceFormPaddingField_ = new _RangeField.RangeField('pad', {
            title: 'Padding',
            defaultValue: this.params_.defaultValuePadding || 0,
            min: -0.1,
            max: 0.5, // 1/2 of min(width, height)
            step: 0.01,
            textFn: function textFn(v) {
              return (v * 100).toFixed(0) + '%';
            }
          }), this.spaceFormTopField_ = new _RangeField.RangeField('top', {
            title: 'Top adjustment (0 = vertically aligned)',
            defaultValue: this.params_.defaultValueTop || 0,
            min: -0.5,
            max: 0.5, // 1/2 of min(width, height)
            step: 0.01,
            textFn: function textFn(v) {
              return (v * 100).toFixed(0) + '%';
            }
          }), this.spaceFormLeftField_ = new _RangeField.RangeField('left', {
            title: 'Left adjustment (0 = horizontally aligned)',
            defaultValue: this.params_.defaultValueLeft || 0,
            min: -0.5,
            max: 0.5, // 1/2 of min(width, height)
            step: 0.01,
            textFn: function textFn(v) {
              return (v * 100).toFixed(0) + '%';
            }
          })]
        });
        this.spaceForm_.onChange(function () {
          _this2.spaceFormValues_ = _this2.spaceForm_.getValues();
          _this2.renderValueAndNotifyChanged_();
        });
        this.spaceFormValues_ = this.spaceForm_.getValues();
      } else {
        this.spaceFormValues_ = {};
      }

      // Create image preview element
      if (!this.params_.noPreview) {
        this.imagePreview_ = $('<canvas>').addClass('form-image-preview').hide().appendTo(fieldContainer.parent());
      }

      if (this.params_.defaultValueClipart) {
        setTimeout(function () {
          if (!_this2.valueType_) {
            _this2.loadClipart_(_this2.params_.defaultValueClipart);
          }
        }, 0);
      }
    }
  }, {
    key: 'setupDropTarget_',
    value: function setupDropTarget_(el) {
      var _this3 = this;

      var $el = this.params_.dropTarget ? $(this.params_.dropTarget) : $(el);
      var enterLeaveTimeout = void 0;

      $el.addClass('form-field-drop-target').on('dragenter', function (ev) {
        ev.preventDefault();
        if (enterLeaveTimeout) {
          clearTimeout(enterLeaveTimeout);
          enterLeaveTimeout = null;
        }
        $el.addClass('drag-hover');
      }).on('dragleave', function (ev) {
        ev.preventDefault();
        if (enterLeaveTimeout) {
          clearTimeout(enterLeaveTimeout);
        }
        enterLeaveTimeout = setTimeout(function () {
          return $el.removeClass('drag-hover');
        }, 100);
      }).on('dragover', function (ev) {
        ev.preventDefault();
        if (enterLeaveTimeout) {
          clearTimeout(enterLeaveTimeout);
          enterLeaveTimeout = null;
        }
        ev.originalEvent.dataTransfer.dropEffect = 'copy';
      }).on('drop', function (ev) {
        $el.removeClass('drag-hover');
        ev.stopPropagation();
        ev.preventDefault();
        _this3.loadImage_(ev.originalEvent.dataTransfer.files);
      });
    }
  }, {
    key: 'loadImage_',
    value: function loadImage_(fileList) {
      var _this4 = this;

      ImageField.loadImageFromFileList(fileList).then(function (ret) {
        if (!ret) {
          return;
        }

        _this4.setValueType_('image');
        _this4.imageParams_ = ret;
        _this4.imageFilename_ = ret.name.replace(/\.[^.]+?$/, ''); // basename
        _this4.renderValueAndNotifyChanged_();
      });
    }
  }, {
    key: 'loadGoogleWebFontsList_',
    value: function loadGoogleWebFontsList_() {
      return new _Promise(function (resolve, reject) {
        if ('assetStudioWebFontsCache' in localStorage) {
          var _JSON$parse = JSON.parse(localStorage.assetStudioWebFontsCache),
              fetchTime = _JSON$parse.fetchTime,
              fonts = _JSON$parse.fonts;

          if (Number(new Date()) - fetchTime < WEB_FONTS_CACHE_TIME) {
            // use cache
            resolve(fonts);
            return;
          }
        }

        $.ajax({
          url: WEB_FONTS_API_URL,
          dataType: 'json'
        }).then(function (data) {
          var fonts = data.items.map(function (item) {
            return item.family;
          });
          localStorage.assetStudioWebFontsCache = JSON.stringify({
            fetchTime: Number(new Date()),
            fonts: fonts
          });
          resolve(fonts);
        }, function (e) {
          return reject(e);
        });
      });
    }
  }, {
    key: 'tryLoadWebFont_',
    value: function tryLoadWebFont_() {
      var _this5 = this;

      var desiredFont = this.textForm_.getValues().font;
      if (this.loadedWebFont_ == desiredFont || !desiredFont) {
        return;
      }

      _webfontloader2.default.load({
        google: {
          families: [desiredFont]
        },
        active: function active() {
          _this5.loadedWebFont_ = desiredFont;
          _this5.renderValueAndNotifyChanged_();
        }
      });
    }
  }, {
    key: 'setValueType_',
    value: function setValueType_(type) {
      this.valueType_ = type;
      $('input', this.el_).prop('checked', false);
      $('.form-image-type-params', this.el_.parent()).addClass('is-hidden');
      if (type) {
        $('#' + this.getHtmlId() + '-' + type).prop('checked', true);
        $('.form-image-type-params-' + type, this.el_.parent()).removeClass('is-hidden');
      }

      if (this.spaceForm_) {
        this.spaceFormTrimField_.setEnabled(true);
        this.spaceFormPaddingField_.setEnabled(true);
        this.spaceFormTopField_.setEnabled(true);
        this.spaceFormLeftField_.setEnabled(true);
        if (type == 'clipart') {
          if (this.params_.clipartNoTrimPadding) {
            this.spaceFormTrimField_.setEnabled(false);
            this.spaceFormTrimField_.setValue(false);
            this.spaceFormPaddingField_.setEnabled(false);
            this.spaceFormPaddingField_.setValue(0);
            this.spaceFormTopField_.setEnabled(false);
            this.spaceFormTopField_.setValue(0);
            this.spaceFormLeftField_.setEnabled(false);
            this.spaceFormLeftField_.setValue(0);
          }
        } else if (type == 'text') {
          this.spaceFormTrimField_.setEnabled(false);
          this.spaceFormTrimField_.setValue(true);
        }
      }
    }
  }, {
    key: 'loadClipart_',
    value: function loadClipart_(clipartSrc) {
      this.$clipartItems.removeClass('is-selected');
      this.$clipartItems.filter('[data-name="' + clipartSrc + '"]').addClass('is-selected');

      this.setValueType_('clipart');
      this.clipartSrc_ = clipartSrc;
      this.renderValueAndNotifyChanged_();
    }
  }, {
    key: 'clearValue',
    value: function clearValue() {
      this.valueType_ = null;
      this.valueCtx_ = null;
      this.valueOrigImg_ = null;
      this.fileEl_.val('');
      if (this.imagePreview_) {
        this.imagePreview_.hide();
      }
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var name = null;
      switch (this.valueType_) {
        case 'image':
          name = this.imageFilename_;
          break;

        case 'clipart':
          name = this.clipartSrc_;
          break;

        case 'text':
          name = this.textParams_.text;
          break;
      }

      return {
        ctx: this.valueCtx_,
        origImg: this.valueOrigImg_,
        type: this.valueType_,
        name: name
      };
    }
  }, {
    key: 'notifyChanged_',
    value: function notifyChanged_(newValue, oldValue) {
      _get(ImageField.prototype.__proto__ || Object.getPrototypeOf(ImageField.prototype), 'notifyChanged_', this).call(this, newValue, oldValue);
      this.lastNotifiedValue_ = Object.assign({}, newValue);
    }

    // this function is asynchronous

  }, {
    key: 'renderValueAndNotifyChanged_',
    value: function renderValueAndNotifyChanged_() {
      var _this6 = this;

      if (!this.valueType_) {
        this.valueCtx_ = null;
        this.valueOrigImg_ = null;
        this.notifyChanged_(this.getValue(), this.lastNotifiedValue_);
        return;
      }

      if (this.renderTimeout_) {
        clearTimeout(this.renderTimeout_);
        this.renderTimeout_ = null;
      }

      if (this.rendering_) {
        this.renderTimeout_ = setTimeout(function () {
          return _this6.renderValueAndNotifyChanged_();
        }, 100);
        return;
      }

      this.rendering_ = true;

      this.renderSource_().then(function (_ref3) {
        var ctx = _ref3.ctx,
            size = _ref3.size;

        _this6.computeTrimRect_(ctx, size).then(function (trimRect) {
          var pad = _this6.spaceFormValues_.pad || 0;
          var padPx = Math.round(pad * Math.min(trimRect.w, trimRect.h));
          var left = _this6.spaceFormValues_.left || 0;
          var leftPx = Math.round(left * Math.min(trimRect.w, trimRect.h));
          var top = _this6.spaceFormValues_.top || 0;
          var topPx = Math.round(top * Math.min(trimRect.w, trimRect.h));
          _this6.valueCtx_ = _imagelib.imagelib.Drawing.context({
            w: trimRect.w + padPx * 2,
            h: trimRect.h + padPx * 2
          });
          _this6.valueCtx_.drawImage(ctx.canvas, trimRect.x, trimRect.y, trimRect.w, trimRect.h, padPx + leftPx, padPx + topPx, trimRect.w, trimRect.h);

          if (_this6.imagePreview_) {
            _this6.imagePreview_.attr({
              width: _this6.valueCtx_.canvas.width,
              height: _this6.valueCtx_.canvas.height
            });

            var previewCtx = _this6.imagePreview_.get(0).getContext('2d');
            previewCtx.drawImage(_this6.valueCtx_.canvas, 0, 0);
            _this6.imagePreview_.show();
          }

          _this6.rendering_ = false;
          _this6.notifyChanged_(_this6.getValue(), _this6.lastNotifiedValue_);
        });
      }).catch(function (e) {
        console.error('Error: ' + e);
        _this6.rendering_ = false;
        _this6.notifyChanged_(_this6.getValue(), _this6.lastNotifiedValue_);
      });
    }
  }, {
    key: 'renderSource_',
    value: function renderSource_() {
      var _this7 = this;

      return new _Promise(function (resolve, reject) {
        // Render the base image (text, clipart, or image)
        switch (_this7.valueType_) {
          case 'image':
            if (_this7.imageParams_.uri) {
              _Util.Util.loadImageFromUri(_this7.imageParams_.uri).then(function (img) {
                _this7.valueOrigImg_ = img;
                var origSize = {
                  w: img.naturalWidth,
                  h: img.naturalHeight
                };
                var size = Object.assign({}, origSize);
                if (_this7.imageParams_.isSvg && _this7.params_.maxFinalSize) {
                  if (size.w / size.h > _this7.params_.maxFinalSize.w / _this7.params_.maxFinalSize.h) {
                    size.w = _this7.params_.maxFinalSize.w;
                    size.h = size.w * origSize.h / origSize.w;
                  } else {
                    size.h = _this7.params_.maxFinalSize.h;
                    size.w = size.h * origSize.w / origSize.h;
                  }
                }
                var ctx = _imagelib.imagelib.Drawing.context(size);
                ctx.drawImage(img, 0, 0, origSize.w, origSize.h, 0, 0, size.w, size.h);
                resolve({ ctx: ctx, size: size });
              });
            } else {
              reject('no uri');
            }
            break;

          case 'clipart':
            var size = { w: 1536, h: 1536 };
            var ctx = _imagelib.imagelib.Drawing.context(size);
            var text = _this7.clipartSrc_;

            ctx.fillStyle = '#000';
            ctx.font = size.h + 'px/' + size.h + 'px \'Material Icons\'';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(text, 0, size.h);

            resolve({ ctx: ctx, size: size });
            break;

          case 'text':
            var size = { w: 6144, h: 1536 };
            var textHeight = size.h * 0.75;
            var ctx = _imagelib.imagelib.Drawing.context(size);
            var text = _this7.textParams_.text || '';
            text = ' ' + text + ' ';

            ctx.fillStyle = '#000';
            ctx.font = 'bold ' + textHeight + 'px/' + size.h + 'px ' + _this7.textParams_.fontStack;
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(text, 0, textHeight);
            size.w = Math.ceil(Math.min(ctx.measureText(text).width, size.w) || size.w);

            resolve({ ctx: ctx, size: size });
            break;

          default:
            reject('No value type');
        }
      });
    }
  }, {
    key: 'computeTrimRect_',
    value: function computeTrimRect_(ctx, size) {
      var _this8 = this;

      return new _Promise(function (resolve, reject) {
        if (_this8.spaceFormValues_.trim) {
          if (_this8.trimPromise_ && _this8.trimPromise_.worker) {
            _this8.trimPromise_.worker.terminate();
          }

          _this8.trimPromise_ = _imagelib.imagelib.Analysis.getTrimRect(ctx, size, 1).then(function (trimRect) {
            var pad = Math.min(size.w, size.h) * .01;
            // pad a little bit to avoid edge artifacts
            Object.assign(trimRect, {
              x: Math.max(Math.floor(trimRect.x - pad), 0),
              y: Math.max(Math.floor(trimRect.y - pad), 0),
              w: Math.ceil(trimRect.w + pad * 2),
              h: Math.ceil(trimRect.h + pad * 2)
            });
            trimRect.w = Math.min(trimRect.w, size.w - trimRect.x);
            trimRect.h = Math.min(trimRect.h, size.h - trimRect.y);
            resolve(trimRect);
          }).catch(reject);
        } else {
          resolve({ x: 0, y: 0, w: size.w, h: size.h });
        }
      });
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      var vals = {
        type: this.valueType_,
        clipart: this.valueType_ == 'clipart' ? this.clipartSrc_ : null,
        text: this.valueType_ == 'text' ? this.textForm_.getValuesSerialized() : null
      };

      if (this.spaceForm_) {
        vals.space = this.spaceForm_.getValuesSerialized();
      }

      return vals;
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(o) {
      if (o.type) {
        this.setValueType_(o.type);
      }
      if (o.space) {
        this.spaceForm_.setValuesSerialized(o.space);
        this.spaceFormValues_ = this.spaceForm_.getValues();
      }
      if (o.clipart && this.valueType_ == 'clipart') {
        this.loadClipart_(o.clipart);
      }
      if (o.text && this.valueType_ == 'text') {
        this.textForm_.setValuesSerialized(o.text);
        this.tryLoadWebFont_();
      }
    }
  }]);

  return ImageField;
}(_Field2.Field);

/**
 * Loads the first valid image from a FileList (e.g. drag + drop source), as a data URI. This method
 * will throw an alert() in case of errors and call back with null.
 * @param {FileList} fileList The FileList to load.
 * @return Returns a promise, with object containing 'uri' field representing
 *      the loaded image. There will also be a 'name' field indicating the file name, if one
 *      is available.
 */


ImageField.loadImageFromFileList = function (fileList) {
  return new _Promise(function (resolve, reject) {
    fileList = fileList || [];

    var file = Array.from(fileList).find(function (file) {
      return ImageField.isValidFile_(file);
    });

    if (!file) {
      alert('Please choose a valid image file (PNG, JPG, GIF, SVG, etc.)');
      resolve(null);
      return;
    }

    var isSvg = file.type == 'image/svg+xml';

    var fileReader = new FileReader();

    // Closure to capture the file information.
    fileReader.onload = function (e) {
      return resolve({
        isSvg: isSvg,
        uri: e.target.result,
        name: file.name
      });
    };

    fileReader.onerror = function (e) {
      switch (e.target.error.code) {
        case e.target.error.NOT_FOUND_ERR:
          alert('File not found!');
          break;

        case e.target.error.NOT_READABLE_ERR:
          alert('File is not readable');
          break;

        case e.target.error.ABORT_ERR:
          break; // noop

        default:
          alert('An error occurred reading this file.');
      }

      resolve(null);
    };

    fileReader.onabort = function (e) {
      alert('File read cancelled');
      resolve(null);
    };

    fileReader.readAsDataURL(file);
  });
};

ImageField.isValidFile_ = function (file) {
  return !!file.type.toLowerCase().match(/^image\//);
};

// Prevent scrolling for clipart per http://stackoverflow.com/questions/7600454
$(document).ready(function () {
  $('.cancel-parent-scroll').on('mousewheel DOMMouseScroll', function (e) {
    var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail;
    e.currentTarget.scrollTop -= delta;
    e.preventDefault();
  });
});

},{"../../imagelib":5,"../Util":20,"./BooleanField":22,"./EnumField":24,"./Field":25,"./Form":26,"./ImageField-clipart":28,"./RangeField":30,"./TextField":31,"es6-promise":34,"webfontloader":37}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RangeField = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Field2 = require('./Field');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var RangeField = exports.RangeField = function (_Field) {
  _inherits(RangeField, _Field);

  function RangeField() {
    _classCallCheck(this, RangeField);

    return _possibleConstructorReturn(this, (RangeField.__proto__ || Object.getPrototypeOf(RangeField)).apply(this, arguments));
  }

  _createClass(RangeField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldContainer = $('.form-field-container', _get(RangeField.prototype.__proto__ || Object.getPrototypeOf(RangeField.prototype), 'createUi', this).call(this, container));
      var me = this;

      this.el_ = $('<div>').addClass('form-field-range').attr('id', this.getHtmlId()).appendTo(fieldContainer);

      this.rangeEl_ = $('<input>').attr('type', 'range').attr('min', this.params_.min || 0).attr('max', this.params_.max || 100).attr('step', this.params_.step || 1).on('input', function () {
        return _this2.setValue(Number(_this2.rangeEl_.val()) || 0, true);
      }).val(this.getValue()).appendTo(this.el_);

      if (this.params_.textFn || this.params_.showText) {
        this.params_.textFn = this.params_.textFn || function (d) {
          return d;
        };
        this.textEl_ = $('<div>').addClass('form-field-range-text').text(this.params_.textFn(this.getValue())).appendTo(this.el_);
      }
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = this.value_;
      if (typeof value != 'number') {
        value = this.params_.defaultValue;
        if (typeof value != 'number') value = 0;
      }
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      var oldValue = this.value_;
      this.value_ = val;
      if (!pauseUi) {
        this.rangeEl_.val(val);
      }
      if (this.textEl_) {
        this.textEl_.text(this.params_.textFn(val));
      }
      this.notifyChanged_(val, oldValue);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(Number(s)); // don't use parseInt nor parseFloat
    }
  }]);

  return RangeField;
}(_Field2.Field);

},{"./Field":25}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextField = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Field2 = require('./Field');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Google Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var TextField = exports.TextField = function (_Field) {
  _inherits(TextField, _Field);

  function TextField() {
    _classCallCheck(this, TextField);

    return _possibleConstructorReturn(this, (TextField.__proto__ || Object.getPrototypeOf(TextField)).apply(this, arguments));
  }

  _createClass(TextField, [{
    key: 'createUi',
    value: function createUi(container) {
      var _this2 = this;

      var fieldContainer = $('.form-field-container', _get(TextField.prototype.__proto__ || Object.getPrototypeOf(TextField.prototype), 'createUi', this).call(this, container));

      this.el_ = $('<input>').attr('type', 'text').attr('placeholder', this.params_.placeholder).addClass('form-field-text').val(this.getValue()).on('input', function (ev) {
        var oldVal = _this2.getValue();
        var newVal = $(ev.currentTarget).val();
        if (oldVal != newVal) {
          _this2.setValue(newVal, true);
        }
      }).appendTo(fieldContainer);
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = this.value_;
      if (typeof value != 'string') {
        value = this.params_.defaultValue || '';
      }
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(val, pauseUi) {
      var oldValue = this.value_;
      this.value_ = val;
      if (!pauseUi) {
        this.el_.val(val);
      }
      this.notifyChanged_(val, oldValue);
    }
  }, {
    key: 'serializeValue',
    value: function serializeValue() {
      return this.getValue();
    }
  }, {
    key: 'deserializeValue',
    value: function deserializeValue(s) {
      this.setValue(s);
    }
  }]);

  return TextField;
}(_Field2.Field);

},{"./Field":25}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forms = undefined;

var _BooleanField = require('./BooleanField');

var _ColorField = require('./ColorField');

var _GradientField = require('./GradientField');

var _EnumField = require('./EnumField');

var _Field = require('./Field');

var _Form = require('./Form');

var _ImageField = require('./ImageField');

var _RangeField = require('./RangeField');

var _TextField = require('./TextField');

var forms = exports.forms = {
  BooleanField: _BooleanField.BooleanField,
  ColorField: _ColorField.ColorField,
  GradientField: _GradientField.GradientField,
  EnumField: _EnumField.EnumField,
  Field: _Field.Field,
  Form: _Form.Form,
  ImageField: _ImageField.ImageField,
  RangeField: _RangeField.RangeField,
  TextField: _TextField.TextField
}; /*
    * Copyright 2016 Google Inc.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

},{"./BooleanField":22,"./ColorField":23,"./EnumField":24,"./Field":25,"./Form":26,"./GradientField":27,"./ImageField":29,"./RangeField":30,"./TextField":31}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.studio = undefined;

var _Hash = require('./Hash');

var _Util = require('./Util');

var _Zip = require('./Zip');

var _forms = require('./forms');

var studio = exports.studio = {
  Hash: _Hash.Hash,
  Util: _Util.Util,
  Zip: _Zip.Zip
}; /*
    * Copyright 2016 Google Inc.
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *     http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

Object.assign(studio, _forms.forms);

},{"./Hash":19,"./Util":20,"./Zip":21,"./forms":32}],34:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.1.1
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === GET_THEN_ERROR) {
      reject(promise, GET_THEN_ERROR.error);
      GET_THEN_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (failed) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator$1(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate(input);
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

Enumerator$1.prototype._enumerate = function (input) {
  for (var i = 0; this._state === PENDING && i < input.length; i++) {
    this._eachEntry(input[i], i);
  }
};

Enumerator$1.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$1 = c.resolve;

  if (resolve$$1 === resolve$1) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise$2) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$1) {
        return resolve$$1(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$1(entry), i);
  }
};

Enumerator$1.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator$1.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all$1(entries) {
  return new Enumerator$1(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race$1(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise$2(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
  }
}

Promise$2.all = all$1;
Promise$2.race = race$1;
Promise$2.resolve = resolve$1;
Promise$2.reject = reject$1;
Promise$2._setScheduler = setScheduler;
Promise$2._setAsap = setAsap;
Promise$2._asap = asap;

Promise$2.prototype = {
  constructor: Promise$2,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

/*global self*/
function polyfill$1() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise$2;
}

// Strange compat..
Promise$2.polyfill = polyfill$1;
Promise$2.Promise = Promise$2;

return Promise$2;

})));



}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":35}],35:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],36:[function(require,module,exports){
// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);

},{}],37:[function(require,module,exports){
/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function A(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||"-"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+" "+(a.f+"00")+" 300px "+I(a.c)}function I(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function J(a){return a.a+a.f}function H(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);K(a,"loading")}function L(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}K(a,"inactive")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function N(a){u(a.c,"body",a.a)}function O(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+I(a.c)+";"+("font-style:"+H(a)+";font-weight:"+(a.f+"00")+";")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+",serif",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+",sans-serif",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G("serif",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G("sans-serif",J(this.a));a=
O(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:"serif",C:"sans-serif"},S=null;function T(){if(null===S){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.m.a.offsetWidth;this.A=q();U(this)};
function la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,J(a).toString(),"active")],[b.a.c("wf",a.c,J(a).toString(),"loading"),b.a.c("wf",a.c,J(a).toString(),"inactive")]);K(b,"fontactive",a);this.m=!0;na(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,J(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,J(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,J(a).toString(),"inactive"));w(b.f,d,e)}K(b,"fontinactive",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),K(a,"active")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};
function qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c("wf",x.c,J(x).toString(),"loading")]);K(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);
X=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}
ra.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||"https://fast.fonts.net/jsapi")+"/"+d+".js"+(e?"?v="+e:""),function(e){e?a([]):(f["__MonotypeConfiguration__"+
d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||""}var ua="https://fonts.googleapis.com/css";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function wa(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}
var za={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Aa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ba={i:"i",italic:"i",n:"n",normal:"n"},
Ca=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(","),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k="";else{k=n[2];k=null==k||""==k?"n":Ba[k];n=n[1];if(null==n||""==n)n="4";else var r=Aa[n],n=r?r:isNaN(n)?"4":n.substr(0,1);k=[k,n].join("")}}else k="";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},A(this.c,(this.f.api||"https://f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());

},{}],38:[function(require,module,exports){

var zip = require('zip');

function createUrl(src){
  var blob = new Blob([src], { type: 'application/javascript' });
  return URL.createObjectURL(blob);
}

var zWorker = createUrl("/* jshint worker:true */\n(function main(global) {\n\t\"use strict\";\n\n\tif (global.zWorkerInitialized)\n\t\tthrow new Error('z-worker.js should be run only once');\n\tglobal.zWorkerInitialized = true;\n\n\taddEventListener(\"message\", function(event) {\n\t\tvar message = event.data, type = message.type, sn = message.sn;\n\t\tvar handler = handlers[type];\n\t\tif (handler) {\n\t\t\ttry {\n\t\t\t\thandler(message);\n\t\t\t} catch (e) {\n\t\t\t\tonError(type, sn, e);\n\t\t\t}\n\t\t}\n\t\t//for debug\n\t\t//postMessage({type: 'echo', originalType: type, sn: sn});\n\t});\n\n\tvar handlers = {\n\t\timportScripts: doImportScripts,\n\t\tnewTask: newTask,\n\t\tappend: processData,\n\t\tflush: processData,\n\t};\n\n\t// deflater/inflater tasks indexed by serial numbers\n\tvar tasks = {};\n\n\tfunction doImportScripts(msg) {\n\t\tif (msg.scripts && msg.scripts.length > 0)\n\t\t\timportScripts.apply(undefined, msg.scripts);\n\t\tpostMessage({type: 'importScripts'});\n\t}\n\n\tfunction newTask(msg) {\n\t\tvar CodecClass = global[msg.codecClass];\n\t\tvar sn = msg.sn;\n\t\tif (tasks[sn])\n\t\t\tthrow Error('duplicated sn');\n\t\ttasks[sn] =  {\n\t\t\tcodec: new CodecClass(msg.options),\n\t\t\tcrcInput: msg.crcType === 'input',\n\t\t\tcrcOutput: msg.crcType === 'output',\n\t\t\tcrc: new Crc32(),\n\t\t};\n\t\tpostMessage({type: 'newTask', sn: sn});\n\t}\n\n\t// performance may not be supported\n\tvar now = global.performance ? global.performance.now.bind(global.performance) : Date.now;\n\n\tfunction processData(msg) {\n\t\tvar sn = msg.sn, type = msg.type, input = msg.data;\n\t\tvar task = tasks[sn];\n\t\t// allow creating codec on first append\n\t\tif (!task && msg.codecClass) {\n\t\t\tnewTask(msg);\n\t\t\ttask = tasks[sn];\n\t\t}\n\t\tvar isAppend = type === 'append';\n\t\tvar start = now();\n\t\tvar output;\n\t\tif (isAppend) {\n\t\t\ttry {\n\t\t\t\toutput = task.codec.append(input, function onprogress(loaded) {\n\t\t\t\t\tpostMessage({type: 'progress', sn: sn, loaded: loaded});\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tdelete tasks[sn];\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete tasks[sn];\n\t\t\toutput = task.codec.flush();\n\t\t}\n\t\tvar codecTime = now() - start;\n\n\t\tstart = now();\n\t\tif (input && task.crcInput)\n\t\t\ttask.crc.append(input);\n\t\tif (output && task.crcOutput)\n\t\t\ttask.crc.append(output);\n\t\tvar crcTime = now() - start;\n\n\t\tvar rmsg = {type: type, sn: sn, codecTime: codecTime, crcTime: crcTime};\n\t\tvar transferables = [];\n\t\tif (output) {\n\t\t\trmsg.data = output;\n\t\t\ttransferables.push(output.buffer);\n\t\t}\n\t\tif (!isAppend && (task.crcInput || task.crcOutput))\n\t\t\trmsg.crc = task.crc.get();\n\t\t\n\t\t// posting a message with transferables will fail on IE10\n\t\ttry {\n\t\t\tpostMessage(rmsg, transferables);\n\t\t} catch(ex) {\n\t\t\tpostMessage(rmsg); // retry without transferables\n\t\t}\n\t}\n\n\tfunction onError(type, sn, e) {\n\t\tvar msg = {\n\t\t\ttype: type,\n\t\t\tsn: sn,\n\t\t\terror: formatError(e)\n\t\t};\n\t\tpostMessage(msg);\n\t}\n\n\tfunction formatError(e) {\n\t\treturn { message: e.message, stack: e.stack };\n\t}\n\n\t// Crc32 code copied from file zip.js\n\tfunction Crc32() {\n\t\tthis.crc = -1;\n\t}\n\tCrc32.prototype.append = function append(data) {\n\t\tvar crc = this.crc | 0, table = this.table;\n\t\tfor (var offset = 0, len = data.length | 0; offset < len; offset++)\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\n\t\tthis.crc = crc;\n\t};\n\tCrc32.prototype.get = function get() {\n\t\treturn ~this.crc;\n\t};\n\tCrc32.prototype.table = (function() {\n\t\tvar i, j, t, table = []; // Uint32Array is actually slower than []\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tt = i;\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tif (t & 1)\n\t\t\t\t\tt = (t >>> 1) ^ 0xEDB88320;\n\t\t\t\telse\n\t\t\t\t\tt = t >>> 1;\n\t\t\ttable[i] = t;\n\t\t}\n\t\treturn table;\n\t})();\n\n\t// \"no-op\" codec\n\tfunction NOOP() {}\n\tglobal.NOOP = NOOP;\n\tNOOP.prototype.append = function append(bytes, onprogress) {\n\t\treturn bytes;\n\t};\n\tNOOP.prototype.flush = function flush() {};\n})(this);\n");
zip.workerScripts = {
  deflater: [zWorker, createUrl("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n\n(function(global) {\n\t\"use strict\";\n\n\t// Global\n\n\tvar MAX_BITS = 15;\n\tvar D_CODES = 30;\n\tvar BL_CODES = 19;\n\n\tvar LENGTH_CODES = 29;\n\tvar LITERALS = 256;\n\tvar L_CODES = (LITERALS + 1 + LENGTH_CODES);\n\tvar HEAP_SIZE = (2 * L_CODES + 1);\n\n\tvar END_BLOCK = 256;\n\n\t// Bit length codes must not exceed MAX_BL_BITS bits\n\tvar MAX_BL_BITS = 7;\n\n\t// repeat previous bit length 3-6 times (2 bits of repeat count)\n\tvar REP_3_6 = 16;\n\n\t// repeat a zero length 3-10 times (3 bits of repeat count)\n\tvar REPZ_3_10 = 17;\n\n\t// repeat a zero length 11-138 times (7 bits of repeat count)\n\tvar REPZ_11_138 = 18;\n\n\t// The lengths of the bit length codes are sent in order of decreasing\n\t// probability, to avoid transmitting the lengths for unused bit\n\t// length codes.\n\n\tvar Buf_size = 8 * 2;\n\n\t// JZlib version : \"1.0.2\"\n\tvar Z_DEFAULT_COMPRESSION = -1;\n\n\t// compression strategy\n\tvar Z_FILTERED = 1;\n\tvar Z_HUFFMAN_ONLY = 2;\n\tvar Z_DEFAULT_STRATEGY = 0;\n\n\tvar Z_NO_FLUSH = 0;\n\tvar Z_PARTIAL_FLUSH = 1;\n\tvar Z_FULL_FLUSH = 3;\n\tvar Z_FINISH = 4;\n\n\tvar Z_OK = 0;\n\tvar Z_STREAM_END = 1;\n\tvar Z_NEED_DICT = 2;\n\tvar Z_STREAM_ERROR = -2;\n\tvar Z_DATA_ERROR = -3;\n\tvar Z_BUF_ERROR = -5;\n\n\t// Tree\n\n\t// see definition of array dist_code below\n\tvar _dist_code = [ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t\t\t10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n\t\t\t12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n\t\t\t13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n\t\t\t14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n\t\t\t14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n\t\t\t15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19,\n\t\t\t20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t\t24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n\t\t\t26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n\t\t\t27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n\t\t\t28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,\n\t\t\t29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n\t\t\t29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 ];\n\n\tfunction Tree() {\n\t\tvar that = this;\n\n\t\t// dyn_tree; // the dynamic tree\n\t\t// max_code; // largest code with non zero frequency\n\t\t// stat_desc; // the corresponding static tree\n\n\t\t// Compute the optimal bit lengths for a tree and update the total bit\n\t\t// length\n\t\t// for the current block.\n\t\t// IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t\t// above are the tree nodes sorted by increasing frequency.\n\t\t// OUT assertions: the field len is set to the optimal bit length, the\n\t\t// array bl_count contains the frequencies for each bit length.\n\t\t// The length opt_len is updated; static_len is also updated if stree is\n\t\t// not null.\n\t\tfunction gen_bitlen(s) {\n\t\t\tvar tree = that.dyn_tree;\n\t\t\tvar stree = that.stat_desc.static_tree;\n\t\t\tvar extra = that.stat_desc.extra_bits;\n\t\t\tvar base = that.stat_desc.extra_base;\n\t\t\tvar max_length = that.stat_desc.max_length;\n\t\t\tvar h; // heap index\n\t\t\tvar n, m; // iterate over the tree elements\n\t\t\tvar bits; // bit length\n\t\t\tvar xbits; // extra bits\n\t\t\tvar f; // frequency\n\t\t\tvar overflow = 0; // number of elements with bit length too large\n\n\t\t\tfor (bits = 0; bits <= MAX_BITS; bits++)\n\t\t\t\ts.bl_count[bits] = 0;\n\n\t\t\t// In a first pass, compute the optimal bit lengths (which may\n\t\t\t// overflow in the case of the bit length tree).\n\t\t\ttree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap\n\n\t\t\tfor (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n\t\t\t\tn = s.heap[h];\n\t\t\t\tbits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n\t\t\t\tif (bits > max_length) {\n\t\t\t\t\tbits = max_length;\n\t\t\t\t\toverflow++;\n\t\t\t\t}\n\t\t\t\ttree[n * 2 + 1] = bits;\n\t\t\t\t// We overwrite tree[n*2+1] which is no longer needed\n\n\t\t\t\tif (n > that.max_code)\n\t\t\t\t\tcontinue; // not a leaf node\n\n\t\t\t\ts.bl_count[bits]++;\n\t\t\t\txbits = 0;\n\t\t\t\tif (n >= base)\n\t\t\t\t\txbits = extra[n - base];\n\t\t\t\tf = tree[n * 2];\n\t\t\t\ts.opt_len += f * (bits + xbits);\n\t\t\t\tif (stree)\n\t\t\t\t\ts.static_len += f * (stree[n * 2 + 1] + xbits);\n\t\t\t}\n\t\t\tif (overflow === 0)\n\t\t\t\treturn;\n\n\t\t\t// This happens for example on obj2 and pic of the Calgary corpus\n\t\t\t// Find the first bit length which could increase:\n\t\t\tdo {\n\t\t\t\tbits = max_length - 1;\n\t\t\t\twhile (s.bl_count[bits] === 0)\n\t\t\t\t\tbits--;\n\t\t\t\ts.bl_count[bits]--; // move one leaf down the tree\n\t\t\t\ts.bl_count[bits + 1] += 2; // move one overflow item as its brother\n\t\t\t\ts.bl_count[max_length]--;\n\t\t\t\t// The brother of the overflow item also moves one step up,\n\t\t\t\t// but this does not affect bl_count[max_length]\n\t\t\t\toverflow -= 2;\n\t\t\t} while (overflow > 0);\n\n\t\t\tfor (bits = max_length; bits !== 0; bits--) {\n\t\t\t\tn = s.bl_count[bits];\n\t\t\t\twhile (n !== 0) {\n\t\t\t\t\tm = s.heap[--h];\n\t\t\t\t\tif (m > that.max_code)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (tree[m * 2 + 1] != bits) {\n\t\t\t\t\t\ts.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n\t\t\t\t\t\ttree[m * 2 + 1] = bits;\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reverse the first len bits of a code, using straightforward code (a\n\t\t// faster\n\t\t// method would use a table)\n\t\t// IN assertion: 1 <= len <= 15\n\t\tfunction bi_reverse(code, // the value to invert\n\t\tlen // its bit length\n\t\t) {\n\t\t\tvar res = 0;\n\t\t\tdo {\n\t\t\t\tres |= code & 1;\n\t\t\t\tcode >>>= 1;\n\t\t\t\tres <<= 1;\n\t\t\t} while (--len > 0);\n\t\t\treturn res >>> 1;\n\t\t}\n\n\t\t// Generate the codes for a given tree and bit counts (which need not be\n\t\t// optimal).\n\t\t// IN assertion: the array bl_count contains the bit length statistics for\n\t\t// the given tree and the field len is set for all tree elements.\n\t\t// OUT assertion: the field code is set for all tree elements of non\n\t\t// zero code length.\n\t\tfunction gen_codes(tree, // the tree to decorate\n\t\tmax_code, // largest code with non zero frequency\n\t\tbl_count // number of codes at each bit length\n\t\t) {\n\t\t\tvar next_code = []; // next code value for each\n\t\t\t// bit length\n\t\t\tvar code = 0; // running code value\n\t\t\tvar bits; // bit index\n\t\t\tvar n; // code index\n\t\t\tvar len;\n\n\t\t\t// The distribution counts are first used to generate the code values\n\t\t\t// without bit reversal.\n\t\t\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\t\t\tnext_code[bits] = code = ((code + bl_count[bits - 1]) << 1);\n\t\t\t}\n\n\t\t\t// Check that the bit counts in bl_count are consistent. The last code\n\t\t\t// must be all ones.\n\t\t\t// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n\t\t\t// \"inconsistent bit counts\");\n\t\t\t// Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tlen = tree[n * 2 + 1];\n\t\t\t\tif (len === 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// Now reverse the bits\n\t\t\t\ttree[n * 2] = bi_reverse(next_code[len]++, len);\n\t\t\t}\n\t\t}\n\n\t\t// Construct one Huffman tree and assigns the code bit strings and lengths.\n\t\t// Update the total bit length for the current block.\n\t\t// IN assertion: the field freq is set for all tree elements.\n\t\t// OUT assertions: the fields len and code are set to the optimal bit length\n\t\t// and corresponding code. The length opt_len is updated; static_len is\n\t\t// also updated if stree is not null. The field max_code is set.\n\t\tthat.build_tree = function(s) {\n\t\t\tvar tree = that.dyn_tree;\n\t\t\tvar stree = that.stat_desc.static_tree;\n\t\t\tvar elems = that.stat_desc.elems;\n\t\t\tvar n, m; // iterate over heap elements\n\t\t\tvar max_code = -1; // largest code with non zero frequency\n\t\t\tvar node; // new node being created\n\n\t\t\t// Construct the initial heap, with least frequent element in\n\t\t\t// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n\t\t\t// heap[0] is not used.\n\t\t\ts.heap_len = 0;\n\t\t\ts.heap_max = HEAP_SIZE;\n\n\t\t\tfor (n = 0; n < elems; n++) {\n\t\t\t\tif (tree[n * 2] !== 0) {\n\t\t\t\t\ts.heap[++s.heap_len] = max_code = n;\n\t\t\t\t\ts.depth[n] = 0;\n\t\t\t\t} else {\n\t\t\t\t\ttree[n * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The pkzip format requires that at least one distance code exists,\n\t\t\t// and that at least one bit should be sent even if there is only one\n\t\t\t// possible code. So to avoid special checks later on we force at least\n\t\t\t// two codes of non zero frequency.\n\t\t\twhile (s.heap_len < 2) {\n\t\t\t\tnode = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n\t\t\t\ttree[node * 2] = 1;\n\t\t\t\ts.depth[node] = 0;\n\t\t\t\ts.opt_len--;\n\t\t\t\tif (stree)\n\t\t\t\t\ts.static_len -= stree[node * 2 + 1];\n\t\t\t\t// node is 0 or 1 so it does not have extra bits\n\t\t\t}\n\t\t\tthat.max_code = max_code;\n\n\t\t\t// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n\t\t\t// establish sub-heaps of increasing lengths:\n\n\t\t\tfor (n = Math.floor(s.heap_len / 2); n >= 1; n--)\n\t\t\t\ts.pqdownheap(tree, n);\n\n\t\t\t// Construct the Huffman tree by repeatedly combining the least two\n\t\t\t// frequent nodes.\n\n\t\t\tnode = elems; // next internal node of the tree\n\t\t\tdo {\n\t\t\t\t// n = node of least frequency\n\t\t\t\tn = s.heap[1];\n\t\t\t\ts.heap[1] = s.heap[s.heap_len--];\n\t\t\t\ts.pqdownheap(tree, 1);\n\t\t\t\tm = s.heap[1]; // m = node of next least frequency\n\n\t\t\t\ts.heap[--s.heap_max] = n; // keep the nodes sorted by frequency\n\t\t\t\ts.heap[--s.heap_max] = m;\n\n\t\t\t\t// Create a new node father of n and m\n\t\t\t\ttree[node * 2] = (tree[n * 2] + tree[m * 2]);\n\t\t\t\ts.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;\n\t\t\t\ttree[n * 2 + 1] = tree[m * 2 + 1] = node;\n\n\t\t\t\t// and insert the new node in the heap\n\t\t\t\ts.heap[1] = node++;\n\t\t\t\ts.pqdownheap(tree, 1);\n\t\t\t} while (s.heap_len >= 2);\n\n\t\t\ts.heap[--s.heap_max] = s.heap[1];\n\n\t\t\t// At this point, the fields freq and dad are set. We can now\n\t\t\t// generate the bit lengths.\n\n\t\t\tgen_bitlen(s);\n\n\t\t\t// The field len is now set, we can generate the bit codes\n\t\t\tgen_codes(tree, that.max_code, s.bl_count);\n\t\t};\n\n\t}\n\n\tTree._length_code = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,\n\t\t\t16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n\t\t\t20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t\t\t22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n\t\t\t25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n\t\t\t26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28 ];\n\n\tTree.base_length = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0 ];\n\n\tTree.base_dist = [ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,\n\t\t\t24576 ];\n\n\t// Mapping from a distance to a distance code. dist is the distance - 1 and\n\t// must not have side effects. _dist_code[256] and _dist_code[257] are never\n\t// used.\n\tTree.d_code = function(dist) {\n\t\treturn ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);\n\t};\n\n\t// extra bits for each length code\n\tTree.extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];\n\n\t// extra bits for each distance code\n\tTree.extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\n\n\t// extra bits for each bit length code\n\tTree.extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];\n\n\tTree.bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\t// StaticTree\n\n\tfunction StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {\n\t\tvar that = this;\n\t\tthat.static_tree = static_tree;\n\t\tthat.extra_bits = extra_bits;\n\t\tthat.extra_base = extra_base;\n\t\tthat.elems = elems;\n\t\tthat.max_length = max_length;\n\t}\n\n\tStaticTree.static_ltree = [ 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8,\n\t\t\t130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42,\n\t\t\t8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8,\n\t\t\t22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8,\n\t\t\t222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113,\n\t\t\t8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8,\n\t\t\t69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8,\n\t\t\t173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9,\n\t\t\t51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9,\n\t\t\t427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379,\n\t\t\t9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23,\n\t\t\t9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9,\n\t\t\t399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9,\n\t\t\t223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7,\n\t\t\t40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8,\n\t\t\t99, 8, 227, 8 ];\n\n\tStaticTree.static_dtree = [ 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5,\n\t\t\t25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5 ];\n\n\tStaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n\n\tStaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);\n\n\tStaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n\n\t// Deflate\n\n\tvar MAX_MEM_LEVEL = 9;\n\tvar DEF_MEM_LEVEL = 8;\n\n\tfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\t\tvar that = this;\n\t\tthat.good_length = good_length;\n\t\tthat.max_lazy = max_lazy;\n\t\tthat.nice_length = nice_length;\n\t\tthat.max_chain = max_chain;\n\t\tthat.func = func;\n\t}\n\n\tvar STORED = 0;\n\tvar FAST = 1;\n\tvar SLOW = 2;\n\tvar config_table = [ new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST),\n\t\t\tnew Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW),\n\t\t\tnew Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW) ];\n\n\tvar z_errmsg = [ \"need dictionary\", // Z_NEED_DICT\n\t// 2\n\t\"stream end\", // Z_STREAM_END 1\n\t\"\", // Z_OK 0\n\t\"\", // Z_ERRNO (-1)\n\t\"stream error\", // Z_STREAM_ERROR (-2)\n\t\"data error\", // Z_DATA_ERROR (-3)\n\t\"\", // Z_MEM_ERROR (-4)\n\t\"buffer error\", // Z_BUF_ERROR (-5)\n\t\"\",// Z_VERSION_ERROR (-6)\n\t\"\" ];\n\n\t// block not completed, need more input or more output\n\tvar NeedMore = 0;\n\n\t// block flush performed\n\tvar BlockDone = 1;\n\n\t// finish started, need only more output at next deflate\n\tvar FinishStarted = 2;\n\n\t// finish done, accept no more input or output\n\tvar FinishDone = 3;\n\n\t// preset dictionary flag in zlib header\n\tvar PRESET_DICT = 0x20;\n\n\tvar INIT_STATE = 42;\n\tvar BUSY_STATE = 113;\n\tvar FINISH_STATE = 666;\n\n\t// The deflate compression method\n\tvar Z_DEFLATED = 8;\n\n\tvar STORED_BLOCK = 0;\n\tvar STATIC_TREES = 1;\n\tvar DYN_TREES = 2;\n\n\tvar MIN_MATCH = 3;\n\tvar MAX_MATCH = 258;\n\tvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n\tfunction smaller(tree, n, m, depth) {\n\t\tvar tn2 = tree[n * 2];\n\t\tvar tm2 = tree[m * 2];\n\t\treturn (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));\n\t}\n\n\tfunction Deflate() {\n\n\t\tvar that = this;\n\t\tvar strm; // pointer back to this zlib stream\n\t\tvar status; // as the name implies\n\t\t// pending_buf; // output still pending\n\t\tvar pending_buf_size; // size of pending_buf\n\t\t// pending_out; // next pending byte to output to the stream\n\t\t// pending; // nb of bytes in the pending buffer\n\t\tvar method; // STORED (for zip only) or DEFLATED\n\t\tvar last_flush; // value of flush param for previous deflate call\n\n\t\tvar w_size; // LZ77 window size (32K by default)\n\t\tvar w_bits; // log2(w_size) (8..16)\n\t\tvar w_mask; // w_size - 1\n\n\t\tvar window;\n\t\t// Sliding window. Input bytes are read into the second half of the window,\n\t\t// and move to the first half later to keep a dictionary of at least wSize\n\t\t// bytes. With this organization, matches are limited to a distance of\n\t\t// wSize-MAX_MATCH bytes, but this ensures that IO is always\n\t\t// performed with a length multiple of the block size. Also, it limits\n\t\t// the window size to 64K, which is quite useful on MSDOS.\n\t\t// To do: use the user input buffer as sliding window.\n\n\t\tvar window_size;\n\t\t// Actual size of window: 2*wSize, except when the user input buffer\n\t\t// is directly used as sliding window.\n\n\t\tvar prev;\n\t\t// Link to older string with same hash index. To limit the size of this\n\t\t// array to 64K, this link is maintained only for the last 32K strings.\n\t\t// An index in this array is thus a window index modulo 32K.\n\n\t\tvar head; // Heads of the hash chains or NIL.\n\n\t\tvar ins_h; // hash index of string to be inserted\n\t\tvar hash_size; // number of elements in hash table\n\t\tvar hash_bits; // log2(hash_size)\n\t\tvar hash_mask; // hash_size-1\n\n\t\t// Number of bits by which ins_h must be shifted at each input\n\t\t// step. It must be such that after MIN_MATCH steps, the oldest\n\t\t// byte no longer takes part in the hash key, that is:\n\t\t// hash_shift * MIN_MATCH >= hash_bits\n\t\tvar hash_shift;\n\n\t\t// Window position at the beginning of the current output block. Gets\n\t\t// negative when the window is moved backwards.\n\n\t\tvar block_start;\n\n\t\tvar match_length; // length of best match\n\t\tvar prev_match; // previous match\n\t\tvar match_available; // set if previous match exists\n\t\tvar strstart; // start of string to insert\n\t\tvar match_start; // start of matching string\n\t\tvar lookahead; // number of valid bytes ahead in window\n\n\t\t// Length of the best match at previous step. Matches not greater than this\n\t\t// are discarded. This is used in the lazy match evaluation.\n\t\tvar prev_length;\n\n\t\t// To speed up deflation, hash chains are never searched beyond this\n\t\t// length. A higher limit improves compression ratio but degrades the speed.\n\t\tvar max_chain_length;\n\n\t\t// Attempt to find a better match only when the current match is strictly\n\t\t// smaller than this value. This mechanism is used only for compression\n\t\t// levels >= 4.\n\t\tvar max_lazy_match;\n\n\t\t// Insert new strings in the hash table only if the match length is not\n\t\t// greater than this length. This saves time but degrades compression.\n\t\t// max_insert_length is used only for compression levels <= 3.\n\n\t\tvar level; // compression level (1..9)\n\t\tvar strategy; // favor or force Huffman coding\n\n\t\t// Use a faster search when the previous match is longer than this\n\t\tvar good_match;\n\n\t\t// Stop searching when current match exceeds this\n\t\tvar nice_match;\n\n\t\tvar dyn_ltree; // literal and length tree\n\t\tvar dyn_dtree; // distance tree\n\t\tvar bl_tree; // Huffman tree for bit lengths\n\n\t\tvar l_desc = new Tree(); // desc for literal tree\n\t\tvar d_desc = new Tree(); // desc for distance tree\n\t\tvar bl_desc = new Tree(); // desc for bit length tree\n\n\t\t// that.heap_len; // number of elements in the heap\n\t\t// that.heap_max; // element of largest frequency\n\t\t// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n\t\t// The same heap array is used to build all trees.\n\n\t\t// Depth of each subtree used as tie breaker for trees of equal frequency\n\t\tthat.depth = [];\n\n\t\tvar l_buf; // index for literals or lengths */\n\n\t\t// Size of match buffer for literals/lengths. There are 4 reasons for\n\t\t// limiting lit_bufsize to 64K:\n\t\t// - frequencies can be kept in 16 bit counters\n\t\t// - if compression is not successful for the first block, all input\n\t\t// data is still in the window so we can still emit a stored block even\n\t\t// when input comes from standard input. (This can also be done for\n\t\t// all blocks if lit_bufsize is not greater than 32K.)\n\t\t// - if compression is not successful for a file smaller than 64K, we can\n\t\t// even emit a stored file instead of a stored block (saving 5 bytes).\n\t\t// This is applicable only for zip (not gzip or zlib).\n\t\t// - creating new Huffman trees less frequently may not provide fast\n\t\t// adaptation to changes in the input data statistics. (Take for\n\t\t// example a binary file with poorly compressible code followed by\n\t\t// a highly compressible string table.) Smaller buffer sizes give\n\t\t// fast adaptation but have of course the overhead of transmitting\n\t\t// trees more frequently.\n\t\t// - I can't count above 4\n\t\tvar lit_bufsize;\n\n\t\tvar last_lit; // running index in l_buf\n\n\t\t// Buffer for distances. To simplify the code, d_buf and l_buf have\n\t\t// the same number of elements. To use different lengths, an extra flag\n\t\t// array would be necessary.\n\n\t\tvar d_buf; // index of pendig_buf\n\n\t\t// that.opt_len; // bit length of current block with optimal trees\n\t\t// that.static_len; // bit length of current block with static trees\n\t\tvar matches; // number of string matches in current block\n\t\tvar last_eob_len; // bit length of EOB code for last block\n\n\t\t// Output buffer. bits are inserted starting at the bottom (least\n\t\t// significant bits).\n\t\tvar bi_buf;\n\n\t\t// Number of valid bits in bi_buf. All bits above the last valid bit\n\t\t// are always zero.\n\t\tvar bi_valid;\n\n\t\t// number of codes at each bit length for an optimal tree\n\t\tthat.bl_count = [];\n\n\t\t// heap used to build the Huffman trees\n\t\tthat.heap = [];\n\n\t\tdyn_ltree = [];\n\t\tdyn_dtree = [];\n\t\tbl_tree = [];\n\n\t\tfunction lm_init() {\n\t\t\tvar i;\n\t\t\twindow_size = 2 * w_size;\n\n\t\t\thead[hash_size - 1] = 0;\n\t\t\tfor (i = 0; i < hash_size - 1; i++) {\n\t\t\t\thead[i] = 0;\n\t\t\t}\n\n\t\t\t// Set the default configuration parameters:\n\t\t\tmax_lazy_match = config_table[level].max_lazy;\n\t\t\tgood_match = config_table[level].good_length;\n\t\t\tnice_match = config_table[level].nice_length;\n\t\t\tmax_chain_length = config_table[level].max_chain;\n\n\t\t\tstrstart = 0;\n\t\t\tblock_start = 0;\n\t\t\tlookahead = 0;\n\t\t\tmatch_length = prev_length = MIN_MATCH - 1;\n\t\t\tmatch_available = 0;\n\t\t\tins_h = 0;\n\t\t}\n\n\t\tfunction init_block() {\n\t\t\tvar i;\n\t\t\t// Initialize the trees.\n\t\t\tfor (i = 0; i < L_CODES; i++)\n\t\t\t\tdyn_ltree[i * 2] = 0;\n\t\t\tfor (i = 0; i < D_CODES; i++)\n\t\t\t\tdyn_dtree[i * 2] = 0;\n\t\t\tfor (i = 0; i < BL_CODES; i++)\n\t\t\t\tbl_tree[i * 2] = 0;\n\n\t\t\tdyn_ltree[END_BLOCK * 2] = 1;\n\t\t\tthat.opt_len = that.static_len = 0;\n\t\t\tlast_lit = matches = 0;\n\t\t}\n\n\t\t// Initialize the tree data structures for a new zlib stream.\n\t\tfunction tr_init() {\n\n\t\t\tl_desc.dyn_tree = dyn_ltree;\n\t\t\tl_desc.stat_desc = StaticTree.static_l_desc;\n\n\t\t\td_desc.dyn_tree = dyn_dtree;\n\t\t\td_desc.stat_desc = StaticTree.static_d_desc;\n\n\t\t\tbl_desc.dyn_tree = bl_tree;\n\t\t\tbl_desc.stat_desc = StaticTree.static_bl_desc;\n\n\t\t\tbi_buf = 0;\n\t\t\tbi_valid = 0;\n\t\t\tlast_eob_len = 8; // enough lookahead for inflate\n\n\t\t\t// Initialize the first block of the first file:\n\t\t\tinit_block();\n\t\t}\n\n\t\t// Restore the heap property by moving down the tree starting at node k,\n\t\t// exchanging a node with the smallest of its two sons if necessary,\n\t\t// stopping\n\t\t// when the heap property is re-established (each father smaller than its\n\t\t// two sons).\n\t\tthat.pqdownheap = function(tree, // the tree to restore\n\t\tk // node to move down\n\t\t) {\n\t\t\tvar heap = that.heap;\n\t\t\tvar v = heap[k];\n\t\t\tvar j = k << 1; // left son of k\n\t\t\twhile (j <= that.heap_len) {\n\t\t\t\t// Set j to the smallest of the two sons:\n\t\t\t\tif (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t// Exit if v is smaller than both sons\n\t\t\t\tif (smaller(tree, v, heap[j], that.depth))\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Exchange v with the smallest son\n\t\t\t\theap[k] = heap[j];\n\t\t\t\tk = j;\n\t\t\t\t// And continue down the tree, setting j to the left son of k\n\t\t\t\tj <<= 1;\n\t\t\t}\n\t\t\theap[k] = v;\n\t\t};\n\n\t\t// Scan a literal or distance tree to determine the frequencies of the codes\n\t\t// in the bit length tree.\n\t\tfunction scan_tree(tree,// the tree to be scanned\n\t\tmax_code // and its largest code of non zero frequency\n\t\t) {\n\t\t\tvar n; // iterates over all tree elements\n\t\t\tvar prevlen = -1; // last emitted length\n\t\t\tvar curlen; // length of current code\n\t\t\tvar nextlen = tree[0 * 2 + 1]; // length of next code\n\t\t\tvar count = 0; // repeat count of the current code\n\t\t\tvar max_count = 7; // max repeat count\n\t\t\tvar min_count = 4; // min repeat count\n\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t}\n\t\t\ttree[(max_code + 1) * 2 + 1] = 0xffff; // guard\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tcurlen = nextlen;\n\t\t\t\tnextlen = tree[(n + 1) * 2 + 1];\n\t\t\t\tif (++count < max_count && curlen == nextlen) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (count < min_count) {\n\t\t\t\t\tbl_tree[curlen * 2] += count;\n\t\t\t\t} else if (curlen !== 0) {\n\t\t\t\t\tif (curlen != prevlen)\n\t\t\t\t\t\tbl_tree[curlen * 2]++;\n\t\t\t\t\tbl_tree[REP_3_6 * 2]++;\n\t\t\t\t} else if (count <= 10) {\n\t\t\t\t\tbl_tree[REPZ_3_10 * 2]++;\n\t\t\t\t} else {\n\t\t\t\t\tbl_tree[REPZ_11_138 * 2]++;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tprevlen = curlen;\n\t\t\t\tif (nextlen === 0) {\n\t\t\t\t\tmax_count = 138;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else if (curlen == nextlen) {\n\t\t\t\t\tmax_count = 6;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else {\n\t\t\t\t\tmax_count = 7;\n\t\t\t\t\tmin_count = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Construct the Huffman tree for the bit lengths and return the index in\n\t\t// bl_order of the last bit length code to send.\n\t\tfunction build_bl_tree() {\n\t\t\tvar max_blindex; // index of last bit length code of non zero freq\n\n\t\t\t// Determine the bit length frequencies for literal and distance trees\n\t\t\tscan_tree(dyn_ltree, l_desc.max_code);\n\t\t\tscan_tree(dyn_dtree, d_desc.max_code);\n\n\t\t\t// Build the bit length tree:\n\t\t\tbl_desc.build_tree(that);\n\t\t\t// opt_len now includes the length of the tree representations, except\n\t\t\t// the lengths of the bit lengths codes and the 5+5+4 bits for the\n\t\t\t// counts.\n\n\t\t\t// Determine the number of bit length codes to send. The pkzip format\n\t\t\t// requires that at least 4 bit length codes be sent. (appnote.txt says\n\t\t\t// 3 but the actual value used is 4.)\n\t\t\tfor (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n\t\t\t\tif (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Update opt_len to include the bit length tree and counts\n\t\t\tthat.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\n\t\t\treturn max_blindex;\n\t\t}\n\n\t\t// Output a byte on the stream.\n\t\t// IN assertion: there is enough room in pending_buf.\n\t\tfunction put_byte(p) {\n\t\t\tthat.pending_buf[that.pending++] = p;\n\t\t}\n\n\t\tfunction put_short(w) {\n\t\t\tput_byte(w & 0xff);\n\t\t\tput_byte((w >>> 8) & 0xff);\n\t\t}\n\n\t\tfunction putShortMSB(b) {\n\t\t\tput_byte((b >> 8) & 0xff);\n\t\t\tput_byte((b & 0xff) & 0xff);\n\t\t}\n\n\t\tfunction send_bits(value, length) {\n\t\t\tvar val, len = length;\n\t\t\tif (bi_valid > Buf_size - len) {\n\t\t\t\tval = value;\n\t\t\t\t// bi_buf |= (val << bi_valid);\n\t\t\t\tbi_buf |= ((val << bi_valid) & 0xffff);\n\t\t\t\tput_short(bi_buf);\n\t\t\t\tbi_buf = val >>> (Buf_size - bi_valid);\n\t\t\t\tbi_valid += len - Buf_size;\n\t\t\t} else {\n\t\t\t\t// bi_buf |= (value) << bi_valid;\n\t\t\t\tbi_buf |= (((value) << bi_valid) & 0xffff);\n\t\t\t\tbi_valid += len;\n\t\t\t}\n\t\t}\n\n\t\tfunction send_code(c, tree) {\n\t\t\tvar c2 = c * 2;\n\t\t\tsend_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);\n\t\t}\n\n\t\t// Send a literal or distance tree in compressed form, using the codes in\n\t\t// bl_tree.\n\t\tfunction send_tree(tree,// the tree to be sent\n\t\tmax_code // and its largest code of non zero frequency\n\t\t) {\n\t\t\tvar n; // iterates over all tree elements\n\t\t\tvar prevlen = -1; // last emitted length\n\t\t\tvar curlen; // length of current code\n\t\t\tvar nextlen = tree[0 * 2 + 1]; // length of next code\n\t\t\tvar count = 0; // repeat count of the current code\n\t\t\tvar max_count = 7; // max repeat count\n\t\t\tvar min_count = 4; // min repeat count\n\n\t\t\tif (nextlen === 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t}\n\n\t\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\t\tcurlen = nextlen;\n\t\t\t\tnextlen = tree[(n + 1) * 2 + 1];\n\t\t\t\tif (++count < max_count && curlen == nextlen) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (count < min_count) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tsend_code(curlen, bl_tree);\n\t\t\t\t\t} while (--count !== 0);\n\t\t\t\t} else if (curlen !== 0) {\n\t\t\t\t\tif (curlen != prevlen) {\n\t\t\t\t\t\tsend_code(curlen, bl_tree);\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t\tsend_code(REP_3_6, bl_tree);\n\t\t\t\t\tsend_bits(count - 3, 2);\n\t\t\t\t} else if (count <= 10) {\n\t\t\t\t\tsend_code(REPZ_3_10, bl_tree);\n\t\t\t\t\tsend_bits(count - 3, 3);\n\t\t\t\t} else {\n\t\t\t\t\tsend_code(REPZ_11_138, bl_tree);\n\t\t\t\t\tsend_bits(count - 11, 7);\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tprevlen = curlen;\n\t\t\t\tif (nextlen === 0) {\n\t\t\t\t\tmax_count = 138;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else if (curlen == nextlen) {\n\t\t\t\t\tmax_count = 6;\n\t\t\t\t\tmin_count = 3;\n\t\t\t\t} else {\n\t\t\t\t\tmax_count = 7;\n\t\t\t\t\tmin_count = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Send the header for a block using dynamic Huffman trees: the counts, the\n\t\t// lengths of the bit length codes, the literal tree and the distance tree.\n\t\t// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t\tfunction send_all_trees(lcodes, dcodes, blcodes) {\n\t\t\tvar rank; // index in bl_order\n\n\t\t\tsend_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n\t\t\tsend_bits(dcodes - 1, 5);\n\t\t\tsend_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n\t\t\tfor (rank = 0; rank < blcodes; rank++) {\n\t\t\t\tsend_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);\n\t\t\t}\n\t\t\tsend_tree(dyn_ltree, lcodes - 1); // literal tree\n\t\t\tsend_tree(dyn_dtree, dcodes - 1); // distance tree\n\t\t}\n\n\t\t// Flush the bit buffer, keeping at most 7 bits in it.\n\t\tfunction bi_flush() {\n\t\t\tif (bi_valid == 16) {\n\t\t\t\tput_short(bi_buf);\n\t\t\t\tbi_buf = 0;\n\t\t\t\tbi_valid = 0;\n\t\t\t} else if (bi_valid >= 8) {\n\t\t\t\tput_byte(bi_buf & 0xff);\n\t\t\t\tbi_buf >>>= 8;\n\t\t\t\tbi_valid -= 8;\n\t\t\t}\n\t\t}\n\n\t\t// Send one empty static block to give enough lookahead for inflate.\n\t\t// This takes 10 bits, of which 7 may remain in the bit buffer.\n\t\t// The current inflate code requires 9 bits of lookahead. If the\n\t\t// last two codes for the previous block (real code plus EOB) were coded\n\t\t// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\n\t\t// the last real code. In this case we send two empty static blocks instead\n\t\t// of one. (There are no problems if the previous block is stored or fixed.)\n\t\t// To simplify the code, we assume the worst case of last real code encoded\n\t\t// on one bit only.\n\t\tfunction _tr_align() {\n\t\t\tsend_bits(STATIC_TREES << 1, 3);\n\t\t\tsend_code(END_BLOCK, StaticTree.static_ltree);\n\n\t\t\tbi_flush();\n\n\t\t\t// Of the 10 bits for the empty block, we have already sent\n\t\t\t// (10 - bi_valid) bits. The lookahead for the last real code (before\n\t\t\t// the EOB of the previous block) was thus at least one plus the length\n\t\t\t// of the EOB plus what we have just sent of the empty static block.\n\t\t\tif (1 + last_eob_len + 10 - bi_valid < 9) {\n\t\t\t\tsend_bits(STATIC_TREES << 1, 3);\n\t\t\t\tsend_code(END_BLOCK, StaticTree.static_ltree);\n\t\t\t\tbi_flush();\n\t\t\t}\n\t\t\tlast_eob_len = 7;\n\t\t}\n\n\t\t// Save the match info and tally the frequency counts. Return true if\n\t\t// the current block must be flushed.\n\t\tfunction _tr_tally(dist, // distance of matched string\n\t\tlc // match length-MIN_MATCH or unmatched char (if dist==0)\n\t\t) {\n\t\t\tvar out_length, in_length, dcode;\n\t\t\tthat.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;\n\t\t\tthat.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;\n\n\t\t\tthat.pending_buf[l_buf + last_lit] = lc & 0xff;\n\t\t\tlast_lit++;\n\n\t\t\tif (dist === 0) {\n\t\t\t\t// lc is the unmatched char\n\t\t\t\tdyn_ltree[lc * 2]++;\n\t\t\t} else {\n\t\t\t\tmatches++;\n\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\tdist--; // dist = match distance - 1\n\t\t\t\tdyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;\n\t\t\t\tdyn_dtree[Tree.d_code(dist) * 2]++;\n\t\t\t}\n\n\t\t\tif ((last_lit & 0x1fff) === 0 && level > 2) {\n\t\t\t\t// Compute an upper bound for the compressed length\n\t\t\t\tout_length = last_lit * 8;\n\t\t\t\tin_length = strstart - block_start;\n\t\t\t\tfor (dcode = 0; dcode < D_CODES; dcode++) {\n\t\t\t\t\tout_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);\n\t\t\t\t}\n\t\t\t\tout_length >>>= 3;\n\t\t\t\tif ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn (last_lit == lit_bufsize - 1);\n\t\t\t// We avoid equality with lit_bufsize because of wraparound at 64K\n\t\t\t// on 16 bit machines and because stored blocks are restricted to\n\t\t\t// 64K-1 bytes.\n\t\t}\n\n\t\t// Send the block data compressed using the given Huffman trees\n\t\tfunction compress_block(ltree, dtree) {\n\t\t\tvar dist; // distance of matched string\n\t\t\tvar lc; // match length or unmatched char (if dist === 0)\n\t\t\tvar lx = 0; // running index in l_buf\n\t\t\tvar code; // the code to send\n\t\t\tvar extra; // number of extra bits to send\n\n\t\t\tif (last_lit !== 0) {\n\t\t\t\tdo {\n\t\t\t\t\tdist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);\n\t\t\t\t\tlc = (that.pending_buf[l_buf + lx]) & 0xff;\n\t\t\t\t\tlx++;\n\n\t\t\t\t\tif (dist === 0) {\n\t\t\t\t\t\tsend_code(lc, ltree); // send a literal byte\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\t\t\tcode = Tree._length_code[lc];\n\n\t\t\t\t\t\tsend_code(code + LITERALS + 1, ltree); // send the length\n\t\t\t\t\t\t// code\n\t\t\t\t\t\textra = Tree.extra_lbits[code];\n\t\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\t\tlc -= Tree.base_length[code];\n\t\t\t\t\t\t\tsend_bits(lc, extra); // send the extra length bits\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist--; // dist is now the match distance - 1\n\t\t\t\t\t\tcode = Tree.d_code(dist);\n\n\t\t\t\t\t\tsend_code(code, dtree); // send the distance code\n\t\t\t\t\t\textra = Tree.extra_dbits[code];\n\t\t\t\t\t\tif (extra !== 0) {\n\t\t\t\t\t\t\tdist -= Tree.base_dist[code];\n\t\t\t\t\t\t\tsend_bits(dist, extra); // send the extra distance bits\n\t\t\t\t\t\t}\n\t\t\t\t\t} // literal or match pair ?\n\n\t\t\t\t\t// Check that the overlay between pending_buf and d_buf+l_buf is\n\t\t\t\t\t// ok:\n\t\t\t\t} while (lx < last_lit);\n\t\t\t}\n\n\t\t\tsend_code(END_BLOCK, ltree);\n\t\t\tlast_eob_len = ltree[END_BLOCK * 2 + 1];\n\t\t}\n\n\t\t// Flush the bit buffer and align the output on a byte boundary\n\t\tfunction bi_windup() {\n\t\t\tif (bi_valid > 8) {\n\t\t\t\tput_short(bi_buf);\n\t\t\t} else if (bi_valid > 0) {\n\t\t\t\tput_byte(bi_buf & 0xff);\n\t\t\t}\n\t\t\tbi_buf = 0;\n\t\t\tbi_valid = 0;\n\t\t}\n\n\t\t// Copy a stored block, storing first the length and its\n\t\t// one's complement if requested.\n\t\tfunction copy_block(buf, // the input data\n\t\tlen, // its length\n\t\theader // true if block header must be written\n\t\t) {\n\t\t\tbi_windup(); // align on byte boundary\n\t\t\tlast_eob_len = 8; // enough lookahead for inflate\n\n\t\t\tif (header) {\n\t\t\t\tput_short(len);\n\t\t\t\tput_short(~len);\n\t\t\t}\n\n\t\t\tthat.pending_buf.set(window.subarray(buf, buf + len), that.pending);\n\t\t\tthat.pending += len;\n\t\t}\n\n\t\t// Send a stored block\n\t\tfunction _tr_stored_block(buf, // input block\n\t\tstored_len, // length of input block\n\t\teof // true if this is the last block for a file\n\t\t) {\n\t\t\tsend_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type\n\t\t\tcopy_block(buf, stored_len, true); // with header\n\t\t}\n\n\t\t// Determine the best encoding for the current block: dynamic trees, static\n\t\t// trees or store, and output the encoded block to the zip file.\n\t\tfunction _tr_flush_block(buf, // input block, or NULL if too old\n\t\tstored_len, // length of input block\n\t\teof // true if this is the last block for a file\n\t\t) {\n\t\t\tvar opt_lenb, static_lenb;// opt_len and static_len in bytes\n\t\t\tvar max_blindex = 0; // index of last bit length code of non zero freq\n\n\t\t\t// Build the Huffman trees unless a stored block is forced\n\t\t\tif (level > 0) {\n\t\t\t\t// Construct the literal and distance trees\n\t\t\t\tl_desc.build_tree(that);\n\n\t\t\t\td_desc.build_tree(that);\n\n\t\t\t\t// At this point, opt_len and static_len are the total bit lengths\n\t\t\t\t// of\n\t\t\t\t// the compressed block data, excluding the tree representations.\n\n\t\t\t\t// Build the bit length tree for the above two trees, and get the\n\t\t\t\t// index\n\t\t\t\t// in bl_order of the last bit length code to send.\n\t\t\t\tmax_blindex = build_bl_tree();\n\n\t\t\t\t// Determine the best encoding. Compute first the block length in\n\t\t\t\t// bytes\n\t\t\t\topt_lenb = (that.opt_len + 3 + 7) >>> 3;\n\t\t\t\tstatic_lenb = (that.static_len + 3 + 7) >>> 3;\n\n\t\t\t\tif (static_lenb <= opt_lenb)\n\t\t\t\t\topt_lenb = static_lenb;\n\t\t\t} else {\n\t\t\t\topt_lenb = static_lenb = stored_len + 5; // force a stored block\n\t\t\t}\n\n\t\t\tif ((stored_len + 4 <= opt_lenb) && buf != -1) {\n\t\t\t\t// 4: two words for the lengths\n\t\t\t\t// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t\t\t// Otherwise we can't have processed more than WSIZE input bytes\n\t\t\t\t// since\n\t\t\t\t// the last block flush, because compression would have been\n\t\t\t\t// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t\t\t// transform a block into a stored block.\n\t\t\t\t_tr_stored_block(buf, stored_len, eof);\n\t\t\t} else if (static_lenb == opt_lenb) {\n\t\t\t\tsend_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);\n\t\t\t\tcompress_block(StaticTree.static_ltree, StaticTree.static_dtree);\n\t\t\t} else {\n\t\t\t\tsend_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);\n\t\t\t\tsend_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\n\t\t\t\tcompress_block(dyn_ltree, dyn_dtree);\n\t\t\t}\n\n\t\t\t// The above check is made mod 2^32, for files larger than 512 MB\n\t\t\t// and uLong implemented on 32 bits.\n\n\t\t\tinit_block();\n\n\t\t\tif (eof) {\n\t\t\t\tbi_windup();\n\t\t\t}\n\t\t}\n\n\t\tfunction flush_block_only(eof) {\n\t\t\t_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);\n\t\t\tblock_start = strstart;\n\t\t\tstrm.flush_pending();\n\t\t}\n\n\t\t// Fill the window when the lookahead becomes insufficient.\n\t\t// Updates strstart and lookahead.\n\t\t//\n\t\t// IN assertion: lookahead < MIN_LOOKAHEAD\n\t\t// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n\t\t// At least one byte has been read, or avail_in === 0; reads are\n\t\t// performed for at least two bytes (required for the zip translate_eol\n\t\t// option -- not supported here).\n\t\tfunction fill_window() {\n\t\t\tvar n, m;\n\t\t\tvar p;\n\t\t\tvar more; // Amount of free space at the end of the window.\n\n\t\t\tdo {\n\t\t\t\tmore = (window_size - lookahead - strstart);\n\n\t\t\t\t// Deal with !@#$% 64K limit:\n\t\t\t\tif (more === 0 && strstart === 0 && lookahead === 0) {\n\t\t\t\t\tmore = w_size;\n\t\t\t\t} else if (more == -1) {\n\t\t\t\t\t// Very unlikely, but possible on 16 bit machine if strstart ==\n\t\t\t\t\t// 0\n\t\t\t\t\t// and lookahead == 1 (input done one byte at time)\n\t\t\t\t\tmore--;\n\n\t\t\t\t\t// If the window is almost full and there is insufficient\n\t\t\t\t\t// lookahead,\n\t\t\t\t\t// move the upper half to the lower one to make room in the\n\t\t\t\t\t// upper half.\n\t\t\t\t} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\twindow.set(window.subarray(w_size, w_size + w_size), 0);\n\n\t\t\t\t\tmatch_start -= w_size;\n\t\t\t\t\tstrstart -= w_size; // we now have strstart >= MAX_DIST\n\t\t\t\t\tblock_start -= w_size;\n\n\t\t\t\t\t// Slide the hash table (could be avoided with 32 bit values\n\t\t\t\t\t// at the expense of memory usage). We slide even when level ==\n\t\t\t\t\t// 0\n\t\t\t\t\t// to keep the hash table consistent if we switch back to level\n\t\t\t\t\t// > 0\n\t\t\t\t\t// later. (Using level 0 permanently is not an optimal usage of\n\t\t\t\t\t// zlib, so we don't care about this pathological case.)\n\n\t\t\t\t\tn = hash_size;\n\t\t\t\t\tp = n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tm = (head[--p] & 0xffff);\n\t\t\t\t\t\thead[p] = (m >= w_size ? m - w_size : 0);\n\t\t\t\t\t} while (--n !== 0);\n\n\t\t\t\t\tn = w_size;\n\t\t\t\t\tp = n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tm = (prev[--p] & 0xffff);\n\t\t\t\t\t\tprev[p] = (m >= w_size ? m - w_size : 0);\n\t\t\t\t\t\t// If n is not on any hash chain, prev[n] is garbage but\n\t\t\t\t\t\t// its value will never be used.\n\t\t\t\t\t} while (--n !== 0);\n\t\t\t\t\tmore += w_size;\n\t\t\t\t}\n\n\t\t\t\tif (strm.avail_in === 0)\n\t\t\t\t\treturn;\n\n\t\t\t\t// If there was no sliding:\n\t\t\t\t// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n\t\t\t\t// more == window_size - lookahead - strstart\n\t\t\t\t// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n\t\t\t\t// => more >= window_size - 2*WSIZE + 2\n\t\t\t\t// In the BIG_MEM or MMAP case (not yet supported),\n\t\t\t\t// window_size == input_size + MIN_LOOKAHEAD &&\n\t\t\t\t// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n\t\t\t\t// Otherwise, window_size == 2*WSIZE so more >= 2.\n\t\t\t\t// If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n\n\t\t\t\tn = strm.read_buf(window, strstart + lookahead, more);\n\t\t\t\tlookahead += n;\n\n\t\t\t\t// Initialize the hash value now that we have some input:\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = window[strstart] & 0xff;\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\n\t\t\t\t}\n\t\t\t\t// If the whole input has less than MIN_MATCH bytes, ins_h is\n\t\t\t\t// garbage,\n\t\t\t\t// but this is not important since only literal bytes will be\n\t\t\t\t// emitted.\n\t\t\t} while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);\n\t\t}\n\n\t\t// Copy without compression as much as possible from the input stream,\n\t\t// return\n\t\t// the current block state.\n\t\t// This function does not insert new strings in the dictionary since\n\t\t// uncompressible data is probably not useful. This function is used\n\t\t// only for the level=0 compression option.\n\t\t// NOTE: this function should be optimized to avoid extra copying from\n\t\t// window to pending_buf.\n\t\tfunction deflate_stored(flush) {\n\t\t\t// Stored blocks are limited to 0xffff bytes, pending_buf is limited\n\t\t\t// to pending_buf_size, and each stored block has a 5 byte header:\n\n\t\t\tvar max_block_size = 0xffff;\n\t\t\tvar max_start;\n\n\t\t\tif (max_block_size > pending_buf_size - 5) {\n\t\t\t\tmax_block_size = pending_buf_size - 5;\n\t\t\t}\n\n\t\t\t// Copy as much as possible from input to output:\n\t\t\twhile (true) {\n\t\t\t\t// Fill the window as much as possible:\n\t\t\t\tif (lookahead <= 1) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead === 0 && flush == Z_NO_FLUSH)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\tstrstart += lookahead;\n\t\t\t\tlookahead = 0;\n\n\t\t\t\t// Emit a stored block if pending_buf will be full:\n\t\t\t\tmax_start = block_start + max_block_size;\n\t\t\t\tif (strstart === 0 || strstart >= max_start) {\n\t\t\t\t\t// strstart === 0 is possible when wraparound on 16-bit machine\n\t\t\t\t\tlookahead = (strstart - max_start);\n\t\t\t\t\tstrstart = max_start;\n\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\n\t\t\t\t}\n\n\t\t\t\t// Flush if we may have to slide, otherwise block_start may become\n\t\t\t\t// negative and the data will be gone:\n\t\t\t\tif (strstart - block_start >= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflush_block_only(flush == Z_FINISH);\n\t\t\tif (strm.avail_out === 0)\n\t\t\t\treturn (flush == Z_FINISH) ? FinishStarted : NeedMore;\n\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\tfunction longest_match(cur_match) {\n\t\t\tvar chain_length = max_chain_length; // max hash chain length\n\t\t\tvar scan = strstart; // current string\n\t\t\tvar match; // matched string\n\t\t\tvar len; // length of current match\n\t\t\tvar best_len = prev_length; // best match length so far\n\t\t\tvar limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;\n\t\t\tvar _nice_match = nice_match;\n\n\t\t\t// Stop when cur_match becomes <= limit. To simplify the code,\n\t\t\t// we prevent matches with the string of window index 0.\n\n\t\t\tvar wmask = w_mask;\n\n\t\t\tvar strend = strstart + MAX_MATCH;\n\t\t\tvar scan_end1 = window[scan + best_len - 1];\n\t\t\tvar scan_end = window[scan + best_len];\n\n\t\t\t// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of\n\t\t\t// 16.\n\t\t\t// It is easy to get rid of this optimization if necessary.\n\n\t\t\t// Do not waste too much time if we already have a good match:\n\t\t\tif (prev_length >= good_match) {\n\t\t\t\tchain_length >>= 2;\n\t\t\t}\n\n\t\t\t// Do not look for matches beyond the end of the input. This is\n\t\t\t// necessary\n\t\t\t// to make deflate deterministic.\n\t\t\tif (_nice_match > lookahead)\n\t\t\t\t_nice_match = lookahead;\n\n\t\t\tdo {\n\t\t\t\tmatch = cur_match;\n\n\t\t\t\t// Skip to next match if the match length cannot increase\n\t\t\t\t// or if the match length is less than 2:\n\t\t\t\tif (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan]\n\t\t\t\t\t\t|| window[++match] != window[scan + 1])\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The check at best_len-1 can be removed because it will be made\n\t\t\t\t// again later. (This heuristic is not always a win.)\n\t\t\t\t// It is not necessary to compare scan[2] and match[2] since they\n\t\t\t\t// are always equal when the other bytes match, given that\n\t\t\t\t// the hash keys are equal and that HASH_BITS >= 8.\n\t\t\t\tscan += 2;\n\t\t\t\tmatch++;\n\n\t\t\t\t// We check for insufficient lookahead only every 8th comparison;\n\t\t\t\t// the 256th check will be made at strstart+258.\n\t\t\t\tdo {\n\t\t\t\t} while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\n\t\t\t\t\t\t&& window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]\n\t\t\t\t\t\t&& window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);\n\n\t\t\t\tlen = MAX_MATCH - (strend - scan);\n\t\t\t\tscan = strend - MAX_MATCH;\n\n\t\t\t\tif (len > best_len) {\n\t\t\t\t\tmatch_start = cur_match;\n\t\t\t\t\tbest_len = len;\n\t\t\t\t\tif (len >= _nice_match)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tscan_end1 = window[scan + best_len - 1];\n\t\t\t\t\tscan_end = window[scan + best_len];\n\t\t\t\t}\n\n\t\t\t} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);\n\n\t\t\tif (best_len <= lookahead)\n\t\t\t\treturn best_len;\n\t\t\treturn lookahead;\n\t\t}\n\n\t\t// Compress as much as possible from the input stream, return the current\n\t\t// block state.\n\t\t// This function does not perform lazy evaluation of matches and inserts\n\t\t// new strings in the dictionary only for unmatched strings or for short\n\t\t// matches. It is used only for the fast compression options.\n\t\tfunction deflate_fast(flush) {\n\t\t\t// short hash_head = 0; // head of the hash chain\n\t\t\tvar hash_head = 0; // head of the hash chain\n\t\t\tvar bflush; // set if current block must be flushed\n\n\t\t\twhile (true) {\n\t\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t\t// string following the next match.\n\t\t\t\tif (lookahead < MIN_LOOKAHEAD) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\n\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t}\n\n\t\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\t\t// At this point we have always match_length < MIN_MATCH\n\n\t\t\t\tif (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t\t// of the string with itself at the start of the input file).\n\t\t\t\t\tif (strategy != Z_HUFFMAN_ONLY) {\n\t\t\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t\t}\n\t\t\t\t\t// longest_match() sets match_start\n\t\t\t\t}\n\t\t\t\tif (match_length >= MIN_MATCH) {\n\t\t\t\t\t// check_match(strstart, match_start, match_length);\n\n\t\t\t\t\tbflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);\n\n\t\t\t\t\tlookahead -= match_length;\n\n\t\t\t\t\t// Insert new strings in the hash table only if the match length\n\t\t\t\t\t// is not too large. This saves time but degrades compression.\n\t\t\t\t\tif (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {\n\t\t\t\t\t\tmatch_length--; // string at strstart already in hash table\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tstrstart++;\n\n\t\t\t\t\t\t\tins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\t\t\thead[ins_h] = strstart;\n\n\t\t\t\t\t\t\t// strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t\t\t// always MIN_MATCH bytes ahead.\n\t\t\t\t\t\t} while (--match_length !== 0);\n\t\t\t\t\t\tstrstart++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrstart += match_length;\n\t\t\t\t\t\tmatch_length = 0;\n\t\t\t\t\t\tins_h = window[strstart] & 0xff;\n\n\t\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;\n\t\t\t\t\t\t// If lookahead < MIN_MATCH, ins_h is garbage, but it does\n\t\t\t\t\t\t// not\n\t\t\t\t\t\t// matter since it will be recomputed at next deflate call.\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No match, output a literal byte\n\n\t\t\t\t\tbflush = _tr_tally(0, window[strstart] & 0xff);\n\t\t\t\t\tlookahead--;\n\t\t\t\t\tstrstart++;\n\t\t\t\t}\n\t\t\t\tif (bflush) {\n\n\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflush_block_only(flush == Z_FINISH);\n\t\t\tif (strm.avail_out === 0) {\n\t\t\t\tif (flush == Z_FINISH)\n\t\t\t\t\treturn FinishStarted;\n\t\t\t\telse\n\t\t\t\t\treturn NeedMore;\n\t\t\t}\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\t// Same as above, but achieves better compression. We use a lazy\n\t\t// evaluation for matches: a match is finally adopted only if there is\n\t\t// no better match at the next window position.\n\t\tfunction deflate_slow(flush) {\n\t\t\t// short hash_head = 0; // head of hash chain\n\t\t\tvar hash_head = 0; // head of hash chain\n\t\t\tvar bflush; // set if current block must be flushed\n\t\t\tvar max_insert;\n\n\t\t\t// Process the input block.\n\t\t\twhile (true) {\n\t\t\t\t// Make sure that we always have enough lookahead, except\n\t\t\t\t// at the end of the input file. We need MAX_MATCH bytes\n\t\t\t\t// for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t\t// string following the next match.\n\n\t\t\t\tif (lookahead < MIN_LOOKAHEAD) {\n\t\t\t\t\tfill_window();\n\t\t\t\t\tif (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t\tif (lookahead === 0)\n\t\t\t\t\t\tbreak; // flush the current block\n\t\t\t\t}\n\n\t\t\t\t// Insert the string window[strstart .. strstart+2] in the\n\t\t\t\t// dictionary, and set hash_head to the head of the hash chain:\n\n\t\t\t\tif (lookahead >= MIN_MATCH) {\n\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t}\n\n\t\t\t\t// Find the longest match, discarding those <= prev_length.\n\t\t\t\tprev_length = match_length;\n\t\t\t\tprev_match = match_start;\n\t\t\t\tmatch_length = MIN_MATCH - 1;\n\n\t\t\t\tif (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {\n\t\t\t\t\t// To simplify the code, we prevent matches with the string\n\t\t\t\t\t// of window index 0 (in particular we have to avoid a match\n\t\t\t\t\t// of the string with itself at the start of the input file).\n\n\t\t\t\t\tif (strategy != Z_HUFFMAN_ONLY) {\n\t\t\t\t\t\tmatch_length = longest_match(hash_head);\n\t\t\t\t\t}\n\t\t\t\t\t// longest_match() sets match_start\n\n\t\t\t\t\tif (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {\n\n\t\t\t\t\t\t// If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t\t\t\t// but we will ignore the current match anyway.\n\t\t\t\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If there was a match at the previous step and the current\n\t\t\t\t// match is not better, output the previous match:\n\t\t\t\tif (prev_length >= MIN_MATCH && match_length <= prev_length) {\n\t\t\t\t\tmax_insert = strstart + lookahead - MIN_MATCH;\n\t\t\t\t\t// Do not insert strings in hash table beyond this.\n\n\t\t\t\t\t// check_match(strstart-1, prev_match, prev_length);\n\n\t\t\t\t\tbflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);\n\n\t\t\t\t\t// Insert in hash table all strings up to the end of the match.\n\t\t\t\t\t// strstart-1 and strstart are already inserted. If there is not\n\t\t\t\t\t// enough lookahead, the last two strings are not inserted in\n\t\t\t\t\t// the hash table.\n\t\t\t\t\tlookahead -= prev_length - 1;\n\t\t\t\t\tprev_length -= 2;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (++strstart <= max_insert) {\n\t\t\t\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\t\t\t\t// prev[strstart&w_mask]=hash_head=head[ins_h];\n\t\t\t\t\t\t\thash_head = (head[ins_h] & 0xffff);\n\t\t\t\t\t\t\tprev[strstart & w_mask] = head[ins_h];\n\t\t\t\t\t\t\thead[ins_h] = strstart;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (--prev_length !== 0);\n\t\t\t\t\tmatch_available = 0;\n\t\t\t\t\tmatch_length = MIN_MATCH - 1;\n\t\t\t\t\tstrstart++;\n\n\t\t\t\t\tif (bflush) {\n\t\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t\t}\n\t\t\t\t} else if (match_available !== 0) {\n\n\t\t\t\t\t// If there was no match at the previous position, output a\n\t\t\t\t\t// single literal. If there was a match but the current match\n\t\t\t\t\t// is longer, truncate the previous match to a single literal.\n\n\t\t\t\t\tbflush = _tr_tally(0, window[strstart - 1] & 0xff);\n\n\t\t\t\t\tif (bflush) {\n\t\t\t\t\t\tflush_block_only(false);\n\t\t\t\t\t}\n\t\t\t\t\tstrstart++;\n\t\t\t\t\tlookahead--;\n\t\t\t\t\tif (strm.avail_out === 0)\n\t\t\t\t\t\treturn NeedMore;\n\t\t\t\t} else {\n\t\t\t\t\t// There is no previous match to compare with, wait for\n\t\t\t\t\t// the next step to decide.\n\n\t\t\t\t\tmatch_available = 1;\n\t\t\t\t\tstrstart++;\n\t\t\t\t\tlookahead--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match_available !== 0) {\n\t\t\t\tbflush = _tr_tally(0, window[strstart - 1] & 0xff);\n\t\t\t\tmatch_available = 0;\n\t\t\t}\n\t\t\tflush_block_only(flush == Z_FINISH);\n\n\t\t\tif (strm.avail_out === 0) {\n\t\t\t\tif (flush == Z_FINISH)\n\t\t\t\t\treturn FinishStarted;\n\t\t\t\telse\n\t\t\t\t\treturn NeedMore;\n\t\t\t}\n\n\t\t\treturn flush == Z_FINISH ? FinishDone : BlockDone;\n\t\t}\n\n\t\tfunction deflateReset(strm) {\n\t\t\tstrm.total_in = strm.total_out = 0;\n\t\t\tstrm.msg = null; //\n\t\t\t\n\t\t\tthat.pending = 0;\n\t\t\tthat.pending_out = 0;\n\n\t\t\tstatus = BUSY_STATE;\n\n\t\t\tlast_flush = Z_NO_FLUSH;\n\n\t\t\ttr_init();\n\t\t\tlm_init();\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {\n\t\t\tif (!_method)\n\t\t\t\t_method = Z_DEFLATED;\n\t\t\tif (!memLevel)\n\t\t\t\tmemLevel = DEF_MEM_LEVEL;\n\t\t\tif (!_strategy)\n\t\t\t\t_strategy = Z_DEFAULT_STRATEGY;\n\n\t\t\t// byte[] my_version=ZLIB_VERSION;\n\n\t\t\t//\n\t\t\t// if (!version || version[0] != my_version[0]\n\t\t\t// || stream_size != sizeof(z_stream)) {\n\t\t\t// return Z_VERSION_ERROR;\n\t\t\t// }\n\n\t\t\tstrm.msg = null;\n\n\t\t\tif (_level == Z_DEFAULT_COMPRESSION)\n\t\t\t\t_level = 6;\n\n\t\t\tif (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0\n\t\t\t\t\t|| _strategy > Z_HUFFMAN_ONLY) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tstrm.dstate = that;\n\n\t\t\tw_bits = bits;\n\t\t\tw_size = 1 << w_bits;\n\t\t\tw_mask = w_size - 1;\n\n\t\t\thash_bits = memLevel + 7;\n\t\t\thash_size = 1 << hash_bits;\n\t\t\thash_mask = hash_size - 1;\n\t\t\thash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n\t\t\twindow = new Uint8Array(w_size * 2);\n\t\t\tprev = [];\n\t\t\thead = [];\n\n\t\t\tlit_bufsize = 1 << (memLevel + 6); // 16K elements by default\n\n\t\t\t// We overlay pending_buf and d_buf+l_buf. This works since the average\n\t\t\t// output size for (length,distance) codes is <= 24 bits.\n\t\t\tthat.pending_buf = new Uint8Array(lit_bufsize * 4);\n\t\t\tpending_buf_size = lit_bufsize * 4;\n\n\t\t\td_buf = Math.floor(lit_bufsize / 2);\n\t\t\tl_buf = (1 + 2) * lit_bufsize;\n\n\t\t\tlevel = _level;\n\n\t\t\tstrategy = _strategy;\n\t\t\tmethod = _method & 0xff;\n\n\t\t\treturn deflateReset(strm);\n\t\t};\n\n\t\tthat.deflateEnd = function() {\n\t\t\tif (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\t// Deallocate in reverse order of allocations:\n\t\t\tthat.pending_buf = null;\n\t\t\thead = null;\n\t\t\tprev = null;\n\t\t\twindow = null;\n\t\t\t// free\n\t\t\tthat.dstate = null;\n\t\t\treturn status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n\t\t};\n\n\t\tthat.deflateParams = function(strm, _level, _strategy) {\n\t\t\tvar err = Z_OK;\n\n\t\t\tif (_level == Z_DEFAULT_COMPRESSION) {\n\t\t\t\t_level = 6;\n\t\t\t}\n\t\t\tif (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tif (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {\n\t\t\t\t// Flush the last buffer:\n\t\t\t\terr = strm.deflate(Z_PARTIAL_FLUSH);\n\t\t\t}\n\n\t\t\tif (level != _level) {\n\t\t\t\tlevel = _level;\n\t\t\t\tmax_lazy_match = config_table[level].max_lazy;\n\t\t\t\tgood_match = config_table[level].good_length;\n\t\t\t\tnice_match = config_table[level].nice_length;\n\t\t\t\tmax_chain_length = config_table[level].max_chain;\n\t\t\t}\n\t\t\tstrategy = _strategy;\n\t\t\treturn err;\n\t\t};\n\n\t\tthat.deflateSetDictionary = function(strm, dictionary, dictLength) {\n\t\t\tvar length = dictLength;\n\t\t\tvar n, index = 0;\n\n\t\t\tif (!dictionary || status != INIT_STATE)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tif (length < MIN_MATCH)\n\t\t\t\treturn Z_OK;\n\t\t\tif (length > w_size - MIN_LOOKAHEAD) {\n\t\t\t\tlength = w_size - MIN_LOOKAHEAD;\n\t\t\t\tindex = dictLength - length; // use the tail of the dictionary\n\t\t\t}\n\t\t\twindow.set(dictionary.subarray(index, index + length), 0);\n\n\t\t\tstrstart = length;\n\t\t\tblock_start = length;\n\n\t\t\t// Insert all strings in the hash table (except for the last two bytes).\n\t\t\t// s->lookahead stays null, so s->ins_h will be recomputed at the next\n\t\t\t// call of fill_window.\n\n\t\t\tins_h = window[0] & 0xff;\n\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;\n\n\t\t\tfor (n = 0; n <= length - MIN_MATCH; n++) {\n\t\t\t\tins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;\n\t\t\t\tprev[n & w_mask] = head[ins_h];\n\t\t\t\thead[ins_h] = n;\n\t\t\t}\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.deflate = function(_strm, flush) {\n\t\t\tvar i, header, level_flags, old_flush, bstate;\n\n\t\t\tif (flush > Z_FINISH || flush < 0) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\n\t\t\tif (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\tif (_strm.avail_out === 0) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\tstrm = _strm; // just in case\n\t\t\told_flush = last_flush;\n\t\t\tlast_flush = flush;\n\n\t\t\t// Write the zlib header\n\t\t\tif (status == INIT_STATE) {\n\t\t\t\theader = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;\n\t\t\t\tlevel_flags = ((level - 1) & 0xff) >> 1;\n\n\t\t\t\tif (level_flags > 3)\n\t\t\t\t\tlevel_flags = 3;\n\t\t\t\theader |= (level_flags << 6);\n\t\t\t\tif (strstart !== 0)\n\t\t\t\t\theader |= PRESET_DICT;\n\t\t\t\theader += 31 - (header % 31);\n\n\t\t\t\tstatus = BUSY_STATE;\n\t\t\t\tputShortMSB(header);\n\t\t\t}\n\n\t\t\t// Flush as much pending output as possible\n\t\t\tif (that.pending !== 0) {\n\t\t\t\tstrm.flush_pending();\n\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t// console.log(\" avail_out==0\");\n\t\t\t\t\t// Since avail_out is 0, deflate will be called again with\n\t\t\t\t\t// more output space, but possibly with both pending and\n\t\t\t\t\t// avail_in equal to zero. There won't be anything to do,\n\t\t\t\t\t// but this is not an error situation so make sure we\n\t\t\t\t\t// return OK instead of BUF_ERROR at next call of deflate:\n\t\t\t\t\tlast_flush = -1;\n\t\t\t\t\treturn Z_OK;\n\t\t\t\t}\n\n\t\t\t\t// Make sure there is something to do and avoid duplicate\n\t\t\t\t// consecutive\n\t\t\t\t// flushes. For repeated and useless calls with Z_FINISH, we keep\n\t\t\t\t// returning Z_STREAM_END instead of Z_BUFF_ERROR.\n\t\t\t} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {\n\t\t\t\tstrm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\t// User must not provide more input after the first FINISH:\n\t\t\tif (status == FINISH_STATE && strm.avail_in !== 0) {\n\t\t\t\t_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\t}\n\n\t\t\t// Start a new block or continue the current one.\n\t\t\tif (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {\n\t\t\t\tbstate = -1;\n\t\t\t\tswitch (config_table[level].func) {\n\t\t\t\tcase STORED:\n\t\t\t\t\tbstate = deflate_stored(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FAST:\n\t\t\t\t\tbstate = deflate_fast(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SLOW:\n\t\t\t\t\tbstate = deflate_slow(flush);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t}\n\n\t\t\t\tif (bstate == FinishStarted || bstate == FinishDone) {\n\t\t\t\t\tstatus = FINISH_STATE;\n\t\t\t\t}\n\t\t\t\tif (bstate == NeedMore || bstate == FinishStarted) {\n\t\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t\tlast_flush = -1; // avoid BUF_ERROR next call, see above\n\t\t\t\t\t}\n\t\t\t\t\treturn Z_OK;\n\t\t\t\t\t// If flush != Z_NO_FLUSH && avail_out === 0, the next call\n\t\t\t\t\t// of deflate should use the same flush parameter to make sure\n\t\t\t\t\t// that the flush is complete. So we don't have to output an\n\t\t\t\t\t// empty block here, this will be done at next call. This also\n\t\t\t\t\t// ensures that for a very small output buffer, we emit at most\n\t\t\t\t\t// one empty block.\n\t\t\t\t}\n\n\t\t\t\tif (bstate == BlockDone) {\n\t\t\t\t\tif (flush == Z_PARTIAL_FLUSH) {\n\t\t\t\t\t\t_tr_align();\n\t\t\t\t\t} else { // FULL_FLUSH or SYNC_FLUSH\n\t\t\t\t\t\t_tr_stored_block(0, 0, false);\n\t\t\t\t\t\t// For a full flush, this empty block will be recognized\n\t\t\t\t\t\t// as a special marker by inflate_sync().\n\t\t\t\t\t\tif (flush == Z_FULL_FLUSH) {\n\t\t\t\t\t\t\t// state.head[s.hash_size-1]=0;\n\t\t\t\t\t\t\tfor (i = 0; i < hash_size/*-1*/; i++)\n\t\t\t\t\t\t\t\t// forget history\n\t\t\t\t\t\t\t\thead[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstrm.flush_pending();\n\t\t\t\t\tif (strm.avail_out === 0) {\n\t\t\t\t\t\tlast_flush = -1; // avoid BUF_ERROR at next call, see above\n\t\t\t\t\t\treturn Z_OK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flush != Z_FINISH)\n\t\t\t\treturn Z_OK;\n\t\t\treturn Z_STREAM_END;\n\t\t};\n\t}\n\n\t// ZStream\n\n\tfunction ZStream() {\n\t\tvar that = this;\n\t\tthat.next_in_index = 0;\n\t\tthat.next_out_index = 0;\n\t\t// that.next_in; // next input byte\n\t\tthat.avail_in = 0; // number of bytes available at next_in\n\t\tthat.total_in = 0; // total nb of input bytes read so far\n\t\t// that.next_out; // next output byte should be put there\n\t\tthat.avail_out = 0; // remaining free space at next_out\n\t\tthat.total_out = 0; // total nb of bytes output so far\n\t\t// that.msg;\n\t\t// that.dstate;\n\t}\n\n\tZStream.prototype = {\n\t\tdeflateInit : function(level, bits) {\n\t\t\tvar that = this;\n\t\t\tthat.dstate = new Deflate();\n\t\t\tif (!bits)\n\t\t\t\tbits = MAX_BITS;\n\t\t\treturn that.dstate.deflateInit(that, level, bits);\n\t\t},\n\n\t\tdeflate : function(flush) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate) {\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\treturn that.dstate.deflate(that, flush);\n\t\t},\n\n\t\tdeflateEnd : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tvar ret = that.dstate.deflateEnd();\n\t\t\tthat.dstate = null;\n\t\t\treturn ret;\n\t\t},\n\n\t\tdeflateParams : function(level, strategy) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.dstate.deflateParams(that, level, strategy);\n\t\t},\n\n\t\tdeflateSetDictionary : function(dictionary, dictLength) {\n\t\t\tvar that = this;\n\t\t\tif (!that.dstate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.dstate.deflateSetDictionary(that, dictionary, dictLength);\n\t\t},\n\n\t\t// Read a new buffer from the current input stream, update the\n\t\t// total number of bytes read. All deflate() input goes through\n\t\t// this function so some applications may wish to modify it to avoid\n\t\t// allocating a large strm->next_in buffer and copying from it.\n\t\t// (See also flush_pending()).\n\t\tread_buf : function(buf, start, size) {\n\t\t\tvar that = this;\n\t\t\tvar len = that.avail_in;\n\t\t\tif (len > size)\n\t\t\t\tlen = size;\n\t\t\tif (len === 0)\n\t\t\t\treturn 0;\n\t\t\tthat.avail_in -= len;\n\t\t\tbuf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);\n\t\t\tthat.next_in_index += len;\n\t\t\tthat.total_in += len;\n\t\t\treturn len;\n\t\t},\n\n\t\t// Flush as much pending output as possible. All deflate() output goes\n\t\t// through this function so some applications may wish to modify it\n\t\t// to avoid allocating a large strm->next_out buffer and copying into it.\n\t\t// (See also read_buf()).\n\t\tflush_pending : function() {\n\t\t\tvar that = this;\n\t\t\tvar len = that.dstate.pending;\n\n\t\t\tif (len > that.avail_out)\n\t\t\t\tlen = that.avail_out;\n\t\t\tif (len === 0)\n\t\t\t\treturn;\n\n\t\t\t// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index\n\t\t\t// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +\n\t\t\t// len)) {\n\t\t\t// console.log(that.dstate.pending_buf.length + \", \" + that.dstate.pending_out + \", \" + that.next_out.length + \", \" +\n\t\t\t// that.next_out_index + \", \" + len);\n\t\t\t// console.log(\"avail_out=\" + that.avail_out);\n\t\t\t// }\n\n\t\t\tthat.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);\n\n\t\t\tthat.next_out_index += len;\n\t\t\tthat.dstate.pending_out += len;\n\t\t\tthat.total_out += len;\n\t\t\tthat.avail_out -= len;\n\t\t\tthat.dstate.pending -= len;\n\t\t\tif (that.dstate.pending === 0) {\n\t\t\t\tthat.dstate.pending_out = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Deflater\n\n\tfunction Deflater(options) {\n\t\tvar that = this;\n\t\tvar z = new ZStream();\n\t\tvar bufsize = 512;\n\t\tvar flush = Z_NO_FLUSH;\n\t\tvar buf = new Uint8Array(bufsize);\n\t\tvar level = options ? options.level : Z_DEFAULT_COMPRESSION;\n\t\tif (typeof level == \"undefined\")\n\t\t\tlevel = Z_DEFAULT_COMPRESSION;\n\t\tz.deflateInit(level);\n\t\tz.next_out = buf;\n\n\t\tthat.append = function(data, onprogress) {\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\n\t\t\tif (!data.length)\n\t\t\t\treturn;\n\t\t\tz.next_in_index = 0;\n\t\t\tz.next_in = data;\n\t\t\tz.avail_in = data.length;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\terr = z.deflate(flush);\n\t\t\t\tif (err != Z_OK)\n\t\t\t\t\tthrow new Error(\"deflating: \" + z.msg);\n\t\t\t\tif (z.next_out_index)\n\t\t\t\t\tif (z.next_out_index == bufsize)\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n\t\t\t\t\tonprogress(z.next_in_index);\n\t\t\t\t\tlastIndex = z.next_in_index;\n\t\t\t\t}\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t\tthat.flush = function() {\n\t\t\tvar err, buffers = [], bufferIndex = 0, bufferSize = 0, array;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\terr = z.deflate(Z_FINISH);\n\t\t\t\tif (err != Z_STREAM_END && err != Z_OK)\n\t\t\t\t\tthrow new Error(\"deflating: \" + z.msg);\n\t\t\t\tif (bufsize - z.avail_out > 0)\n\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tz.deflateEnd();\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t}\n\n\t// 'zip' may not be defined in z-worker and some tests\n\tvar env = global.zip || global;\n\tenv.Deflater = env._jzlib_Deflater = Deflater;\n})(this);\n")],
  inflater: [zWorker, createUrl("/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n\n(function(global) {\n\t\"use strict\";\n\n\t// Global\n\tvar MAX_BITS = 15;\n\n\tvar Z_OK = 0;\n\tvar Z_STREAM_END = 1;\n\tvar Z_NEED_DICT = 2;\n\tvar Z_STREAM_ERROR = -2;\n\tvar Z_DATA_ERROR = -3;\n\tvar Z_MEM_ERROR = -4;\n\tvar Z_BUF_ERROR = -5;\n\n\tvar inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\n\t\t\t0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\n\n\tvar MANY = 1440;\n\n\t// JZlib version : \"1.0.2\"\n\tvar Z_NO_FLUSH = 0;\n\tvar Z_FINISH = 4;\n\n\t// InfTree\n\tvar fixed_bl = 9;\n\tvar fixed_bd = 5;\n\n\tvar fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\n\t\t\t0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\n\t\t\t0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\n\t\t\t0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\n\t\t\t0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\n\t\t\t35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\n\t\t\t26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\n\t\t\t7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\n\t\t\t8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\n\t\t\t8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\n\t\t\t0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\n\t\t\t81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\n\t\t\t0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\n\t\t\t84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\n\t\t\t0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\n\t\t\t80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\n\t\t\t0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\n\t\t\t0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\n\t\t\t0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\n\t\t\t193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\n\t\t\t120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\n\t\t\t227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\n\t\t\t92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\n\t\t\t249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\n\t\t\t130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\n\t\t\t181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\n\t\t\t102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\n\t\t\t221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\n\t\t\t8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\n\t\t\t147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\n\t\t\t85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\n\t\t\t235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\n\t\t\t141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\n\t\t\t167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\n\t\t\t107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\n\t\t\t207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\n\t\t\t127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\n\tvar fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\n\t\t\t8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\n\t\t\t24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\n\n\t// Tables for deflate from PKZIP's appnote.txt.\n\tvar cplens = [ // Copy lengths for literal codes 257..285\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\n\n\t// see note #13 above about 258\n\tvar cplext = [ // Extra bits for literal codes 257..285\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n\t];\n\n\tvar cpdist = [ // Copy offsets for distance codes 0..29\n\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\n\n\tvar cpdext = [ // Extra bits for distance codes\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\n\n\t// If BMAX needs to be larger than 16, then h and x[] should be uLong.\n\tvar BMAX = 15; // maximum bit length of any code\n\n\tfunction InfTree() {\n\t\tvar that = this;\n\n\t\tvar hn; // hufts used in space\n\t\tvar v; // work area for huft_build\n\t\tvar c; // bit length count table\n\t\tvar r; // table entry for structure assignment\n\t\tvar u; // table stack\n\t\tvar x; // bit offsets, then code stack\n\n\t\tfunction huft_build(b, // code lengths in bits (all assumed <=\n\t\t// BMAX)\n\t\tbindex, n, // number of codes (assumed <= 288)\n\t\ts, // number of simple-valued codes (0..s-1)\n\t\td, // list of base values for non-simple codes\n\t\te, // list of extra bits for non-simple codes\n\t\tt, // result: starting table\n\t\tm, // maximum lookup bits, returns actual\n\t\thp,// space for trees\n\t\thn,// hufts used in space\n\t\tv // working area: values in order of bit length\n\t\t) {\n\t\t\t// Given a list of code lengths and a maximum table size, make a set of\n\t\t\t// tables to decode that set of codes. Return Z_OK on success,\n\t\t\t// Z_BUF_ERROR\n\t\t\t// if the given code set is incomplete (the tables are still built in\n\t\t\t// this\n\t\t\t// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\n\t\t\t// of\n\t\t\t// lengths), or Z_MEM_ERROR if not enough memory.\n\n\t\t\tvar a; // counter for codes of length k\n\t\t\tvar f; // i repeats in table every f entries\n\t\t\tvar g; // maximum code length\n\t\t\tvar h; // table level\n\t\t\tvar i; // counter, current code\n\t\t\tvar j; // counter\n\t\t\tvar k; // number of bits in current code\n\t\t\tvar l; // bits per table (returned in m)\n\t\t\tvar mask; // (1 << w) - 1, to avoid cc -O bug on HP\n\t\t\tvar p; // pointer into c[], b[], or v[]\n\t\t\tvar q; // points to current table\n\t\t\tvar w; // bits before this table == (l * h)\n\t\t\tvar xp; // pointer into x\n\t\t\tvar y; // number of dummy codes added\n\t\t\tvar z; // number of entries in current table\n\n\t\t\t// Generate counts for each bit length\n\n\t\t\tp = 0;\n\t\t\ti = n;\n\t\t\tdo {\n\t\t\t\tc[b[bindex + p]]++;\n\t\t\t\tp++;\n\t\t\t\ti--; // assume all entries <= BMAX\n\t\t\t} while (i !== 0);\n\n\t\t\tif (c[0] == n) { // null input--all zero length codes\n\t\t\t\tt[0] = -1;\n\t\t\t\tm[0] = 0;\n\t\t\t\treturn Z_OK;\n\t\t\t}\n\n\t\t\t// Find minimum and maximum length, bound *m by those\n\t\t\tl = m[0];\n\t\t\tfor (j = 1; j <= BMAX; j++)\n\t\t\t\tif (c[j] !== 0)\n\t\t\t\t\tbreak;\n\t\t\tk = j; // minimum code length\n\t\t\tif (l < j) {\n\t\t\t\tl = j;\n\t\t\t}\n\t\t\tfor (i = BMAX; i !== 0; i--) {\n\t\t\t\tif (c[i] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg = i; // maximum code length\n\t\t\tif (l > i) {\n\t\t\t\tl = i;\n\t\t\t}\n\t\t\tm[0] = l;\n\n\t\t\t// Adjust last length count to fill out codes, if needed\n\t\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\t\t\tif ((y -= c[j]) < 0) {\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((y -= c[i]) < 0) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tc[i] += y;\n\n\t\t\t// Generate starting offsets into the value table for each length\n\t\t\tx[1] = j = 0;\n\t\t\tp = 1;\n\t\t\txp = 2;\n\t\t\twhile (--i !== 0) { // note that i == g from above\n\t\t\t\tx[xp] = (j += c[p]);\n\t\t\t\txp++;\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\t// Make a table of values in order of bit lengths\n\t\t\ti = 0;\n\t\t\tp = 0;\n\t\t\tdo {\n\t\t\t\tif ((j = b[bindex + p]) !== 0) {\n\t\t\t\t\tv[x[j]++] = i;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t} while (++i < n);\n\t\t\tn = x[g]; // set n to length of v\n\n\t\t\t// Generate the Huffman codes and for each, make the table entries\n\t\t\tx[0] = i = 0; // first Huffman code is zero\n\t\t\tp = 0; // grab values in bit order\n\t\t\th = -1; // no tables yet--level -1\n\t\t\tw = -l; // bits decoded == (l * h)\n\t\t\tu[0] = 0; // just to keep compilers happy\n\t\t\tq = 0; // ditto\n\t\t\tz = 0; // ditto\n\n\t\t\t// go through the bit lengths (k already is bits in shortest code)\n\t\t\tfor (; k <= g; k++) {\n\t\t\t\ta = c[k];\n\t\t\t\twhile (a-- !== 0) {\n\t\t\t\t\t// here i is the Huffman code of length k bits for value *p\n\t\t\t\t\t// make tables up to required level\n\t\t\t\t\twhile (k > w + l) {\n\t\t\t\t\t\th++;\n\t\t\t\t\t\tw += l; // previous table always l bits\n\t\t\t\t\t\t// compute minimum size table less than or equal to l bits\n\t\t\t\t\t\tz = g - w;\n\t\t\t\t\t\tz = (z > l) ? l : z; // table size upper limit\n\t\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n\t\t\t\t\t\t\t// too few codes for\n\t\t\t\t\t\t\t// k-w bit table\n\t\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\n\t\t\t\t\t\t\txp = k;\n\t\t\t\t\t\t\tif (j < z) {\n\t\t\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\n\t\t\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp])\n\t\t\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\n\t\t\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = 1 << j; // table entries for j-bit table\n\n\t\t\t\t\t\t// allocate new table\n\t\t\t\t\t\tif (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\n\t\t\t\t\t\t\treturn Z_DATA_ERROR; // overflow of MANY\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu[h] = q = /* hp+ */hn[0]; // DEBUG\n\t\t\t\t\t\thn[0] += z;\n\n\t\t\t\t\t\t// connect to last table, if there is one\n\t\t\t\t\t\tif (h !== 0) {\n\t\t\t\t\t\t\tx[h] = i; // save pattern for backing up\n\t\t\t\t\t\t\tr[0] = /* (byte) */j; // bits in this table\n\t\t\t\t\t\t\tr[1] = /* (byte) */l; // bits to dump before this table\n\t\t\t\t\t\t\tj = i >>> (w - l);\n\t\t\t\t\t\t\tr[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\n\t\t\t\t\t\t\thp.set(r, (u[h - 1] + j) * 3);\n\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t// last\n\t\t\t\t\t\t\t// table\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt[0] = q; // first table is returned result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// set up table entry in r\n\t\t\t\t\tr[1] = /* (byte) */(k - w);\n\t\t\t\t\tif (p >= n) {\n\t\t\t\t\t\tr[0] = 128 + 64; // out of values--invalid code\n\t\t\t\t\t} else if (v[p] < s) {\n\t\t\t\t\t\tr[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\n\t\t\t\t\t\t// end-of-block\n\t\t\t\t\t\tr[2] = v[p++]; // simple code is just the value\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\n\t\t\t\t\t\t// up in lists\n\t\t\t\t\t\tr[2] = d[v[p++] - s];\n\t\t\t\t\t}\n\n\t\t\t\t\t// fill code-like entries with r\n\t\t\t\t\tf = 1 << (k - w);\n\t\t\t\t\tfor (j = i >>> w; j < z; j += f) {\n\t\t\t\t\t\thp.set(r, (q + j) * 3);\n\t\t\t\t\t}\n\n\t\t\t\t\t// backwards increment the k-bit code i\n\t\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\n\t\t\t\t\t\ti ^= j;\n\t\t\t\t\t}\n\t\t\t\t\ti ^= j;\n\n\t\t\t\t\t// backup over finished tables\n\t\t\t\t\tmask = (1 << w) - 1; // needed on HP, cc -O bug\n\t\t\t\t\twhile ((i & mask) != x[h]) {\n\t\t\t\t\t\th--; // don't need to update q\n\t\t\t\t\t\tw -= l;\n\t\t\t\t\t\tmask = (1 << w) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return Z_BUF_ERROR if we were given an incomplete table\n\t\t\treturn y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n\t\t}\n\n\t\tfunction initWorkArea(vsize) {\n\t\t\tvar i;\n\t\t\tif (!hn) {\n\t\t\t\thn = []; // []; //new Array(1);\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t\tc = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t\tr = []; // new Array(3);\n\t\t\t\tu = new Int32Array(BMAX); // new Array(BMAX);\n\t\t\t\tx = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t}\n\t\t\tif (v.length < vsize) {\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t}\n\t\t\tfor (i = 0; i < vsize; i++) {\n\t\t\t\tv[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < BMAX + 1; i++) {\n\t\t\t\tc[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tr[i] = 0;\n\t\t\t}\n\t\t\t// for(int i=0; i<BMAX; i++){u[i]=0;}\n\t\t\tu.set(c.subarray(0, BMAX), 0);\n\t\t\t// for(int i=0; i<BMAX+1; i++){x[i]=0;}\n\t\t\tx.set(c.subarray(0, BMAX + 1), 0);\n\t\t}\n\n\t\tthat.inflate_trees_bits = function(c, // 19 code lengths\n\t\tbb, // bits tree desired/actual depth\n\t\ttb, // bits tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\t\t\tinitWorkArea(19);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\n\n\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\tz.msg = \"oversubscribed dynamic bit lengths tree\";\n\t\t\t} else if (result == Z_BUF_ERROR || bb[0] === 0) {\n\t\t\t\tz.msg = \"incomplete dynamic bit lengths tree\";\n\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tthat.inflate_trees_dynamic = function(nl, // number of literal/length codes\n\t\tnd, // number of distance codes\n\t\tc, // that many (total) code lengths\n\t\tbl, // literal desired/actual bit depth\n\t\tbd, // distance desired/actual bit depth\n\t\ttl, // literal/length tree result\n\t\ttd, // distance tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\n\t\t\t// build literal/length tree\n\t\t\tinitWorkArea(288);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\n\t\t\tif (result != Z_OK || bl[0] === 0) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed literal/length tree\";\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete literal/length tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// build distance tree\n\t\t\tinitWorkArea(288);\n\t\t\tresult = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\n\n\t\t\tif (result != Z_OK || (bd[0] === 0 && nl > 257)) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = \"oversubscribed distance tree\";\n\t\t\t\t} else if (result == Z_BUF_ERROR) {\n\t\t\t\t\tz.msg = \"incomplete distance tree\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = \"empty distance tree with lengths\";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn Z_OK;\n\t\t};\n\n\t}\n\n\tInfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\n\tbd, // distance desired/actual bit depth\n\ttl,// literal/length tree result\n\ttd// distance tree result\n\t) {\n\t\tbl[0] = fixed_bl;\n\t\tbd[0] = fixed_bd;\n\t\ttl[0] = fixed_tl;\n\t\ttd[0] = fixed_td;\n\t\treturn Z_OK;\n\t};\n\n\t// InfCodes\n\n\t// waiting for \"i:\"=input,\n\t// \"o:\"=output,\n\t// \"x:\"=nothing\n\tvar START = 0; // x: set up for LEN\n\tvar LEN = 1; // i: get length/literal/eob next\n\tvar LENEXT = 2; // i: getting length extra (have base)\n\tvar DIST = 3; // i: get distance next\n\tvar DISTEXT = 4;// i: getting distance extra\n\tvar COPY = 5; // o: copying bytes in window, waiting\n\t// for space\n\tvar LIT = 6; // o: got literal, waiting for output\n\t// space\n\tvar WASH = 7; // o: got eob, possibly still output\n\t// waiting\n\tvar END = 8; // x: got eob and all data flushed\n\tvar BADCODE = 9;// x: got error\n\n\tfunction InfCodes() {\n\t\tvar that = this;\n\n\t\tvar mode; // current inflate_codes mode\n\n\t\t// mode dependent information\n\t\tvar len = 0;\n\n\t\tvar tree; // pointer into tree\n\t\tvar tree_index = 0;\n\t\tvar need = 0; // bits needed\n\n\t\tvar lit = 0;\n\n\t\t// if EXT or COPY, where and how much\n\t\tvar get = 0; // bits to get for extra\n\t\tvar dist = 0; // distance back to copy from\n\n\t\tvar lbits = 0; // ltree bits decoded per branch\n\t\tvar dbits = 0; // dtree bits decoder per branch\n\t\tvar ltree; // literal/length/eob tree\n\t\tvar ltree_index = 0; // literal/length/eob tree\n\t\tvar dtree; // distance tree\n\t\tvar dtree_index = 0; // distance tree\n\n\t\t// Called with number of bytes left to write in window at least 258\n\t\t// (the maximum string length) and number of input bytes available\n\t\t// at least ten. The ten bytes are six bytes for the longest length/\n\t\t// distance pair plus four bytes for overloading the bit buffer.\n\n\t\tfunction inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\n\t\t\tvar t; // temporary pointer\n\t\t\tvar tp; // temporary pointer\n\t\t\tvar tp_index; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar ml; // mask for literal/length tree\n\t\t\tvar md; // mask for distance tree\n\t\t\tvar c; // bytes to copy\n\t\t\tvar d; // distance back to copy from\n\t\t\tvar r; // copy source pointer\n\n\t\t\tvar tp_index_t_3; // (tp_index+t)*3\n\n\t\t\t// load input, output, bit values\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// initialize masks\n\t\t\tml = inflate_mask[bl];\n\t\t\tmd = inflate_mask[bd];\n\n\t\t\t// do until not enough input or output space for fast loop\n\t\t\tdo { // assume called with m >= 258 && n >= 10\n\t\t\t\t// get literal/length code\n\t\t\t\twhile (k < (20)) { // max bits for literal/length code\n\t\t\t\t\tn--;\n\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\tk += 8;\n\t\t\t\t}\n\n\t\t\t\tt = b & ml;\n\t\t\t\ttp = tl;\n\t\t\t\ttp_index = tl_index;\n\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\tm--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdo {\n\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\tc = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\n\n\t\t\t\t\t\tb >>= e;\n\t\t\t\t\t\tk -= e;\n\n\t\t\t\t\t\t// decode distance base of block to copy\n\t\t\t\t\t\twhile (k < (15)) { // max bits for distance code\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt = b & md;\n\t\t\t\t\t\ttp = td;\n\t\t\t\t\t\ttp_index = td_index;\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\te = tp[tp_index_t_3];\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\t\t\t// get extra bits to add to distance base\n\t\t\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\t\t\twhile (k < (e)) { // get extra bits (up to 13)\n\t\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\td = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n\t\t\t\t\t\t\t\tb >>= (e);\n\t\t\t\t\t\t\t\tk -= (e);\n\n\t\t\t\t\t\t\t\t// do the copy\n\t\t\t\t\t\t\t\tm -= c;\n\t\t\t\t\t\t\t\tif (q >= d) { // offset before dest\n\t\t\t\t\t\t\t\t\t// just copy\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tif (q - r > 0 && 2 > (q - r)) {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // minimum\n\t\t\t\t\t\t\t\t\t\t// count is\n\t\t\t\t\t\t\t\t\t\t// three,\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // so unroll\n\t\t\t\t\t\t\t\t\t\t// loop a\n\t\t\t\t\t\t\t\t\t\t// little\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + 2), q);\n\t\t\t\t\t\t\t\t\t\tq += 2;\n\t\t\t\t\t\t\t\t\t\tr += 2;\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else { // else offset after destination\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tr += s.end; // force pointer in window\n\t\t\t\t\t\t\t\t\t} while (r < 0); // covers invalid distances\n\t\t\t\t\t\t\t\t\te = s.end - r;\n\t\t\t\t\t\t\t\t\tif (c > e) { // if source crosses,\n\t\t\t\t\t\t\t\t\t\tc -= e; // wrapped copy\n\t\t\t\t\t\t\t\t\t\tif (q - r > 0 && e > (q - r)) {\n\t\t\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t\t\t} while (--e !== 0);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + e), q);\n\t\t\t\t\t\t\t\t\t\t\tq += e;\n\t\t\t\t\t\t\t\t\t\t\tr += e;\n\t\t\t\t\t\t\t\t\t\t\te = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tr = 0; // copy rest from start of window\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// copy all or what's left\n\t\t\t\t\t\t\t\tif (q - r > 0 && c > (q - r)) {\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t} while (--c !== 0);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + c), q);\n\t\t\t\t\t\t\t\t\tq += c;\n\t\t\t\t\t\t\t\t\tr += c;\n\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if ((e & 64) === 0) {\n\t\t\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\t\t\te = tp[tp_index_t_3];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tz.msg = \"invalid distance code\";\n\n\t\t\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\t\t\tn += c;\n\t\t\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (true);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((e & 64) === 0) {\n\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\tm--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ((e & 32) !== 0) {\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz.msg = \"invalid literal/length code\";\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} while (true);\n\t\t\t} while (m >= 258 && n >= 10);\n\n\t\t\t// not enough input or output--restore pointers and return\n\t\t\tc = z.avail_in - n;\n\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\tn += c;\n\t\t\tp -= c;\n\t\t\tk -= c << 3;\n\n\t\t\ts.bitb = b;\n\t\t\ts.bitk = k;\n\t\t\tz.avail_in = n;\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\ts.write = q;\n\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.init = function(bl, bd, tl, tl_index, td, td_index) {\n\t\t\tmode = START;\n\t\t\tlbits = /* (byte) */bl;\n\t\t\tdbits = /* (byte) */bd;\n\t\t\tltree = tl;\n\t\t\tltree_index = tl_index;\n\t\t\tdtree = td;\n\t\t\tdtree_index = td_index;\n\t\t\ttree = null;\n\t\t};\n\n\t\tthat.proc = function(s, z, r) {\n\t\t\tvar j; // temporary storage\n\t\t\tvar tindex; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b = 0; // bit buffer\n\t\t\tvar k = 0; // bits in bit buffer\n\t\t\tvar p = 0; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar f; // pointer to copy strings from\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// process input and output based on current state\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n\t\t\t\tcase START: // x: set up for LEN\n\t\t\t\t\tif (m >= 258 && n >= 10) {\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\tr = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\n\n\t\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\t\tb = s.bitb;\n\t\t\t\t\t\tk = s.bitk;\n\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\tif (r != Z_OK) {\n\t\t\t\t\t\t\tmode = r == Z_STREAM_END ? WASH : BADCODE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tneed = lbits;\n\t\t\t\t\ttree = ltree;\n\t\t\t\t\ttree_index = ltree_index;\n\n\t\t\t\t\tmode = LEN;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase LEN: // i: get length/literal/eob next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>>= (tree[tindex + 1]);\n\t\t\t\t\tk -= (tree[tindex + 1]);\n\n\t\t\t\t\te = tree[tindex];\n\n\t\t\t\t\tif (e === 0) { // literal\n\t\t\t\t\t\tlit = tree[tindex + 2];\n\t\t\t\t\t\tmode = LIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 16) !== 0) { // length\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tlen = tree[tindex + 2];\n\t\t\t\t\t\tmode = LENEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 32) !== 0) { // end of block\n\t\t\t\t\t\tmode = WASH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = \"invalid literal/length code\";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase LENEXT: // i: getting length extra (have base)\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tneed = dbits;\n\t\t\t\t\ttree = dtree;\n\t\t\t\t\ttree_index = dtree_index;\n\t\t\t\t\tmode = DIST;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DIST: // i: get distance next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>= tree[tindex + 1];\n\t\t\t\t\tk -= tree[tindex + 1];\n\n\t\t\t\t\te = (tree[tindex]);\n\t\t\t\t\tif ((e & 16) !== 0) { // distance\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tdist = tree[tindex + 2];\n\t\t\t\t\t\tmode = DISTEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = \"invalid distance code\";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase DISTEXT: // i: getting distance extra\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tdist += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tmode = COPY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase COPY: // o: copying bytes in window, waiting for space\n\t\t\t\t\tf = q - dist;\n\t\t\t\t\twhile (f < 0) { // modulo window size-\"while\" instead\n\t\t\t\t\t\tf += s.end; // of \"if\" handles invalid distances\n\t\t\t\t\t}\n\t\t\t\t\twhile (len !== 0) {\n\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.window[q++] = s.window[f++];\n\t\t\t\t\t\tm--;\n\n\t\t\t\t\t\tif (f == s.end)\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LIT: // o: got literal, waiting for output space\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\ts.window[q++] = /* (byte) */lit;\n\t\t\t\t\tm--;\n\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WASH: // o: got eob, possibly more output\n\t\t\t\t\tif (k > 7) { // return unused byte, if any\n\t\t\t\t\t\tk -= 8;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t\tp--; // can always return one\n\t\t\t\t\t}\n\n\t\t\t\t\ts.write = q;\n\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\tq = s.write;\n\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\tif (s.read != s.write) {\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = END;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase END:\n\t\t\t\t\tr = Z_STREAM_END;\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase BADCODE: // x: got error\n\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function() {\n\t\t\t// ZFREE(z, c);\n\t\t};\n\n\t}\n\n\t// InfBlocks\n\n\t// Table for deflate from PKZIP's appnote.txt.\n\tvar border = [ // Order of the bit length code lengths\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\tvar TYPE = 0; // get type bits (3, including end bit)\n\tvar LENS = 1; // get lengths for stored\n\tvar STORED = 2;// processing stored block\n\tvar TABLE = 3; // get table lengths\n\tvar BTREE = 4; // get bit lengths tree for a dynamic\n\t// block\n\tvar DTREE = 5; // get length, distance trees for a\n\t// dynamic block\n\tvar CODES = 6; // processing fixed or dynamic block\n\tvar DRY = 7; // output remaining window bytes\n\tvar DONELOCKS = 8; // finished last block, done\n\tvar BADBLOCKS = 9; // ot a data error--stuck here\n\n\tfunction InfBlocks(z, w) {\n\t\tvar that = this;\n\n\t\tvar mode = TYPE; // current inflate_block mode\n\n\t\tvar left = 0; // if STORED, bytes left to copy\n\n\t\tvar table = 0; // table lengths (14 bits)\n\t\tvar index = 0; // index into blens (or border)\n\t\tvar blens; // bit lengths of codes\n\t\tvar bb = [ 0 ]; // bit length tree depth\n\t\tvar tb = [ 0 ]; // bit length decoding tree\n\n\t\tvar codes = new InfCodes(); // if CODES, current state\n\n\t\tvar last = 0; // true if this block is the last block\n\n\t\tvar hufts = new Int32Array(MANY * 3); // single malloc for tree space\n\t\tvar check = 0; // check on output\n\t\tvar inftree = new InfTree();\n\n\t\tthat.bitk = 0; // bits in bit buffer\n\t\tthat.bitb = 0; // bit buffer\n\t\tthat.window = new Uint8Array(w); // sliding window\n\t\tthat.end = w; // one byte after sliding window\n\t\tthat.read = 0; // window read pointer\n\t\tthat.write = 0; // window write pointer\n\n\t\tthat.reset = function(z, c) {\n\t\t\tif (c)\n\t\t\t\tc[0] = check;\n\t\t\t// if (mode == BTREE || mode == DTREE) {\n\t\t\t// }\n\t\t\tif (mode == CODES) {\n\t\t\t\tcodes.free(z);\n\t\t\t}\n\t\t\tmode = TYPE;\n\t\t\tthat.bitk = 0;\n\t\t\tthat.bitb = 0;\n\t\t\tthat.read = that.write = 0;\n\t\t};\n\n\t\tthat.reset(z, null);\n\n\t\t// copy as much as possible from the sliding window to the output area\n\t\tthat.inflate_flush = function(z, r) {\n\t\t\tvar n;\n\t\t\tvar p;\n\t\t\tvar q;\n\n\t\t\t// local copies of source and destination pointers\n\t\t\tp = z.next_out_index;\n\t\t\tq = that.read;\n\n\t\t\t// compute number of bytes to copy as far as end of window\n\t\t\tn = /* (int) */((q <= that.write ? that.write : that.end) - q);\n\t\t\tif (n > z.avail_out)\n\t\t\t\tn = z.avail_out;\n\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\tr = Z_OK;\n\n\t\t\t// update counters\n\t\t\tz.avail_out -= n;\n\t\t\tz.total_out += n;\n\n\t\t\t// copy as far as end of window\n\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\tp += n;\n\t\t\tq += n;\n\n\t\t\t// see if more to copy at beginning of window\n\t\t\tif (q == that.end) {\n\t\t\t\t// wrap pointers\n\t\t\t\tq = 0;\n\t\t\t\tif (that.write == that.end)\n\t\t\t\t\tthat.write = 0;\n\n\t\t\t\t// compute bytes to copy\n\t\t\t\tn = that.write - q;\n\t\t\t\tif (n > z.avail_out)\n\t\t\t\t\tn = z.avail_out;\n\t\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t// update counters\n\t\t\t\tz.avail_out -= n;\n\t\t\t\tz.total_out += n;\n\n\t\t\t\t// copy\n\t\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\t\tp += n;\n\t\t\t\tq += n;\n\t\t\t}\n\n\t\t\t// update pointers\n\t\t\tz.next_out_index = p;\n\t\t\tthat.read = q;\n\n\t\t\t// done\n\t\t\treturn r;\n\t\t};\n\n\t\tthat.proc = function(z, r) {\n\t\t\tvar t; // temporary storage\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\n\t\t\tvar i;\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\t// {\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = that.bitb;\n\t\t\tk = that.bitk;\n\t\t\t// }\n\t\t\t// {\n\t\t\tq = that.write;\n\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t// }\n\n\t\t\t// process input based on current state\n\t\t\t// DEBUG dtree\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase TYPE:\n\n\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\t\t\t\t\tt = /* (int) */(b & 7);\n\t\t\t\t\tlast = t & 1;\n\n\t\t\t\t\tswitch (t >>> 1) {\n\t\t\t\t\tcase 0: // stored\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tt = k & 7; // go to byte boundary\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = LENS; // get length of stored block\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: // fixed\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tvar bl = []; // new Array(1);\n\t\t\t\t\t\tvar bd = []; // new Array(1);\n\t\t\t\t\t\tvar tl = [ [] ]; // new Array(1);\n\t\t\t\t\t\tvar td = [ [] ]; // new Array(1);\n\n\t\t\t\t\t\tInfTree.inflate_trees_fixed(bl, bd, tl, td);\n\t\t\t\t\t\tcodes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = CODES;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: // dynamic\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = TABLE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: // illegal\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"invalid block type\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LENS:\n\n\t\t\t\t\twhile (k < (32)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"invalid stored block lengths\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tleft = (b & 0xffff);\n\t\t\t\t\tb = k = 0; // dump bits\n\t\t\t\t\tmode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STORED:\n\t\t\t\t\tif (n === 0) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = that.write;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\tt = left;\n\t\t\t\t\tif (t > n)\n\t\t\t\t\t\tt = n;\n\t\t\t\t\tif (t > m)\n\t\t\t\t\t\tt = m;\n\t\t\t\t\tthat.window.set(z.read_buf(p, t), q);\n\t\t\t\t\tp += t;\n\t\t\t\t\tn -= t;\n\t\t\t\t\tq += t;\n\t\t\t\t\tm -= t;\n\t\t\t\t\tif ((left -= t) !== 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmode = last !== 0 ? DRY : TYPE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TABLE:\n\n\t\t\t\t\twhile (k < (14)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttable = t = (b & 0x3fff);\n\t\t\t\t\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = \"too many length or distance symbols\";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\t\t\t\t\tif (!blens || blens.length < t) {\n\t\t\t\t\t\tblens = []; // new Array(t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < t; i++) {\n\t\t\t\t\t\t\tblens[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// {\n\t\t\t\t\tb >>>= (14);\n\t\t\t\t\tk -= (14);\n\t\t\t\t\t// }\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = BTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase BTREE:\n\t\t\t\t\twhile (index < 4 + (table >>> 10)) {\n\t\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tblens[border[index++]] = b & 7;\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (index < 19) {\n\t\t\t\t\t\tblens[border[index++]] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbb[0] = 7;\n\t\t\t\t\tt = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tr = t;\n\t\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = DTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DTREE:\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tt = table;\n\t\t\t\t\t\tif (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar j, c;\n\n\t\t\t\t\t\tt = bb[0];\n\n\t\t\t\t\t\twhile (k < (t)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if (tb[0] == -1) {\n\t\t\t\t\t\t// System.err.println(\"null...\");\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tt = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\n\t\t\t\t\t\tc = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n\t\t\t\t\t\tif (c < 16) {\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t\tblens[index++] = c;\n\t\t\t\t\t\t} else { // c == 16..18\n\t\t\t\t\t\t\ti = c == 18 ? 7 : c - 14;\n\t\t\t\t\t\t\tj = c == 18 ? 11 : 3;\n\n\t\t\t\t\t\t\twhile (k < (t + i)) {\n\t\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\n\t\t\t\t\t\t\tj += (b & inflate_mask[i]);\n\n\t\t\t\t\t\t\tb >>>= (i);\n\t\t\t\t\t\t\tk -= (i);\n\n\t\t\t\t\t\t\ti = index;\n\t\t\t\t\t\t\tt = table;\n\t\t\t\t\t\t\tif (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\n\t\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t\t\tz.msg = \"invalid bit length repeat\";\n\t\t\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tc = c == 16 ? blens[i - 1] : 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tblens[i++] = c;\n\t\t\t\t\t\t\t} while (--j !== 0);\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttb[0] = -1;\n\t\t\t\t\t// {\n\t\t\t\t\tvar bl_ = []; // new Array(1);\n\t\t\t\t\tvar bd_ = []; // new Array(1);\n\t\t\t\t\tvar tl_ = []; // new Array(1);\n\t\t\t\t\tvar td_ = []; // new Array(1);\n\t\t\t\t\tbl_[0] = 9; // must be <= 9 for lookahead assumptions\n\t\t\t\t\tbd_[0] = 6; // must be <= 9 for lookahead assumptions\n\n\t\t\t\t\tt = table;\n\t\t\t\t\tt = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\n\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tif (t == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr = t;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tcodes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\n\t\t\t\t\t// }\n\t\t\t\t\tmode = CODES;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase CODES:\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\n\t\t\t\t\tif ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\t\t\t\t\tcodes.free(z);\n\n\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\tb = that.bitb;\n\t\t\t\t\tk = that.bitk;\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\n\t\t\t\t\tif (last === 0) {\n\t\t\t\t\t\tmode = TYPE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = DRY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DRY:\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\tif (that.read != that.write) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = DONELOCKS;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONELOCKS:\n\t\t\t\t\tr = Z_STREAM_END;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\tcase BADBLOCKS:\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function(z) {\n\t\t\tthat.reset(z, null);\n\t\t\tthat.window = null;\n\t\t\thufts = null;\n\t\t\t// ZFREE(z, s);\n\t\t};\n\n\t\tthat.set_dictionary = function(d, start, n) {\n\t\t\tthat.window.set(d.subarray(start, start + n), 0);\n\t\t\tthat.read = that.write = n;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n\t\tthat.sync_point = function() {\n\t\t\treturn mode == LENS ? 1 : 0;\n\t\t};\n\n\t}\n\n\t// Inflate\n\n\t// preset dictionary flag in zlib header\n\tvar PRESET_DICT = 0x20;\n\n\tvar Z_DEFLATED = 8;\n\n\tvar METHOD = 0; // waiting for method byte\n\tvar FLAG = 1; // waiting for flag byte\n\tvar DICT4 = 2; // four dictionary check bytes to go\n\tvar DICT3 = 3; // three dictionary check bytes to go\n\tvar DICT2 = 4; // two dictionary check bytes to go\n\tvar DICT1 = 5; // one dictionary check byte to go\n\tvar DICT0 = 6; // waiting for inflateSetDictionary\n\tvar BLOCKS = 7; // decompressing blocks\n\tvar DONE = 12; // finished check, done\n\tvar BAD = 13; // got an error--stay here\n\n\tvar mark = [ 0, 0, 0xff, 0xff ];\n\n\tfunction Inflate() {\n\t\tvar that = this;\n\n\t\tthat.mode = 0; // current inflate mode\n\n\t\t// mode dependent information\n\t\tthat.method = 0; // if FLAGS, method byte\n\n\t\t// if CHECK, check values to compare\n\t\tthat.was = [ 0 ]; // new Array(1); // computed check value\n\t\tthat.need = 0; // stream check value\n\n\t\t// if BAD, inflateSync's marker bytes count\n\t\tthat.marker = 0;\n\n\t\t// mode independent information\n\t\tthat.wbits = 0; // log2(window size) (8..15, defaults to 15)\n\n\t\t// this.blocks; // current inflate_blocks state\n\n\t\tfunction inflateReset(z) {\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tz.total_in = z.total_out = 0;\n\t\t\tz.msg = null;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\tz.istate.blocks.reset(z, null);\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.inflateEnd = function(z) {\n\t\t\tif (that.blocks)\n\t\t\t\tthat.blocks.free(z);\n\t\t\tthat.blocks = null;\n\t\t\t// ZFREE(z, z->state);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateInit = function(z, w) {\n\t\t\tz.msg = null;\n\t\t\tthat.blocks = null;\n\n\t\t\t// set window size\n\t\t\tif (w < 8 || w > 15) {\n\t\t\t\tthat.inflateEnd(z);\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\tthat.wbits = w;\n\n\t\t\tz.istate.blocks = new InfBlocks(z, 1 << w);\n\n\t\t\t// reset state\n\t\t\tinflateReset(z);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflate = function(z, f) {\n\t\t\tvar r;\n\t\t\tvar b;\n\n\t\t\tif (!z || !z.istate || !z.next_in)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tf = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n\t\t\tr = Z_BUF_ERROR;\n\t\t\twhile (true) {\n\t\t\t\t// System.out.println(\"mode: \"+z.istate.mode);\n\t\t\t\tswitch (z.istate.mode) {\n\t\t\t\tcase METHOD:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tif (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"unknown compression method\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"invalid window size\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = FLAG;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase FLAG:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tb = (z.read_byte(z.next_in_index++)) & 0xff;\n\n\t\t\t\t\tif ((((z.istate.method << 8) + b) % 31) !== 0) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = \"incorrect header check\";\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((b & PRESET_DICT) === 0) {\n\t\t\t\t\t\tz.istate.mode = BLOCKS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = DICT4;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT4:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\n\t\t\t\t\tz.istate.mode = DICT3;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT3:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\n\t\t\t\t\tz.istate.mode = DICT2;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT2:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\n\t\t\t\t\tz.istate.mode = DICT1;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT1:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\n\t\t\t\t\tz.istate.mode = DICT0;\n\t\t\t\t\treturn Z_NEED_DICT;\n\t\t\t\tcase DICT0:\n\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\tz.msg = \"need dictionary\";\n\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\tcase BLOCKS:\n\n\t\t\t\t\tr = z.istate.blocks.proc(z, r);\n\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r == Z_OK) {\n\t\t\t\t\t\tr = f;\n\t\t\t\t\t}\n\t\t\t\t\tif (r != Z_STREAM_END) {\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t\tr = f;\n\t\t\t\t\tz.istate.blocks.reset(z, z.istate.was);\n\t\t\t\t\tz.istate.mode = DONE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONE:\n\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\tcase BAD:\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.inflateSetDictionary = function(z, dictionary, dictLength) {\n\t\t\tvar index = 0;\n\t\t\tvar length = dictLength;\n\t\t\tif (!z || !z.istate || z.istate.mode != DICT0)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tif (length >= (1 << z.istate.wbits)) {\n\t\t\t\tlength = (1 << z.istate.wbits) - 1;\n\t\t\t\tindex = dictLength - length;\n\t\t\t}\n\t\t\tz.istate.blocks.set_dictionary(dictionary, index, length);\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateSync = function(z) {\n\t\t\tvar n; // number of bytes to look at\n\t\t\tvar p; // pointer to bytes\n\t\t\tvar m; // number of marker bytes found in a row\n\t\t\tvar r, w; // temporaries to save total_in and total_out\n\n\t\t\t// set up\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tif (z.istate.mode != BAD) {\n\t\t\t\tz.istate.mode = BAD;\n\t\t\t\tz.istate.marker = 0;\n\t\t\t}\n\t\t\tif ((n = z.avail_in) === 0)\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\tp = z.next_in_index;\n\t\t\tm = z.istate.marker;\n\n\t\t\t// search\n\t\t\twhile (n !== 0 && m < 4) {\n\t\t\t\tif (z.read_byte(p) == mark[m]) {\n\t\t\t\t\tm++;\n\t\t\t\t} else if (z.read_byte(p) !== 0) {\n\t\t\t\t\tm = 0;\n\t\t\t\t} else {\n\t\t\t\t\tm = 4 - m;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tn--;\n\t\t\t}\n\n\t\t\t// restore\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\tz.avail_in = n;\n\t\t\tz.istate.marker = m;\n\n\t\t\t// return no joy or set up to restart on a new block\n\t\t\tif (m != 4) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tr = z.total_in;\n\t\t\tw = z.total_out;\n\t\t\tinflateReset(z);\n\t\t\tz.total_in = r;\n\t\t\tz.total_out = w;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n\t\t// implementation to provide an additional safety check. PPP uses\n\t\t// Z_SYNC_FLUSH\n\t\t// but removes the length bytes of the resulting empty stored block. When\n\t\t// decompressing, PPP checks that at the end of input packet, inflate is\n\t\t// waiting for these length bytes.\n\t\tthat.inflateSyncPoint = function(z) {\n\t\t\tif (!z || !z.istate || !z.istate.blocks)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn z.istate.blocks.sync_point();\n\t\t};\n\t}\n\n\t// ZStream\n\n\tfunction ZStream() {\n\t}\n\n\tZStream.prototype = {\n\t\tinflateInit : function(bits) {\n\t\t\tvar that = this;\n\t\t\tthat.istate = new Inflate();\n\t\t\tif (!bits)\n\t\t\t\tbits = MAX_BITS;\n\t\t\treturn that.istate.inflateInit(that, bits);\n\t\t},\n\n\t\tinflate : function(f) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflate(that, f);\n\t\t},\n\n\t\tinflateEnd : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tvar ret = that.istate.inflateEnd(that);\n\t\t\tthat.istate = null;\n\t\t\treturn ret;\n\t\t},\n\n\t\tinflateSync : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSync(that);\n\t\t},\n\t\tinflateSetDictionary : function(dictionary, dictLength) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSetDictionary(that, dictionary, dictLength);\n\t\t},\n\t\tread_byte : function(start) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + 1)[0];\n\t\t},\n\t\tread_buf : function(start, size) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + size);\n\t\t}\n\t};\n\n\t// Inflater\n\n\tfunction Inflater() {\n\t\tvar that = this;\n\t\tvar z = new ZStream();\n\t\tvar bufsize = 512;\n\t\tvar flush = Z_NO_FLUSH;\n\t\tvar buf = new Uint8Array(bufsize);\n\t\tvar nomoreinput = false;\n\n\t\tz.inflateInit();\n\t\tz.next_out = buf;\n\n\t\tthat.append = function(data, onprogress) {\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\n\t\t\tif (data.length === 0)\n\t\t\t\treturn;\n\t\t\tz.next_in_index = 0;\n\t\t\tz.next_in = data;\n\t\t\tz.avail_in = data.length;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\tif ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\n\t\t\t\t\tz.next_in_index = 0;\n\t\t\t\t\tnomoreinput = true;\n\t\t\t\t}\n\t\t\t\terr = z.inflate(flush);\n\t\t\t\tif (nomoreinput && (err === Z_BUF_ERROR)) {\n\t\t\t\t\tif (z.avail_in !== 0)\n\t\t\t\t\t\tthrow new Error(\"inflating: bad input\");\n\t\t\t\t} else if (err !== Z_OK && err !== Z_STREAM_END)\n\t\t\t\t\tthrow new Error(\"inflating: \" + z.msg);\n\t\t\t\tif ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))\n\t\t\t\t\tthrow new Error(\"inflating: bad input\");\n\t\t\t\tif (z.next_out_index)\n\t\t\t\t\tif (z.next_out_index === bufsize)\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n\t\t\t\t\tonprogress(z.next_in_index);\n\t\t\t\t\tlastIndex = z.next_in_index;\n\t\t\t\t}\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t\tthat.flush = function() {\n\t\t\tz.inflateEnd();\n\t\t};\n\t}\n\n\t// 'zip' may not be defined in z-worker and some tests\n\tvar env = global.zip || global;\n\tenv.Inflater = env._jzlib_Inflater = Inflater;\n})(this);\n")]
};

module.exports = zip;


},{"zip":39}],39:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*
 Copyright (c) 2013 Gildas Lormeau. All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution.

 3. The names of the authors may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
 INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

(function(obj) {
	"use strict";

	var ERR_BAD_FORMAT = "File format is not recognized.";
	var ERR_CRC = "CRC failed.";
	var ERR_ENCRYPTED = "File contains encrypted entry.";
	var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
	var ERR_READ = "Error while reading zip file.";
	var ERR_WRITE = "Error while writing zip file.";
	var ERR_WRITE_DATA = "Error while writing file data.";
	var ERR_READ_DATA = "Error while reading file data.";
	var ERR_DUPLICATED_NAME = "File already exists.";
	var CHUNK_SIZE = 512 * 1024;
	
	var TEXT_PLAIN = "text/plain";

	var appendABViewSupported;
	try {
		appendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;
	} catch (e) {
	}

	function Crc32() {
		this.crc = -1;
	}
	Crc32.prototype.append = function append(data) {
		var crc = this.crc | 0, table = this.table;
		for (var offset = 0, len = data.length | 0; offset < len; offset++)
			crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
		this.crc = crc;
	};
	Crc32.prototype.get = function get() {
		return ~this.crc;
	};
	Crc32.prototype.table = (function() {
		var i, j, t, table = []; // Uint32Array is actually slower than []
		for (i = 0; i < 256; i++) {
			t = i;
			for (j = 0; j < 8; j++)
				if (t & 1)
					t = (t >>> 1) ^ 0xEDB88320;
				else
					t = t >>> 1;
			table[i] = t;
		}
		return table;
	})();
	
	// "no-op" codec
	function NOOP() {}
	NOOP.prototype.append = function append(bytes, onprogress) {
		return bytes;
	};
	NOOP.prototype.flush = function flush() {};

	function blobSlice(blob, index, length) {
		if (index < 0 || length < 0 || index + length > blob.size)
			throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
		if (blob.slice)
			return blob.slice(index, index + length);
		else if (blob.webkitSlice)
			return blob.webkitSlice(index, index + length);
		else if (blob.mozSlice)
			return blob.mozSlice(index, index + length);
		else if (blob.msSlice)
			return blob.msSlice(index, index + length);
	}

	function getDataHelper(byteLength, bytes) {
		var dataBuffer, dataArray;
		dataBuffer = new ArrayBuffer(byteLength);
		dataArray = new Uint8Array(dataBuffer);
		if (bytes)
			dataArray.set(bytes, 0);
		return {
			buffer : dataBuffer,
			array : dataArray,
			view : new DataView(dataBuffer)
		};
	}

	// Readers
	function Reader() {
	}

	function TextReader(text) {
		var that = this, blobReader;

		function init(callback, onerror) {
			var blob = new Blob([ text ], {
				type : TEXT_PLAIN
			});
			blobReader = new BlobReader(blob);
			blobReader.init(function() {
				that.size = blobReader.size;
				callback();
			}, onerror);
		}

		function readUint8Array(index, length, callback, onerror) {
			blobReader.readUint8Array(index, length, callback, onerror);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	TextReader.prototype = new Reader();
	TextReader.prototype.constructor = TextReader;

	function Data64URIReader(dataURI) {
		var that = this, dataStart;

		function init(callback) {
			var dataEnd = dataURI.length;
			while (dataURI.charAt(dataEnd - 1) == "=")
				dataEnd--;
			dataStart = dataURI.indexOf(",") + 1;
			that.size = Math.floor((dataEnd - dataStart) * 0.75);
			callback();
		}

		function readUint8Array(index, length, callback) {
			var i, data = getDataHelper(length);
			var start = Math.floor(index / 3) * 4;
			var end = Math.ceil((index + length) / 3) * 4;
			var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
			var delta = index - Math.floor(start / 4) * 3;
			for (i = delta; i < delta + length; i++)
				data.array[i - delta] = bytes.charCodeAt(i);
			callback(data.array);
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	Data64URIReader.prototype = new Reader();
	Data64URIReader.prototype.constructor = Data64URIReader;

	function BlobReader(blob) {
		var that = this;

		function init(callback) {
			that.size = blob.size;
			callback();
		}

		function readUint8Array(index, length, callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(new Uint8Array(e.target.result));
			};
			reader.onerror = onerror;
			try {
				reader.readAsArrayBuffer(blobSlice(blob, index, length));
			} catch (e) {
				onerror(e);
			}
		}

		that.size = 0;
		that.init = init;
		that.readUint8Array = readUint8Array;
	}
	BlobReader.prototype = new Reader();
	BlobReader.prototype.constructor = BlobReader;

	// Writers

	function Writer() {
	}
	Writer.prototype.getData = function(callback) {
		callback(this.data);
	};

	function TextWriter(encoding) {
		var that = this, blob;

		function init(callback) {
			blob = new Blob([], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : TEXT_PLAIN
			});
			callback();
		}

		function getData(callback, onerror) {
			var reader = new FileReader();
			reader.onload = function(e) {
				callback(e.target.result);
			};
			reader.onerror = onerror;
			reader.readAsText(blob, encoding);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	TextWriter.prototype = new Writer();
	TextWriter.prototype.constructor = TextWriter;

	function Data64URIWriter(contentType) {
		var that = this, data = "", pending = "";

		function init(callback) {
			data += "data:" + (contentType || "") + ";base64,";
			callback();
		}

		function writeUint8Array(array, callback) {
			var i, delta = pending.length, dataString = pending;
			pending = "";
			for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
				dataString += String.fromCharCode(array[i]);
			for (; i < array.length; i++)
				pending += String.fromCharCode(array[i]);
			if (dataString.length > 2)
				data += obj.btoa(dataString);
			else
				pending = dataString;
			callback();
		}

		function getData(callback) {
			callback(data + obj.btoa(pending));
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	Data64URIWriter.prototype = new Writer();
	Data64URIWriter.prototype.constructor = Data64URIWriter;

	function BlobWriter(contentType) {
		var blob, that = this;

		function init(callback) {
			blob = new Blob([], {
				type : contentType
			});
			callback();
		}

		function writeUint8Array(array, callback) {
			blob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {
				type : contentType
			});
			callback();
		}

		function getData(callback) {
			callback(blob);
		}

		that.init = init;
		that.writeUint8Array = writeUint8Array;
		that.getData = getData;
	}
	BlobWriter.prototype = new Writer();
	BlobWriter.prototype.constructor = BlobWriter;

	/** 
	 * inflate/deflate core functions
	 * @param worker {Worker} web worker for the task.
	 * @param initialMessage {Object} initial message to be sent to the worker. should contain
	 *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.
	 *   This function may add more properties before sending.
	 */
	function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;

		function onflush() {
			worker.removeEventListener('message', onmessage, false);
			onend(outputSize, crc);
		}

		function onmessage(event) {
			var message = event.data, data = message.data, err = message.error;
			if (err) {
				err.toString = function () { return 'Error: ' + this.message; };
				onreaderror(err);
				return;
			}
			if (message.sn !== sn)
				return;
			if (typeof message.codecTime === 'number')
				worker.codecTime += message.codecTime; // should be before onflush()
			if (typeof message.crcTime === 'number')
				worker.crcTime += message.crcTime;

			switch (message.type) {
				case 'append':
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							step();
						}, onwriteerror);
					} else
						step();
					break;
				case 'flush':
					crc = message.crc;
					if (data) {
						outputSize += data.length;
						writer.writeUint8Array(data, function() {
							onflush();
						}, onwriteerror);
					} else
						onflush();
					break;
				case 'progress':
					if (onprogress)
						onprogress(index + message.loaded, size);
					break;
				case 'importScripts': //no need to handle here
				case 'newTask':
				case 'echo':
					break;
				default:
					console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
			}
		}

		function step() {
			index = chunkIndex * CHUNK_SIZE;
			// use `<=` instead of `<`, because `size` may be 0.
			if (index <= size) {
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
					if (onprogress)
						onprogress(index, size);
					var msg = index === 0 ? initialMessage : {sn : sn};
					msg.type = 'append';
					msg.data = array;
					
					// posting a message with transferables will fail on IE10
					try {
						worker.postMessage(msg, [array.buffer]);
					} catch(ex) {
						worker.postMessage(msg); // retry without transferables
					}
					chunkIndex++;
				}, onreaderror);
			} else {
				worker.postMessage({
					sn: sn,
					type: 'flush'
				});
			}
		}

		outputSize = 0;
		worker.addEventListener('message', onmessage, false);
		step();
	}

	function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
		var chunkIndex = 0, index, outputSize = 0,
			crcInput = crcType === 'input',
			crcOutput = crcType === 'output',
			crc = new Crc32();
		function step() {
			var outputData;
			index = chunkIndex * CHUNK_SIZE;
			if (index < size)
				reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
					var outputData;
					try {
						outputData = process.append(inputData, function(loaded) {
							if (onprogress)
								onprogress(index + loaded, size);
						});
					} catch (e) {
						onreaderror(e);
						return;
					}
					if (outputData) {
						outputSize += outputData.length;
						writer.writeUint8Array(outputData, function() {
							chunkIndex++;
							setTimeout(step, 1);
						}, onwriteerror);
						if (crcOutput)
							crc.append(outputData);
					} else {
						chunkIndex++;
						setTimeout(step, 1);
					}
					if (crcInput)
						crc.append(inputData);
					if (onprogress)
						onprogress(index, size);
				}, onreaderror);
			else {
				try {
					outputData = process.flush();
				} catch (e) {
					onreaderror(e);
					return;
				}
				if (outputData) {
					if (crcOutput)
						crc.append(outputData);
					outputSize += outputData.length;
					writer.writeUint8Array(outputData, function() {
						onend(outputSize, crc.get());
					}, onwriteerror);
				} else
					onend(outputSize, crc.get());
			}
		}

		step();
	}

	function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = computeCrc32 ? 'output' : 'none';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				codecClass: 'Inflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers) {
			var initialMessage = {
				sn: sn,
				options: {level: level},
				codecClass: 'Deflater',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
		var crcType = 'input';
		if (obj.zip.useWebWorkers && computeCrc32) {
			var initialMessage = {
				sn: sn,
				codecClass: 'NOOP',
				crcType: crcType,
			};
			launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
		} else
			launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
	}

	// ZipReader

	function decodeASCII(str) {
		var i, out = "", charCode, extendedASCII = [ '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB',
				'\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
				'\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1',
				'\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6',
				'\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3',
				'\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE',
				'\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE',
				'\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7',
				'\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' ' ];
		for (i = 0; i < str.length; i++) {
			charCode = str.charCodeAt(i) & 0xFF;
			if (charCode > 127)
				out += extendedASCII[charCode - 128];
			else
				out += String.fromCharCode(charCode);
		}
		return out;
	}

	function decodeUTF8(string) {
		return decodeURIComponent(escape(string));
	}

	function getString(bytes) {
		var i, str = "";
		for (i = 0; i < bytes.length; i++)
			str += String.fromCharCode(bytes[i]);
		return str;
	}

	function getDate(timeRaw) {
		var date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
		try {
			return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,
					(time & 0x001F) * 2, 0);
		} catch (e) {
		}
	}

	function readCommonHeader(entry, data, index, centralDirectory, onerror) {
		entry.version = data.view.getUint16(index, true);
		entry.bitFlag = data.view.getUint16(index + 2, true);
		entry.compressionMethod = data.view.getUint16(index + 4, true);
		entry.lastModDateRaw = data.view.getUint32(index + 6, true);
		entry.lastModDate = getDate(entry.lastModDateRaw);
		if ((entry.bitFlag & 0x01) === 0x01) {
			onerror(ERR_ENCRYPTED);
			return;
		}
		if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
			entry.crc32 = data.view.getUint32(index + 10, true);
			entry.compressedSize = data.view.getUint32(index + 14, true);
			entry.uncompressedSize = data.view.getUint32(index + 18, true);
		}
		if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
			onerror(ERR_ZIP64);
			return;
		}
		entry.filenameLength = data.view.getUint16(index + 22, true);
		entry.extraFieldLength = data.view.getUint16(index + 24, true);
	}

	function createZipReader(reader, callback, onerror) {
		var inflateSN = 0;

		function Entry() {
		}

		Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
			var that = this;

			function testCrc32(crc32) {
				var dataCrc32 = getDataHelper(4);
				dataCrc32.view.setUint32(0, crc32);
				return that.crc32 == dataCrc32.view.getUint32(0);
			}

			function getWriterData(uncompressedSize, crc32) {
				if (checkCrc32 && !testCrc32(crc32))
					onerror(ERR_CRC);
				else
					writer.getData(function(data) {
						onend(data);
					});
			}

			function onreaderror(err) {
				onerror(err || ERR_READ_DATA);
			}

			function onwriteerror(err) {
				onerror(err || ERR_WRITE_DATA);
			}

			reader.readUint8Array(that.offset, 30, function(bytes) {
				var data = getDataHelper(bytes.length, bytes), dataOffset;
				if (data.view.getUint32(0) != 0x504b0304) {
					onerror(ERR_BAD_FORMAT);
					return;
				}
				readCommonHeader(that, data, 4, false, onerror);
				dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
				writer.init(function() {
					if (that.compressionMethod === 0)
						copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
					else
						inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
				}, onwriteerror);
			}, onreaderror);
		};

		function seekEOCDR(eocdrCallback) {
			// "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
			// Zip file comment is the last part of EOCDR and has max length of 64KB,
			// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
			var EOCDR_MIN = 22;
			if (reader.size < EOCDR_MIN) {
				onerror(ERR_BAD_FORMAT);
				return;
			}
			var ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;

			// In most cases, the EOCDR is EOCDR_MIN bytes long
			doSeek(EOCDR_MIN, function() {
				// If not found, try within EOCDR_MAX bytes
				doSeek(Math.min(EOCDR_MAX, reader.size), function() {
					onerror(ERR_BAD_FORMAT);
				});
			});

			// seek last length bytes of file for EOCDR
			function doSeek(length, eocdrNotFoundCallback) {
				reader.readUint8Array(reader.size - length, length, function(bytes) {
					for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
						if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
							eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
							return;
						}
					}
					eocdrNotFoundCallback();
				}, function() {
					onerror(ERR_READ);
				});
			}
		}

		var zipReader = {
			getEntries : function(callback) {
				var worker = this._worker;
				// look for End of central directory record
				seekEOCDR(function(dataView) {
					var datalength, fileslength;
					datalength = dataView.getUint32(16, true);
					fileslength = dataView.getUint16(8, true);
					if (datalength < 0 || datalength >= reader.size) {
						onerror(ERR_BAD_FORMAT);
						return;
					}
					reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
						var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
						for (i = 0; i < fileslength; i++) {
							entry = new Entry();
							entry._worker = worker;
							if (data.view.getUint32(index) != 0x504b0102) {
								onerror(ERR_BAD_FORMAT);
								return;
							}
							readCommonHeader(entry, data, index + 6, true, onerror);
							entry.commentLength = data.view.getUint16(index + 32, true);
							entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
							entry.offset = data.view.getUint32(index + 42, true);
							filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
							entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
							if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
								entry.directory = true;
							comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46
									+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));
							entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
							entries.push(entry);
							index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
						}
						callback(entries);
					}, function() {
						onerror(ERR_READ);
					});
				});
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}
				if (callback)
					callback();
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipReader);
		else {
			createWorker('inflater',
				function(worker) {
					zipReader._worker = worker;
					callback(zipReader);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	// ZipWriter

	function encodeUTF8(string) {
		return unescape(encodeURIComponent(string));
	}

	function getBytes(str) {
		var i, array = [];
		for (i = 0; i < str.length; i++)
			array.push(str.charCodeAt(i));
		return array;
	}

	function createZipWriter(writer, callback, onerror, dontDeflate) {
		var files = {}, filenames = [], datalength = 0;
		var deflateSN = 0;

		function onwriteerror(err) {
			onerror(err || ERR_WRITE);
		}

		function onreaderror(err) {
			onerror(err || ERR_READ_DATA);
		}

		var zipWriter = {
			add : function(name, reader, onend, onprogress, options) {
				var header, filename, date;
				var worker = this._worker;

				function writeHeader(callback) {
					var data;
					date = options.lastModDate || new Date();
					header = getDataHelper(26);
					files[name] = {
						headerArray : header.array,
						directory : options.directory,
						filename : filename,
						offset : datalength,
						comment : getBytes(encodeUTF8(options.comment || ""))
					};
					header.view.setUint32(0, 0x14000808);
					if (options.version)
						header.view.setUint8(0, options.version);
					if (!dontDeflate && options.level !== 0 && !options.directory)
						header.view.setUint16(4, 0x0800);
					header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
					header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
					header.view.setUint16(22, filename.length, true);
					data = getDataHelper(30 + filename.length);
					data.view.setUint32(0, 0x504b0304);
					data.array.set(header.array, 4);
					data.array.set(filename, 30);
					datalength += data.array.length;
					writer.writeUint8Array(data.array, callback, onwriteerror);
				}

				function writeFooter(compressedLength, crc32) {
					var footer = getDataHelper(16);
					datalength += compressedLength || 0;
					footer.view.setUint32(0, 0x504b0708);
					if (typeof crc32 != "undefined") {
						header.view.setUint32(10, crc32, true);
						footer.view.setUint32(4, crc32, true);
					}
					if (reader) {
						footer.view.setUint32(8, compressedLength, true);
						header.view.setUint32(14, compressedLength, true);
						footer.view.setUint32(12, reader.size, true);
						header.view.setUint32(18, reader.size, true);
					}
					writer.writeUint8Array(footer.array, function() {
						datalength += 16;
						onend();
					}, onwriteerror);
				}

				function writeFile() {
					options = options || {};
					name = name.trim();
					if (options.directory && name.charAt(name.length - 1) != "/")
						name += "/";
					if (files.hasOwnProperty(name)) {
						onerror(ERR_DUPLICATED_NAME);
						return;
					}
					filename = getBytes(encodeUTF8(name));
					filenames.push(name);
					writeHeader(function() {
						if (reader)
							if (dontDeflate || options.level === 0)
								copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
							else
								deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
						else
							writeFooter();
					}, onwriteerror);
				}

				if (reader)
					reader.init(writeFile, onreaderror);
				else
					writeFile();
			},
			close : function(callback) {
				if (this._worker) {
					this._worker.terminate();
					this._worker = null;
				}

				var data, length = 0, index = 0, indexFilename, file;
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					length += 46 + file.filename.length + file.comment.length;
				}
				data = getDataHelper(length + 22);
				for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
					file = files[filenames[indexFilename]];
					data.view.setUint32(index, 0x504b0102);
					data.view.setUint16(index + 4, 0x1400);
					data.array.set(file.headerArray, index + 6);
					data.view.setUint16(index + 32, file.comment.length, true);
					if (file.directory)
						data.view.setUint8(index + 38, 0x10);
					data.view.setUint32(index + 42, file.offset, true);
					data.array.set(file.filename, index + 46);
					data.array.set(file.comment, index + 46 + file.filename.length);
					index += 46 + file.filename.length + file.comment.length;
				}
				data.view.setUint32(index, 0x504b0506);
				data.view.setUint16(index + 8, filenames.length, true);
				data.view.setUint16(index + 10, filenames.length, true);
				data.view.setUint32(index + 12, length, true);
				data.view.setUint32(index + 16, datalength, true);
				writer.writeUint8Array(data.array, function() {
					writer.getData(callback);
				}, onwriteerror);
			},
			_worker: null
		};

		if (!obj.zip.useWebWorkers)
			callback(zipWriter);
		else {
			createWorker('deflater',
				function(worker) {
					zipWriter._worker = worker;
					callback(zipWriter);
				},
				function(err) {
					onerror(err);
				}
			);
		}
	}

	function resolveURLs(urls) {
		var a = document.createElement('a');
		return urls.map(function(url) {
			a.href = url;
			return a.href;
		});
	}

	var DEFAULT_WORKER_SCRIPTS = {
		deflater: ['z-worker.js', 'deflate.js'],
		inflater: ['z-worker.js', 'inflate.js']
	};
	function createWorker(type, callback, onerror) {
		if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
			onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
			return;
		}
		var scripts;
		if (obj.zip.workerScripts) {
			scripts = obj.zip.workerScripts[type];
			if (!Array.isArray(scripts)) {
				onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
				return;
			}
			scripts = resolveURLs(scripts);
		} else {
			scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
			scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
		}
		var worker = new Worker(scripts[0]);
		// record total consumed time by inflater/deflater/crc32 in this worker
		worker.codecTime = worker.crcTime = 0;
		worker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });
		worker.addEventListener('message', onmessage);
		function onmessage(ev) {
			var msg = ev.data;
			if (msg.error) {
				worker.terminate(); // should before onerror(), because onerror() may throw.
				onerror(msg.error);
				return;
			}
			if (msg.type === 'importScripts') {
				worker.removeEventListener('message', onmessage);
				worker.removeEventListener('error', errorHandler);
				callback(worker);
			}
		}
		// catch entry script loading error and other unhandled errors
		worker.addEventListener('error', errorHandler);
		function errorHandler(err) {
			worker.terminate();
			onerror(err);
		}
	}

	function onerror_default(error) {
		console.error(error);
	}
	obj.zip = {
		Reader : Reader,
		Writer : Writer,
		BlobReader : BlobReader,
		Data64URIReader : Data64URIReader,
		TextReader : TextReader,
		BlobWriter : BlobWriter,
		Data64URIWriter : Data64URIWriter,
		TextWriter : TextWriter,
		createReader : function(reader, callback, onerror) {
			onerror = onerror || onerror_default;

			reader.init(function() {
				createZipReader(reader, callback, onerror);
			}, onerror);
		},
		createWriter : function(writer, callback, onerror, dontDeflate) {
			onerror = onerror || onerror_default;
			dontDeflate = !!dontDeflate;

			writer.init(function() {
				createZipWriter(writer, callback, onerror, dontDeflate);
			}, onerror);
		},
		useWebWorkers : true,
		/**
		 * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.
		 * E.g.: zip.workerScripts = './';
		 */
		workerScriptsPath : null,
		/**
		 * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.
		 * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.
		 * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.
		 * All urls are relative to current base url.
		 * E.g.:
		 * zip.workerScripts = {
		 *   deflater: ['z-worker.js', 'deflate.js'],
		 *   inflater: ['z-worker.js', 'inflate.js']
		 * };
		 */
		workerScripts : null,
	};

})(this);

; browserify_shim__define__module__export__(typeof zip != "undefined" ? zip : window.zip);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvc2NyaXB0cy9hcHAuanMiLCJhcHAvc2NyaXB0cy9pbWFnZWxpYi9BbmFseXNpcy5qcyIsImFwcC9zY3JpcHRzL2ltYWdlbGliL0RyYXdpbmcuanMiLCJhcHAvc2NyaXB0cy9pbWFnZWxpYi9FZmZlY3RzLmpzIiwiYXBwL3NjcmlwdHMvaW1hZ2VsaWIvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9wYWdlcy9BY3Rpb25CYXJJY29uR2VuZXJhdG9yLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvQXBwU2hvcnRjdXRJY29uR2VuZXJhdG9yLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvQmFzZUdlbmVyYXRvci5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL0dlbmVyaWNJY29uR2VuZXJhdG9yLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvTGF1bmNoZXJJY29uR2VuZXJhdG9yLmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvTm90aWZpY2F0aW9uSWNvbkdlbmVyYXRvci5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvcGFnZXMvbmluZXBhdGNoL05pbmVQYXRjaEdlbmVyYXRvci5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL25pbmVwYXRjaC9OaW5lUGF0Y2hMb2FkZXIuanMiLCJhcHAvc2NyaXB0cy9wYWdlcy9uaW5lcGF0Y2gvTmluZVBhdGNoUHJldmlldy5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL25pbmVwYXRjaC9OaW5lUGF0Y2hTdGFnZS5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL25pbmVwYXRjaC9OaW5lUGF0Y2hUcmltbWluZy5qcyIsImFwcC9zY3JpcHRzL3BhZ2VzL25pbmVwYXRjaC9TdW1tZXIuanMiLCJhcHAvc2NyaXB0cy9zdHVkaW8vSGFzaC5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9VdGlsLmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL1ppcC5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9mb3Jtcy9Cb29sZWFuRmllbGQuanMiLCJhcHAvc2NyaXB0cy9zdHVkaW8vZm9ybXMvQ29sb3JGaWVsZC5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9mb3Jtcy9FbnVtRmllbGQuanMiLCJhcHAvc2NyaXB0cy9zdHVkaW8vZm9ybXMvRmllbGQuanMiLCJhcHAvc2NyaXB0cy9zdHVkaW8vZm9ybXMvRm9ybS5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9mb3Jtcy9HcmFkaWVudEZpZWxkLmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL2Zvcm1zL0ltYWdlRmllbGQtY2xpcGFydC5qcyIsImFwcC9zY3JpcHRzL3N0dWRpby9mb3Jtcy9JbWFnZUZpZWxkLmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL2Zvcm1zL1JhbmdlRmllbGQuanMiLCJhcHAvc2NyaXB0cy9zdHVkaW8vZm9ybXMvVGV4dEZpZWxkLmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL2Zvcm1zL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvc3R1ZGlvL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Rpbnljb2xvcjIvdGlueWNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL3dlYmZvbnRsb2FkZXIvd2ViZm9udGxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy96aXBqcy1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ppcGpzLWJyb3dzZXJpZnkvdmVuZG9yL3ppcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDZ0JBOztBQUNBOztBQUNBOztBQUVBLE9BQU8sS0FBUCxnQixDQXBCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZ0JBOzswRkFoQkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQk8sSUFBTSw4QkFBVyxFQUFqQjs7QUFFUCxTQUFTLG1CQUFUOztBQTJCQSxTQUFT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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtwYWdlc30gZnJvbSAnLi9wYWdlcyc7XG5pbXBvcnQge3N0dWRpb30gZnJvbSAnLi9zdHVkaW8nO1xuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi9pbWFnZWxpYic7XG5cbndpbmRvdy5wYWdlcyA9IHBhZ2VzO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7RHJhd2luZ30gZnJvbSAnLi9EcmF3aW5nJztcblxuZXhwb3J0IGNvbnN0IEFuYWx5c2lzID0ge307XG5cbkFuYWx5c2lzLlRSSU1fUkVDVF9XT1JLRVJfSlMgPSBgXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGwgPSBldmVudC5kYXRhLnNpemUudywgdCA9IGV2ZW50LmRhdGEuc2l6ZS5oLCByID0gMCwgYiA9IDA7XG5cbiAgICAgIHZhciBhbHBoYTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgZXZlbnQuZGF0YS5zaXplLmg7IHkrKykge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGV2ZW50LmRhdGEuc2l6ZS53OyB4KyspIHtcbiAgICAgICAgICBhbHBoYSA9IGV2ZW50LmRhdGEuaW1hZ2VEYXRhLmRhdGFbXG4gICAgICAgICAgICAgICgoeSAqIGV2ZW50LmRhdGEuc2l6ZS53ICsgeCkgPDwgMikgKyAzXTtcbiAgICAgICAgICBpZiAoYWxwaGEgPj0gZXZlbnQuZGF0YS5taW5BbHBoYSkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKHgsIGwpO1xuICAgICAgICAgICAgdCA9IE1hdGgubWluKHksIHQpO1xuICAgICAgICAgICAgciA9IE1hdGgubWF4KHgsIHIpO1xuICAgICAgICAgICAgYiA9IE1hdGgubWF4KHksIGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobCA+IHIpIHtcbiAgICAgICAgLy8gbm8gcGl4ZWxzLCBjb3VsZG4ndCB0cmltXG4gICAgICAgIHBvc3RNZXNzYWdlKHsgeDogMCwgeTogMCwgdzogZXZlbnQuZGF0YS5zaXplLncsIGg6IGV2ZW50LmRhdGEuc2l6ZS5oIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBvc3RNZXNzYWdlKHsgeDogbCwgeTogdCwgdzogciAtIGwgKyAxLCBoOiBiIC0gdCArIDEgfSk7XG4gICAgfTtgXG5cbkFuYWx5c2lzLk1BWF9UUklNX1NSQ19TSVpFID0gNTAwO1xuXG5BbmFseXNpcy5nZXRUcmltUmVjdCA9IGZ1bmN0aW9uKGN0eCwgc2l6ZSwgbWluQWxwaGEpIHtcbiAgaWYgKCFjdHguY2FudmFzKSB7XG4gICAgLy8gTGlrZWx5IGFuIGltYWdlXG4gICAgbGV0IHNyYyA9IGN0eDtcbiAgICBjdHggPSBEcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmMsIDAsIDApO1xuICB9XG5cbiAgbGV0IHNjYWxlID0gMTtcbiAgaWYgKHNpemUudyA+IEFuYWx5c2lzLk1BWF9UUklNX1NSQ19TSVpFIHx8IHNpemUuaCA+IEFuYWx5c2lzLk1BWF9UUklNX1NSQ19TSVpFKSB7XG4gICAgc2NhbGUgPSAoc2l6ZS53ID4gQW5hbHlzaXMuTUFYX1RSSU1fU1JDX1NJWkUpXG4gICAgICAgID8gQW5hbHlzaXMuTUFYX1RSSU1fU1JDX1NJWkUgLyBzaXplLndcbiAgICAgICAgOiBBbmFseXNpcy5NQVhfVFJJTV9TUkNfU0laRSAvIHNpemUuaDtcbiAgICBsZXQgc2NhbGVkU2l6ZSA9IHsgdzogc2l6ZS53ICogc2NhbGUsIGg6IHNpemUuaCAqIHNjYWxlIH07XG4gICAgbGV0IHRtcEN0eCA9IERyYXdpbmcuY29udGV4dChzY2FsZWRTaXplKTtcbiAgICB0bXBDdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIDAsIDAsIHNpemUudywgc2l6ZS5oLCAwLCAwLCBzY2FsZWRTaXplLncsIHNjYWxlZFNpemUuaCk7XG4gICAgY3R4ID0gdG1wQ3R4O1xuICAgIHNpemUgPSBzY2FsZWRTaXplO1xuICB9XG5cbiAgbGV0IHdvcmtlcjtcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKG1pbkFscGhhID09IDApIHtcbiAgICAgIHJlc29sdmUoeyB4OiAwLCB5OiAwLCB3OiBzaXplLncsIGg6IHNpemUuaCB9KTtcbiAgICB9XG5cbiAgICBtaW5BbHBoYSA9IG1pbkFscGhhIHx8IDE7XG5cbiAgICB3b3JrZXIgPSBydW5Xb3JrZXJKc18oXG4gICAgICAgIEFuYWx5c2lzLlRSSU1fUkVDVF9XT1JLRVJfSlMsXG4gICAgICAgIHtcbiAgICAgICAgICBpbWFnZURhdGE6IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZS53LCBzaXplLmgpLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgbWluQWxwaGFcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0aW5nUmVjdCA9PiB7XG4gICAgICAgICAgcmVzdWx0aW5nUmVjdC54IC89IHNjYWxlO1xuICAgICAgICAgIHJlc3VsdGluZ1JlY3QueSAvPSBzY2FsZTtcbiAgICAgICAgICByZXN1bHRpbmdSZWN0LncgLz0gc2NhbGU7XG4gICAgICAgICAgcmVzdWx0aW5nUmVjdC5oIC89IHNjYWxlO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0aW5nUmVjdClcbiAgICAgICAgICB3b3JrZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsICd3b3JrZXInLCB7XG4gICAgZ2V0OiAoKSA9PiB3b3JrZXJcbiAgfSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BbmFseXNpcy5nZXRDZW50ZXJPZk1hc3MgPSBmdW5jdGlvbihjdHgsIHNpemUsIG1pbkFscGhhKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFjdHguY2FudmFzKSB7XG4gICAgICAvLyBMaWtlbHkgYW4gaW1hZ2VcbiAgICAgIHZhciBzcmMgPSBjdHg7XG4gICAgICBjdHggPSBEcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHNyYywgMCwgMCk7XG4gICAgfVxuXG4gICAgaWYgKG1pbkFscGhhID09IDApIHtcbiAgICAgIHJlc29sdmUoeyB4OiBzaXplLncgLyAyLCB5OiBzaXplLmggLyAyIH0pO1xuICAgIH1cblxuICAgIG1pbkFscGhhID0gbWluQWxwaGEgfHwgMTtcblxuICAgIHZhciBsID0gc2l6ZS53LCB0ID0gc2l6ZS5oLCByID0gMCwgYiA9IDA7XG4gICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuXG4gICAgdmFyIHN1bVggPSAwO1xuICAgIHZhciBzdW1ZID0gMDtcbiAgICB2YXIgbiA9IDA7IC8vIG51bWJlciBvZiBwaXhlbHMgPiBtaW5BbHBoYVxuICAgIHZhciBhbHBoYTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNpemUuaDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHNpemUudzsgeCsrKSB7XG4gICAgICAgIGFscGhhID0gaW1hZ2VEYXRhLmRhdGFbKCh5ICogc2l6ZS53ICsgeCkgPDwgMikgKyAzXTtcbiAgICAgICAgaWYgKGFscGhhID49IG1pbkFscGhhKSB7XG4gICAgICAgICAgc3VtWCArPSB4O1xuICAgICAgICAgIHN1bVkgKz0geTtcbiAgICAgICAgICArK247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobiA8PSAwKSB7XG4gICAgICAvLyBubyBwaXhlbHMgPiBtaW5BbHBoYSwganVzdCB1c2UgY2VudGVyXG4gICAgICByZXNvbHZlKHsgeDogc2l6ZS53IC8gMiwgaDogc2l6ZS5oIC8gMiB9KTtcbiAgICB9XG5cbiAgICByZXNvbHZlKHsgeDogTWF0aC5yb3VuZChzdW1YIC8gbiksIHk6IE1hdGgucm91bmQoc3VtWSAvIG4pIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIGZvciBydW5uaW5nIGlubGluZSBXZWIgV29ya2VycywgaWYgdGhlIGJyb3dzZXIgY2FuIHN1cHBvcnRcbiAqIHRoZW0uIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpbmxpbmUgV2ViIFdvcmtlcnMsIHJ1biB0aGUgc2NyaXB0XG4gKiBvbiB0aGUgbWFpbiB0aHJlYWQsIHdpdGggdGhpcyBmdW5jdGlvbiBib2R5J3Mgc2NvcGUsIHVzaW5nIGV2YWwuIEJyb3dzZXJzXG4gKiBtdXN0IHByb3ZpZGUgQmxvYkJ1aWxkZXIsIFVSTC5jcmVhdGVPYmplY3RVUkwsIGFuZCBXb3JrZXIgc3VwcG9ydCB0byB1c2VcbiAqIGlubGluZSBXZWIgV29ya2Vycy4gTW9zdCBmZWF0dXJlcyBzdWNoIGFzIGltcG9ydFNjcmlwdHMoKSBhcmUgbm90XG4gKiBjdXJyZW50bHkgc3VwcG9ydGVkLCBzbyB0aGlzIG9ubHkgd29ya3MgZm9yIGJhc2ljIHdvcmtlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30ganMgVGhlIGlubGluZSBXZWIgV29ya2VyIEphdmFzY3JpcHQgY29kZSB0byBydW4uIFRoaXMgY29kZVxuICogICAgIG11c3QgdXNlICdzZWxmJyBhbmQgbm90ICd0aGlzJyBhcyB0aGUgZ2xvYmFsIGNvbnRleHQgdmFyaWFibGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIG9iamVjdCB0byBwYXNzIHRvIHRoZSB3b3JrZXIuXG4gKiAgICAgRXF1aXZhbGVudCB0byBjYWxsaW5nIFdvcmtlci5wb3N0TWVzc2FnZShwYXJhbXMpO1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHJ1biB3aGVuIHRoZSB3b3JrZXIgY2FsbHNcbiAqICAgICBwb3N0TWVzc2FnZS4gRXF1aXZhbGVudCB0byBhZGRpbmcgYSAnbWVzc2FnZScgZXZlbnQgbGlzdGVuZXIgb24gYVxuICogICAgIFdvcmtlciBvYmplY3QgYW5kIHJ1bm5pbmcgY2FsbGJhY2soZXZlbnQuZGF0YSk7XG4gKi9cbmZ1bmN0aW9uIHJ1bldvcmtlckpzXyhqcywgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkw7XG4gIHZhciBXb3JrZXIgPSB3aW5kb3cuV29ya2VyO1xuXG4gIGlmIChVUkwgJiYgV29ya2VyICYmIGhhc0Jsb2JDb25zdHJ1Y3Rvcl8oKSkge1xuICAgIC8vIFRoZSBCbG9iIGNvbnN0cnVjdG9yLCBXb3JrZXIsIGFuZCB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCBhcmUgYWxsIGF2YWlsYWJsZSxcbiAgICAvLyBzbyB3ZSBjYW4gdXNlIGlubGluZSB3b3JrZXJzLlxuICAgIHZhciBiYiA9IG5ldyBCbG9iKFtqc10sIHt0eXBlOid0ZXh0L2phdmFzY3JpcHQnfSk7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChiYikpO1xuICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQuZGF0YSk7XG4gICAgfTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UocGFyYW1zKTtcbiAgICByZXR1cm4gd29ya2VyO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY2FuJ3QgdXNlIGlubGluZSB3b3JrZXJzLCBzbyBydW4gdGhlIHdvcmtlciBKUyBvbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9fRFVNTVlfT0JKRUNUX18gPSB7fTtcbiAgICAgIC8vIFByb3h5IHRvIFdvcmtlci5vbm1lc3NhZ2VcbiAgICAgIHZhciBwb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIC8vIEJpbmQgdGhlIHdvcmtlciB0byB0aGlzIGR1bW15IG9iamVjdC4gVGhlIHdvcmtlciB3aWxsIHJ1blxuICAgICAgLy8gaW4gdGhpcyBzY29wZS5cbiAgICAgIGV2YWwoJ3ZhciBzZWxmPV9fRFVNTVlfT0JKRUNUX187XFxuJyArIGpzKTtcbiAgICAgIC8vIFByb3h5IHRvIFdvcmtlci5wb3N0TWVzc2FnZVxuICAgICAgX19EVU1NWV9PQkpFQ1RfXy5vbm1lc3NhZ2Uoe1xuICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgIH0pO1xuICAgIH0pKCk7XG5cbiAgICAvLyBSZXR1cm4gYSBkdW1teSBXb3JrZXIuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oKXt9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpbGRhcy1sb3JtZWF1L3ppcC5qcy9pc3N1ZXMvMTcjaXNzdWVjb21tZW50LTg1MTMyNThcbi8vIHRoYW5rcyBFcmljIVxuZnVuY3Rpb24gaGFzQmxvYkNvbnN0cnVjdG9yXygpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFuZXcgQmxvYigpO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2RlZmF1bHQgYXMgdGlueWNvbG9yfSBmcm9tICd0aW55Y29sb3IyJztcblxuaW1wb3J0IHtFZmZlY3RzfSBmcm9tICcuL0VmZmVjdHMnO1xuXG5leHBvcnQgY29uc3QgRHJhd2luZyA9IHt9O1xuXG5EcmF3aW5nLmNvbnRleHQgPSBmdW5jdGlvbihzaXplKSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gc2l6ZS53O1xuICBjYW52YXMuaGVpZ2h0ID0gc2l6ZS5oO1xuICBjYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2ltYWdlLXJlbmRlcmluZycsICdvcHRpbWl6ZVF1YWxpdHknLCBudWxsKTtcbiAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xufTtcblxuRHJhd2luZy5kcmF3Q2VudGVySW5zaWRlID0gZnVuY3Rpb24oZHN0Q3R4LCBzcmMsIGRzdFJlY3QsIHNyY1JlY3QpIHtcbiAgaWYgKHNyY1JlY3QudyAvIHNyY1JlY3QuaCA+IGRzdFJlY3QudyAvIGRzdFJlY3QuaCkge1xuICAgIHZhciBoID0gc3JjUmVjdC5oICogZHN0UmVjdC53IC8gc3JjUmVjdC53O1xuICAgICBEcmF3aW5nLmRyYXdJbWFnZVNjYWxlZChkc3RDdHgsIHNyYyxcbiAgICAgICAgc3JjUmVjdC54LCBzcmNSZWN0LnksXG4gICAgICAgIHNyY1JlY3Qudywgc3JjUmVjdC5oLFxuICAgICAgICBkc3RSZWN0LngsIGRzdFJlY3QueSArIChkc3RSZWN0LmggLSBoKSAvIDIsXG4gICAgICAgIGRzdFJlY3QudywgaCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSBzcmNSZWN0LncgKiBkc3RSZWN0LmggLyBzcmNSZWN0Lmg7XG4gICAgIERyYXdpbmcuZHJhd0ltYWdlU2NhbGVkKGRzdEN0eCwgc3JjLFxuICAgICAgICBzcmNSZWN0LngsIHNyY1JlY3QueSxcbiAgICAgICAgc3JjUmVjdC53LCBzcmNSZWN0LmgsXG4gICAgICAgIGRzdFJlY3QueCArIChkc3RSZWN0LncgLSB3KSAvIDIsIGRzdFJlY3QueSxcbiAgICAgICAgdywgZHN0UmVjdC5oKTtcbiAgfVxufTtcblxuRHJhd2luZy5kcmF3Q2VudGVyQ3JvcCA9IGZ1bmN0aW9uKGRzdEN0eCwgc3JjLCBkc3RSZWN0LCBzcmNSZWN0KSB7XG4gIGlmIChzcmNSZWN0LncgLyBzcmNSZWN0LmggPiBkc3RSZWN0LncgLyBkc3RSZWN0LmgpIHtcbiAgICB2YXIgdyA9IHNyY1JlY3QuaCAqIGRzdFJlY3QudyAvIGRzdFJlY3QuaDtcbiAgICBEcmF3aW5nLmRyYXdJbWFnZVNjYWxlZChkc3RDdHgsIHNyYyxcbiAgICAgICAgc3JjUmVjdC54ICsgKHNyY1JlY3QudyAtIHcpIC8gMiwgc3JjUmVjdC55LFxuICAgICAgICB3LCBzcmNSZWN0LmgsXG4gICAgICAgIGRzdFJlY3QueCwgZHN0UmVjdC55LFxuICAgICAgICBkc3RSZWN0LncsIGRzdFJlY3QuaCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGggPSBzcmNSZWN0LncgKiBkc3RSZWN0LmggLyBkc3RSZWN0Lnc7XG4gICAgRHJhd2luZy5kcmF3SW1hZ2VTY2FsZWQoZHN0Q3R4LCBzcmMsXG4gICAgICAgIHNyY1JlY3QueCwgc3JjUmVjdC55ICsgKHNyY1JlY3QuaCAtIGgpIC8gMixcbiAgICAgICAgc3JjUmVjdC53LCBoLFxuICAgICAgICBkc3RSZWN0LngsIGRzdFJlY3QueSxcbiAgICAgICAgZHN0UmVjdC53LCBkc3RSZWN0LmgpO1xuICB9XG59O1xuXG5EcmF3aW5nLmRyYXdJbWFnZVNjYWxlZCA9IGZ1bmN0aW9uKGRzdEN0eCwgc3JjLCBzeCwgc3ksIHN3LCBzaCwgZHgsIGR5LCBkdywgZGgpIHtcbiAgaWYgKGR3IDw9IDAgfHwgZGggPD0gMCB8fCBzdyA8PSAwIHx8IHNoIDw9IDApIHtcbiAgICBjb25zb2xlLmVycm9yKCdXaWR0aC9oZWlnaHQgbXVzdCBiZSBhdCBsZWFzdCAwJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3JjID0gc3JjLmNhbnZhcyB8fCBzcmM7XG5cbiAgLy8gYWxnb3JpdGhtOiB3aGVuIHNjYWxpbmcgZG93biwgZG93bnNhbXBsZSBieSBhdCBtb3N0IGEgZmFjdG9yIG9mIDIgcGVyIGl0ZXJhdGlvblxuICAvLyB0byBhdm9pZCBwb29yIGJyb3dzZXIgZG93bnNhbXBsaW5nXG4gIHdoaWxlIChkdyA8IHN3IC8gMiB8fCBkaCA8IHNoIC8gMikge1xuICAgIGxldCB0bXBEdyA9IE1hdGguY2VpbChNYXRoLm1heChkdywgc3cgLyAyKSk7XG4gICAgbGV0IHRtcERoID0gTWF0aC5jZWlsKE1hdGgubWF4KGRoLCBzaCAvIDIpKTtcbiAgICBsZXQgdG1wQ3R4ID0gRHJhd2luZy5jb250ZXh0KHsgdzogdG1wRHcsIGg6IHRtcERoIH0pO1xuXG4gICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCB0bXBEdywgdG1wRGgpO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2Uoc3JjLCBzeCwgc3ksIHN3LCBzaCwgMCwgMCwgdG1wRHcsIHRtcERoKTtcblxuICAgIHNyYyA9IHRtcEN0eC5jYW52YXM7XG4gICAgc3ggPSBzeSA9IDA7XG4gICAgc3cgPSB0bXBEdztcbiAgICBzaCA9IHRtcERoO1xuICB9XG5cbiAgZHN0Q3R4LmRyYXdJbWFnZShzcmMsIHN4LCBzeSwgc3csIHNoLCBkeCwgZHksIGR3LCBkaCk7XG59O1xuXG5EcmF3aW5nLmRyYXdMYXllcnMgPSBmdW5jdGlvbihkc3RDdHgsIHNpemUsIGxheWVyVHJlZSkge1xuICBkcmF3TGF5ZXJfKGRzdEN0eCwgbGF5ZXJUcmVlKTtcblxuICBmdW5jdGlvbiBkcmF3TGF5ZXJfKGRzdEN0eCwgbGF5ZXIpIHtcbiAgICBsZXQgbGF5ZXJDdHggPSBEcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG5cbiAgICBpZiAobGF5ZXIuY2hpbGRyZW4pIHtcbiAgICAgIGRyYXdHcm91cF8obGF5ZXJDdHgsIGxheWVyKTtcbiAgICB9IGVsc2UgaWYgKGxheWVyLmRyYXcpIHtcbiAgICAgIGxheWVyLmRyYXcobGF5ZXJDdHgpO1xuICAgIH1cblxuICAgIGlmIChsYXllci5lZmZlY3RzKSB7XG4gICAgICAvLyBhcHBseSBlZmZlY3RzIGluIGEgbmV3IGJ1ZmZlclxuICAgICAgbGV0IGVmZmVjdHNDdHggPSBEcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG4gICAgICBFZmZlY3RzLmZ4KGxheWVyLmVmZmVjdHMsIGVmZmVjdHNDdHgsIGxheWVyQ3R4LCBzaXplKTtcbiAgICAgIGxheWVyQ3R4ID0gZWZmZWN0c0N0eDtcbiAgICB9XG5cbiAgICBkc3RDdHguZHJhd0ltYWdlKGxheWVyQ3R4LmNhbnZhcywgMCwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3R3JvdXBfKGRzdEN0eCwgZ3JvdXApIHtcbiAgICBsZXQgZHN0Q3R4U3RhY2sgPSBbZHN0Q3R4XTtcblxuICAgIGdyb3VwLmNoaWxkcmVuLmZpbHRlcihsYXllciA9PiAhIWxheWVyKS5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGRyYXdMYXllcl8oZHN0Q3R4U3RhY2tbZHN0Q3R4U3RhY2subGVuZ3RoIC0gMV0sIGxheWVyKTtcbiAgICAgIGlmIChsYXllci5tYXNrKSB7XG4gICAgICAgIC8vIGRyYXcgZnV0dXJlIGxheWVycyBpbnRvIGEgc2VwYXJhdGUgYnVmZmVyIChsYXRlciBnZXRzIG1hc2tlZClcbiAgICAgICAgbGV0IG1hc2tlZENvbnRlbnRDdHggPSBEcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG4gICAgICAgIGRzdEN0eFN0YWNrLnB1c2gobWFza2VkQ29udGVudEN0eCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB3aGlsZSAoZHN0Q3R4U3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgbGV0IHRhcmdldEN0eCA9IGRzdEN0eFN0YWNrW2RzdEN0eFN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgbGV0IGNvbnRlbnRDdHggPSBkc3RDdHhTdGFja1tkc3RDdHhTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHRhcmdldEN0eC5zYXZlKCk7XG4gICAgICB0YXJnZXRDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1hdG9wJztcbiAgICAgIHRhcmdldEN0eC5kcmF3SW1hZ2UoY29udGVudEN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgdGFyZ2V0Q3R4LnJlc3RvcmUoKTtcbiAgICAgIGRzdEN0eFN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0RyYXdpbmd9IGZyb20gJy4vRHJhd2luZyc7XG5cbmNvbnN0IE9VVEVSX0VGRkVDVFMgPSBuZXcgU2V0KFsnb3V0ZXItc2hhZG93JywgJ2Nhc3Qtc2hhZG93J10pO1xuY29uc3QgSU5ORVJfRUZGRUNUUyA9IG5ldyBTZXQoWydpbm5lci1zaGFkb3cnLCAnc2NvcmUnXSk7XG5jb25zdCBGSUxMX0VGRkVDVFMgPSBuZXcgU2V0KFsnZmlsbC1jb2xvcicsICdmaWxsLWxpbmVhcmdyYWRpZW50JywgJ2ZpbGwtcmFkaWFsZ3JhZGllbnQnXSk7XG5cblxuZXhwb3J0IGNvbnN0IEVmZmVjdHMgPSB7XG4gIGZ4KGVmZmVjdHMsIGRzdEN0eCwgc3JjLCBzaXplKSB7XG4gICAgZWZmZWN0cyA9IGVmZmVjdHMgfHwgW107XG5cbiAgICBsZXQgb3V0ZXJFZmZlY3RzID0gZWZmZWN0cy5maWx0ZXIoZSA9PiBPVVRFUl9FRkZFQ1RTLmhhcyhlLmVmZmVjdCkpO1xuICAgIGxldCBpbm5lckVmZmVjdHMgPSBlZmZlY3RzLmZpbHRlcihlID0+IElOTkVSX0VGRkVDVFMuaGFzKGUuZWZmZWN0KSk7XG4gICAgbGV0IGZpbGxFZmZlY3RzID0gZWZmZWN0cy5maWx0ZXIoZSA9PiBGSUxMX0VGRkVDVFMuaGFzKGUuZWZmZWN0KSk7XG5cbiAgICBsZXQgdG1wQ3R4LCBidWZmZXJDdHg7XG5cbiAgICAvLyBGaXJzdCByZW5kZXIgb3V0ZXIgZWZmZWN0c1xuICAgIGxldCBwYWRMZWZ0LCBwYWRSaWdodCwgcGFkQm90dG9tLCBwYWRUb3A7XG4gICAgcGFkTGVmdCA9IHBhZFJpZ2h0ID0gcGFkQm90dG9tID0gcGFkVG9wID1cbiAgICAgICAgb3V0ZXJFZmZlY3RzLnJlZHVjZSgociwgZSkgPT4gTWF0aC5tYXgociwgZS5ibHVyIHx8IDApLCAwKTtcblxuICAgIGxldCBwYWRkZWRTaXplID0ge1xuICAgICAgdzogc2l6ZS53ICsgcGFkTGVmdCArIHBhZFJpZ2h0LFxuICAgICAgaDogc2l6ZS5oICsgcGFkVG9wICsgcGFkQm90dG9tXG4gICAgfTtcblxuICAgIHRtcEN0eCA9IERyYXdpbmcuY29udGV4dChwYWRkZWRTaXplKTtcblxuICAgIG91dGVyRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiB7XG4gICAgICBzd2l0Y2ggKGVmZmVjdC5lZmZlY3QpIHtcbiAgICAgICAgY2FzZSAnY2FzdC1zaGFkb3cnOlxuICAgICAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgcGFkZGVkU2l6ZS53LCBwYWRkZWRTaXplLmgpO1xuICAgICAgICAgIHRtcEN0eC5kcmF3SW1hZ2Uoc3JjLmNhbnZhcyB8fCBzcmMsIHBhZExlZnQsIHBhZFRvcCk7XG4gICAgICAgICAgcmVuZGVyQ2FzdFNoYWRvd18odG1wQ3R4LCBwYWRkZWRTaXplLncsIHBhZGRlZFNpemUuaCwgdGlueWNvbG9yKGVmZmVjdC5jb2xvcikpO1xuICAgICAgICAgIGRzdEN0eC5kcmF3SW1hZ2UodG1wQ3R4LmNhbnZhcywgcGFkTGVmdCwgcGFkVG9wLCBzaXplLncsIHNpemUuaCwgMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ291dGVyLXNoYWRvdyc6XG4gICAgICAgICAgbGV0IHRDb2xvciA9IHRpbnljb2xvcihlZmZlY3QuY29sb3IgfHwgJyMwMDAnKTtcbiAgICAgICAgICBsZXQgYWxwaGEgPSB0Q29sb3IuZ2V0QWxwaGEoKTtcbiAgICAgICAgICB0Q29sb3Iuc2V0QWxwaGEoMSk7XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNDYW52YXNGaWx0ZXJzXygpKSB7XG4gICAgICAgICAgICB0bXBDdHguc2F2ZSgpO1xuICAgICAgICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBwYWRkZWRTaXplLncsIHBhZGRlZFNpemUuaCk7XG4gICAgICAgICAgICB0bXBDdHguZmlsdGVyID0gYGJsdXIoJHtlZmZlY3QuYmx1ciB8fCAwfXB4KWA7XG4gICAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKHNyYy5jYW52YXMgfHwgc3JjLCBwYWRMZWZ0LCBwYWRUb3ApO1xuICAgICAgICAgICAgdG1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2UtYXRvcCc7XG4gICAgICAgICAgICB0bXBDdHguZmlsbFN0eWxlID0gdENvbG9yLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgICAgICB0bXBDdHguZmlsbFJlY3QoMCwgMCwgcGFkZGVkU2l6ZS53LCBwYWRkZWRTaXplLmgpO1xuICAgICAgICAgICAgdG1wQ3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgZHN0Q3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGRzdEN0eC50cmFuc2xhdGUoZWZmZWN0LnRyYW5zbGF0ZVggfHwgMCwgZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCk7XG4gICAgICAgICAgICBkc3RDdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgIGRzdEN0eC5kcmF3SW1hZ2UodG1wQ3R4LmNhbnZhcywgcGFkTGVmdCwgcGFkVG9wLCBzaXplLncsIHNpemUuaCwgMCwgMCwgc2l6ZS53LCBzaXplLmgpO1xuICAgICAgICAgICAgZHN0Q3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHN0Q3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGRzdEN0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgZHN0Q3R4LnNoYWRvd09mZnNldFggPSBwYWRkZWRTaXplLnc7XG4gICAgICAgICAgICBkc3RDdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICBkc3RDdHguc2hhZG93Q29sb3IgPSB0Q29sb3IudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgICAgIGRzdEN0eC5zaGFkb3dCbHVyID0gY2FudmFzU2hhZG93Qmx1ckZvclJhZGl1c18oZWZmZWN0LmJsdXIgfHwgMCk7XG4gICAgICAgICAgICBkc3RDdHguZHJhd0ltYWdlKHNyYy5jYW52YXMgfHwgc3JjLFxuICAgICAgICAgICAgICAgIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSAtIHBhZGRlZFNpemUudyxcbiAgICAgICAgICAgICAgICAoZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCkpO1xuICAgICAgICAgICAgZHN0Q3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOZXh0LCByZW5kZXIgdGhlIHNvdXJjZSwgZmlsbCBlZmZlY3RzIChmaXJzdCBvbmUpLCBhbmQgaW5uZXIgZWZmZWN0c1xuICAgIC8vIGluIGEgYnVmZmVyIChidWZmZXJDdHgpXG4gICAgYnVmZmVyQ3R4ID0gRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgIHRtcEN0eCA9IERyYXdpbmcuY29udGV4dChzaXplKTtcbiAgICB0bXBDdHguZHJhd0ltYWdlKHNyYy5jYW52YXMgfHwgc3JjLCAwLCAwKTtcbiAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1hdG9wJztcblxuICAgIC8vIEZpbGwgZWZmZWN0c1xuICAgIGxldCBmaWxsT3BhY2l0eSA9IDEuMDtcbiAgICBpZiAoZmlsbEVmZmVjdHMubGVuZ3RoKSB7XG4gICAgICBsZXQgZWZmZWN0ID0gZmlsbEVmZmVjdHNbMF07XG4gICAgICBmaWxsT3BhY2l0eSA9ICgnb3BhY2l0eScgaW4gZWZmZWN0KSA/IGVmZmVjdC5vcGFjaXR5IDogMTtcblxuICAgICAgdG1wQ3R4LnNhdmUoKTtcblxuICAgICAgc3dpdGNoIChlZmZlY3QuZWZmZWN0KSB7XG4gICAgICAgIGNhc2UgJ2ZpbGwtY29sb3InOiB7XG4gICAgICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IGVmZmVjdC5jb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2ZpbGwtbGluZWFyZ3JhZGllbnQnOiB7XG4gICAgICAgICAgbGV0IGdyYWRpZW50ID0gdG1wQ3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgICAgICBlZmZlY3QuZnJvbVgsIGVmZmVjdC5mcm9tWSwgZWZmZWN0LnRvWCwgZWZmZWN0LnRvWSk7XG4gICAgICAgICAgZWZmZWN0LmNvbG9ycy5mb3JFYWNoKCh7b2Zmc2V0LCBjb2xvcn0pID0+IGdyYWRpZW50LmFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKSk7XG4gICAgICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZmlsbC1yYWRpYWxncmFkaWVudCc6IHtcbiAgICAgICAgICBsZXQgZ3JhZGllbnQgPSB0bXBDdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgICAgIGVmZmVjdC5jZW50ZXJYLCBlZmZlY3QuY2VudGVyWSwgMCwgZWZmZWN0LmNlbnRlclgsIGVmZmVjdC5jZW50ZXJZLCBlZmZlY3QucmFkaXVzKTtcbiAgICAgICAgICBlZmZlY3QuY29sb3JzLmZvckVhY2goKHtvZmZzZXQsIGNvbG9yfSkgPT4gZ3JhZGllbnQuYWRkQ29sb3JTdG9wKG9mZnNldCwgY29sb3IpKTtcbiAgICAgICAgICB0bXBDdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHNpemUudywgc2l6ZS5oKTtcbiAgICAgIHRtcEN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgYnVmZmVyQ3R4LnNhdmUoKTtcbiAgICBidWZmZXJDdHguZ2xvYmFsQWxwaGEgPSBmaWxsT3BhY2l0eTtcbiAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRtcEN0eC5jYW52YXMsIDAsIDApO1xuICAgIGJ1ZmZlckN0eC5yZXN0b3JlKCk7XG5cbiAgICAvLyBSZW5kZXIgaW5uZXIgZWZmZWN0c1xuICAgIHBhZExlZnQgPSBwYWRUb3AgPSBwYWRSaWdodCA9IHBhZEJvdHRvbSA9IDA7XG4gICAgaW5uZXJFZmZlY3RzLmZvckVhY2goZWZmZWN0ID0+IHtcbiAgICAgIHBhZExlZnQgICA9IE1hdGgubWF4KHBhZExlZnQsICAgKGVmZmVjdC5ibHVyIHx8IDApICsgTWF0aC5tYXgoMCwgIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSkpO1xuICAgICAgcGFkVG9wICAgID0gTWF0aC5tYXgocGFkVG9wLCAgICAoZWZmZWN0LmJsdXIgfHwgMCkgKyBNYXRoLm1heCgwLCAgKGVmZmVjdC50cmFuc2xhdGVZIHx8IDApKSk7XG4gICAgICBwYWRSaWdodCAgPSBNYXRoLm1heChwYWRSaWdodCwgIChlZmZlY3QuYmx1ciB8fCAwKSArIE1hdGgubWF4KDAsIC0oZWZmZWN0LnRyYW5zbGF0ZVggfHwgMCkpKTtcbiAgICAgIHBhZEJvdHRvbSA9IE1hdGgubWF4KHBhZEJvdHRvbSwgKGVmZmVjdC5ibHVyIHx8IDApICsgTWF0aC5tYXgoMCwgLShlZmZlY3QudHJhbnNsYXRlWSB8fCAwKSkpO1xuICAgIH0pO1xuXG4gICAgcGFkZGVkU2l6ZSA9IHtcbiAgICAgIHc6IHNpemUudyArIHBhZExlZnQgKyBwYWRSaWdodCxcbiAgICAgIGg6IHNpemUuaCArIHBhZFRvcCArIHBhZEJvdHRvbVxuICAgIH07XG5cbiAgICB0bXBDdHggPSBEcmF3aW5nLmNvbnRleHQocGFkZGVkU2l6ZSk7XG5cbiAgICBpbm5lckVmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4ge1xuICAgICAgc3dpdGNoIChlZmZlY3QuZWZmZWN0KSB7XG4gICAgICAgIGNhc2UgJ2lubmVyLXNoYWRvdyc6XG4gICAgICAgICAgdG1wQ3R4LnNhdmUoKTtcbiAgICAgICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHBhZGRlZFNpemUudywgcGFkZGVkU2l6ZS5oKTtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNDYW52YXNGaWx0ZXJzXygpKSB7XG4gICAgICAgICAgICB0bXBDdHguZmlsdGVyID0gYGJsdXIoJHtlZmZlY3QuYmx1ciB8fCAwfXB4KWA7XG4gICAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKGJ1ZmZlckN0eC5jYW52YXMsXG4gICAgICAgICAgICAgICAgcGFkTGVmdCArIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSxcbiAgICAgICAgICAgICAgICBwYWRUb3AgKyAoZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBDdHguc2hhZG93T2Zmc2V0WCA9IHBhZGRlZFNpemUudztcbiAgICAgICAgICAgIHRtcEN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRtcEN0eC5zaGFkb3dDb2xvciA9ICcjMDAwJzsgLy8gY29sb3IgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgIHRtcEN0eC5zaGFkb3dCbHVyID0gY2FudmFzU2hhZG93Qmx1ckZvclJhZGl1c18oZWZmZWN0LmJsdXIgfHwgMCk7XG4gICAgICAgICAgICB0bXBDdHguZHJhd0ltYWdlKGJ1ZmZlckN0eC5jYW52YXMsXG4gICAgICAgICAgICAgICAgcGFkTGVmdCArIChlZmZlY3QudHJhbnNsYXRlWCB8fCAwKSAtIHBhZGRlZFNpemUudyxcbiAgICAgICAgICAgICAgICBwYWRUb3AgKyAoZWZmZWN0LnRyYW5zbGF0ZVkgfHwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdXQnO1xuICAgICAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSBlZmZlY3QuY29sb3I7XG4gICAgICAgICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHBhZGRlZFNpemUudywgcGFkZGVkU2l6ZS5oKTtcbiAgICAgICAgICB0bXBDdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgYnVmZmVyQ3R4LnNhdmUoKTtcbiAgICAgICAgICBidWZmZXJDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1hdG9wJztcbiAgICAgICAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRtcEN0eC5jYW52YXMsIC1wYWRMZWZ0LCAtcGFkVG9wKTtcbiAgICAgICAgICBidWZmZXJDdHgucmVzdG9yZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRHJhdyBidWZmZXIgKHNvdXJjZSwgZmlsbCwgaW5uZXIgZWZmZWN0cykgb24gdG9wIG9mIG91dGVyIGVmZmVjdHNcbiAgICBkc3RDdHguZHJhd0ltYWdlKGJ1ZmZlckN0eC5jYW52YXMsIDAsIDApO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVuZGVyQ2FzdFNoYWRvd18oY3R4LCB3LCBoLCBjb2xvcikge1xuICBsZXQgdG1wQ3R4ID0gRHJhd2luZy5jb250ZXh0KHt3LCBofSk7XG4gIC8vIHJlbmRlciB0aGUgY2FzdCBzaGFkb3dcbiAgZm9yIChsZXQgbyA9IDE7IG8gPCBNYXRoLm1heCh3LCBoKTsgbysrKSB7XG4gICAgdG1wQ3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCBvLCBvKTtcbiAgfVxuICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1pbic7XG4gIHRtcEN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gIHRtcEN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcbiAgbGV0IGdyYWRpZW50ID0gdG1wQ3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHcsIGgpO1xuICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgY29sb3IudG9SZ2JTdHJpbmcoKSk7XG4gIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBjb2xvci5zZXRBbHBoYSgwKS50b1JnYlN0cmluZygpKTtcbiAgdG1wQ3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICB0bXBDdHguZmlsbFJlY3QoMCwgMCwgdywgaCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gIGN0eC5kcmF3SW1hZ2UodG1wQ3R4LmNhbnZhcywgMCwgMCk7XG59XG5cblxuZnVuY3Rpb24gc3VwcG9ydHNDYW52YXNGaWx0ZXJzXygpIHtcbiAgaWYgKCFzdXBwb3J0c0NhbnZhc0ZpbHRlcnNfLmhhc093blByb3BlcnR5KCdjYWNoZWQnKSkge1xuICAgIHN1cHBvcnRzQ2FudmFzRmlsdGVyc18uY2FjaGVkID0gKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpLmZpbHRlciA9PSAnbm9uZScpO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzQ2FudmFzRmlsdGVyc18uY2FjaGVkO1xufVxuXG5cbi8vIGRldGVybWluZWQgZW1waXJpY2FsbHk6IGh0dHA6Ly9jb2RlcGVuLmlvL2Fub24vcGVuL2dnTE9xSlxuY29uc3QgQkxVUl9NVUxUSVBMSUVSID0gW1xuICB7cmU6IC9jaHJvbWUvaSwgbXVsdDogMi43fSxcbiAge3JlOiAvc2FmYXJpL2ksIG11bHQ6IDEuOH0sXG4gIHtyZTogL2ZpcmVmb3gvaSwgbXVsdDogMS43fSxcbiAge3JlOiAvLi9pLCBtdWx0OiAxLjd9LCAvLyBkZWZhdWx0XG5dLmZpbmQoeCA9PiB4LnJlLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpLm11bHQ7XG5cblxuZnVuY3Rpb24gY2FudmFzU2hhZG93Qmx1ckZvclJhZGl1c18ocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMgKiBCTFVSX01VTFRJUExJRVI7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtFZmZlY3RzfSBmcm9tICcuL0VmZmVjdHMnO1xuaW1wb3J0IHtEcmF3aW5nfSBmcm9tICcuL0RyYXdpbmcnO1xuaW1wb3J0IHtBbmFseXNpc30gZnJvbSAnLi9BbmFseXNpcyc7XG5cbmV4cG9ydCBjb25zdCBpbWFnZWxpYiA9IHtcbiAgRHJhd2luZyxcbiAgRWZmZWN0cyxcbiAgQW5hbHlzaXMsXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3R1ZGlvfSBmcm9tICcuLi9zdHVkaW8nO1xuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vaW1hZ2VsaWInO1xuaW1wb3J0IHtCYXNlR2VuZXJhdG9yfSBmcm9tICcuL0Jhc2VHZW5lcmF0b3InO1xuXG5jb25zdCBJQ09OX1NJWkUgPSB7IHc6IDI0LCBoOiAyNCB9O1xuY29uc3QgVEFSR0VUX1JFQ1QgPSB7IHg6IDAsIHk6IDAsIHc6IDI0LCBoOiAyNCB9O1xuXG5jb25zdCBHUklEX09WRVJMQVlfU1ZHID1cbiAgICBgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgIDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiNFwiIHk9XCIyXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjIwXCIgcng9XCIyXCIvPlxuICAgICAgICAgICAgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCIzXCIgeT1cIjNcIiB3aWR0aD1cIjE4XCIgaGVpZ2h0PVwiMThcIiByeD1cIjJcIi8+XG4gICAgICAgICAgICA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIjJcIiB5PVwiNFwiIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiMlwiLz5cbiAgICAgICAgICAgIDxjaXJjbGUgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjVcIi8+XG4gICAgICAgICAgICA8Y2lyY2xlIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIxMFwiLz5cbiAgICAgICAgICAgIDxwYXRoIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiBkPVwiTTAgMjRMMjQgME0wIDBsMjQgMjRtLTEyIDBWME04IDB2MjRtOC0yNHYyNG04LTEySDBtMCA0aDI0TTAgOGgyNFwiLz5cbiAgICAgICAgPC9nPlxuICAgIDwvc3ZnPmA7XG5cbmV4cG9ydCBjbGFzcyBBY3Rpb25CYXJJY29uR2VuZXJhdG9yIGV4dGVuZHMgQmFzZUdlbmVyYXRvciB7XG4gIGdldCBncmlkT3ZlcmxheVN2ZygpIHtcbiAgICByZXR1cm4gR1JJRF9PVkVSTEFZX1NWRztcbiAgfVxuXG4gIHNldHVwRm9ybSgpIHtcbiAgICBzdXBlci5zZXR1cEZvcm0oKTtcblxuICAgIGxldCBkZWZhdWx0TmFtZUZvclNvdXJjZVZhbHVlXyA9IHYgPT4ge1xuICAgICAgbGV0IG5hbWUgPSBzdHVkaW8uVXRpbC5zYW5pdGl6ZVJlc291cmNlTmFtZSh2Lm5hbWUgfHwgJ2V4YW1wbGUnKTtcbiAgICAgIHJldHVybiBgaWNfYWN0aW9uXyR7bmFtZX1gO1xuICAgIH07XG5cbiAgICBsZXQgbmFtZUZpZWxkLCBjdXN0b21Db2xvckZpZWxkO1xuICAgIHRoaXMuZm9ybSA9IG5ldyBzdHVkaW8uRm9ybSh7XG4gICAgICBpZDogJ2ljb25mb3JtJyxcbiAgICAgIGNvbnRhaW5lcjogJyNpbnB1dHMtZm9ybScsXG4gICAgICBmaWVsZHM6IFtcbiAgICAgICAgbmV3IHN0dWRpby5JbWFnZUZpZWxkKCdzb3VyY2UnLCB7XG4gICAgICAgICAgdGl0bGU6ICdTb3VyY2UnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnTXVzdCBiZSB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgbWF4RmluYWxTaXplOiB7IHc6IDEyOCwgaDogMTI4IH0sXG4gICAgICAgICAgY2xpcGFydE5vVHJpbVBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlQ2xpcGFydDogJ2FkZF9jaXJjbGUnLFxuICAgICAgICAgIGRyb3BUYXJnZXQ6IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgb25DaGFuZ2U6IChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lRmllbGQuZ2V0VmFsdWUoKSA9PSBkZWZhdWx0TmFtZUZvclNvdXJjZVZhbHVlXyhvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmFtZUZpZWxkLnNldFZhbHVlKGRlZmF1bHROYW1lRm9yU291cmNlVmFsdWVfKG5ld1ZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgKG5hbWVGaWVsZCA9IG5ldyBzdHVkaW8uVGV4dEZpZWxkKCduYW1lJywge1xuICAgICAgICAgIG5ld0dyb3VwOiB0cnVlLFxuICAgICAgICAgIHRpdGxlOiAnTmFtZScsXG4gICAgICAgICAgaGVscFRleHQ6ICdVc2VkIHdoZW4gZ2VuZXJhdGluZyBaSVAgZmlsZXMuJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHROYW1lRm9yU291cmNlVmFsdWVfKHt9KVxuICAgICAgICB9KSksXG4gICAgICAgIG5ldyBzdHVkaW8uRW51bUZpZWxkKCd0aGVtZScsIHtcbiAgICAgICAgICB0aXRsZTogJ1RoZW1lJyxcbiAgICAgICAgICBidXR0b25zOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHsgaWQ6ICdsaWdodCcsIHRpdGxlOiAnTGlnaHQnIH0sXG4gICAgICAgICAgICB7IGlkOiAnZGFyaycsIHRpdGxlOiAnRGFyaycgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdjdXN0b20nLCB0aXRsZTogJ0N1c3RvbScgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnbGlnaHQnXG4gICAgICAgIH0pLFxuICAgICAgICAoY3VzdG9tQ29sb3JGaWVsZCA9IG5ldyBzdHVkaW8uQ29sb3JGaWVsZCgnY29sb3InLCB7XG4gICAgICAgICAgdGl0bGU6ICdDb2xvcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAncmdiYSgzMywgMTUwLCAyNDMsIC42KScsXG4gICAgICAgICAgYWxwaGE6IHRydWVcbiAgICAgICAgfSkpXG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5mb3JtLm9uQ2hhbmdlKGZpZWxkID0+IHtcbiAgICAgIGxldCB2YWx1ZXMgPSB0aGlzLmZvcm0uZ2V0VmFsdWVzKCk7XG4gICAgICAkKCcub3V0cHV0cy1wYW5lbCcpLmF0dHIoJ2RhdGEtdGhlbWUnLCB2YWx1ZXMudGhlbWUpO1xuICAgICAgY3VzdG9tQ29sb3JGaWVsZC5zZXRFbmFibGVkKHZhbHVlcy50aGVtZSA9PSAnY3VzdG9tJyk7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGVEZWJvdW5jZWRfKCk7XG4gICAgfSk7XG4gIH1cblxuICByZWdlbmVyYXRlKCkge1xuICAgIGxldCB2YWx1ZXMgPSB0aGlzLmZvcm0uZ2V0VmFsdWVzKCk7XG5cbiAgICB0aGlzLnppcHBlci5jbGVhcigpO1xuICAgIHRoaXMuemlwcGVyLnNldFppcEZpbGVuYW1lKGAke3ZhbHVlcy5uYW1lfS56aXBgKTtcblxuICAgIHRoaXMuZGVuc2l0aWVzLmZvckVhY2goZGVuc2l0eSA9PiB7XG4gICAgICBsZXQgbXVsdCA9IHN0dWRpby5VdGlsLmdldE11bHRCYXNlTWRwaShkZW5zaXR5KTtcbiAgICAgIGxldCBpY29uU2l6ZSA9IHN0dWRpby5VdGlsLm11bHRSb3VuZChJQ09OX1NJWkUsIG11bHQpO1xuXG4gICAgICBsZXQgb3V0Q3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KGljb25TaXplKTtcbiAgICAgIGxldCB0bXBDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuXG4gICAgICBpZiAodmFsdWVzLnNvdXJjZS5jdHgpIHtcbiAgICAgICAgbGV0IHNyY0N0eCA9IHZhbHVlcy5zb3VyY2UuY3R4O1xuICAgICAgICBpbWFnZWxpYi5EcmF3aW5nLmRyYXdDZW50ZXJJbnNpZGUoXG4gICAgICAgICAgICB0bXBDdHgsXG4gICAgICAgICAgICBzcmNDdHgsXG4gICAgICAgICAgICBzdHVkaW8uVXRpbC5tdWx0KFRBUkdFVF9SRUNULCBtdWx0KSxcbiAgICAgICAgICAgIHt4OiAwLCB5OiAwLCB3OiBzcmNDdHguY2FudmFzLndpZHRoLCBoOiBzcmNDdHguY2FudmFzLmhlaWdodH0pO1xuICAgICAgfVxuXG4gICAgICBsZXQgY29sb3IgPSB2YWx1ZXMuY29sb3I7XG4gICAgICBpZiAodmFsdWVzLnRoZW1lID09ICdsaWdodCcpIHtcbiAgICAgICAgY29sb3IgPSB0aW55Y29sb3IoJ3JnYmEoMCwgMCwgMCwgLjU0KScpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZXMudGhlbWUgPT0gJ2RhcmsnKSB7XG4gICAgICAgIGNvbG9yID0gdGlueWNvbG9yKCcjZmZmJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBhbHBoYSA9IGNvbG9yLmdldEFscGhhKCk7XG4gICAgICBjb2xvci5zZXRBbHBoYSgxKTtcblxuICAgICAgaW1hZ2VsaWIuRWZmZWN0cy5meChbXG4gICAgICAgIHtlZmZlY3Q6ICdmaWxsLWNvbG9yJywgY29sb3I6IGNvbG9yLnRvUmdiU3RyaW5nKCksIG9wYWNpdHk6IGFscGhhfVxuICAgICAgXSwgb3V0Q3R4LCB0bXBDdHgsIGljb25TaXplKTtcblxuICAgICAgY29sb3Iuc2V0QWxwaGEoYWxwaGEpO1xuXG4gICAgICB0aGlzLnppcHBlci5hZGQoe1xuICAgICAgICBuYW1lOiBgcmVzL2RyYXdhYmxlLSR7ZGVuc2l0eX0vJHt2YWx1ZXMubmFtZX0ucG5nYCxcbiAgICAgICAgY2FudmFzOiBvdXRDdHguY2FudmFzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zZXRJbWFnZUZvclNsb3RfKGRlbnNpdHksIG91dEN0eC5jYW52YXMudG9EYXRhVVJMKCkpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtzdHVkaW99IGZyb20gJy4uL3N0dWRpbyc7XG5pbXBvcnQge2ltYWdlbGlifSBmcm9tICcuLi9pbWFnZWxpYic7XG5pbXBvcnQge0Jhc2VHZW5lcmF0b3J9IGZyb20gJy4vQmFzZUdlbmVyYXRvcic7XG5cbmNvbnN0IElDT05fU0laRSA9IHsgdzogNDgsIGg6IDQ4IH07XG5jb25zdCBUQVJHRVRfUkVDVCA9IHsgeDogMTIsIHk6IDEyLCB3OiAyNCwgaDogMjQgfTtcblxuY29uc3QgR1JJRF9PVkVSTEFZX1NWRyA9XG4gICAgYDxzdmcgd2lkdGg9XCI0OFwiIGhlaWdodD1cIjQ4XCIgdmlld0JveD1cIjAgMCA0OCA0OFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIjEyXCIgeT1cIjEyXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIvPlxuICAgICAgICA8L2c+XG4gICAgPC9zdmc+YDtcblxuZXhwb3J0IGNsYXNzIEFwcFNob3J0Y3V0SWNvbkdlbmVyYXRvciBleHRlbmRzIEJhc2VHZW5lcmF0b3Ige1xuICBnZXQgZ3JpZE92ZXJsYXlTdmcoKSB7XG4gICAgcmV0dXJuIEdSSURfT1ZFUkxBWV9TVkc7XG4gIH1cblxuICBzZXR1cEZvcm0oKSB7XG4gICAgc3VwZXIuc2V0dXBGb3JtKCk7XG5cbiAgICBsZXQgZGVmYXVsdE5hbWVGb3JTb3VyY2VWYWx1ZV8gPSB2ID0+IHtcbiAgICAgIGxldCBuYW1lID0gc3R1ZGlvLlV0aWwuc2FuaXRpemVSZXNvdXJjZU5hbWUodi5uYW1lIHx8ICdleGFtcGxlJyk7XG4gICAgICByZXR1cm4gYGljX3Nob3J0Y3V0XyR7bmFtZX1gO1xuICAgIH07XG5cbiAgICBsZXQgbmFtZUZpZWxkLCBjdXN0b21Db2xvckZpZWxkO1xuICAgIHRoaXMuZm9ybSA9IG5ldyBzdHVkaW8uRm9ybSh7XG4gICAgICBpZDogJ2ljb25mb3JtJyxcbiAgICAgIGNvbnRhaW5lcjogJyNpbnB1dHMtZm9ybScsXG4gICAgICBmaWVsZHM6IFtcbiAgICAgICAgbmV3IHN0dWRpby5JbWFnZUZpZWxkKCdzb3VyY2UnLCB7XG4gICAgICAgICAgdGl0bGU6ICdTb3VyY2UnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnTXVzdCBiZSB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgbWF4RmluYWxTaXplOiB7IHc6IDEyOCwgaDogMTI4IH0sXG4gICAgICAgICAgY2xpcGFydE5vVHJpbVBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlQ2xpcGFydDogJ3NlYXJjaCcsXG4gICAgICAgICAgZHJvcFRhcmdldDogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICBvbkNoYW5nZTogKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWVGaWVsZC5nZXRWYWx1ZSgpID09IGRlZmF1bHROYW1lRm9yU291cmNlVmFsdWVfKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICBuYW1lRmllbGQuc2V0VmFsdWUoZGVmYXVsdE5hbWVGb3JTb3VyY2VWYWx1ZV8obmV3VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICAobmFtZUZpZWxkID0gbmV3IHN0dWRpby5UZXh0RmllbGQoJ25hbWUnLCB7XG4gICAgICAgICAgbmV3R3JvdXA6IHRydWUsXG4gICAgICAgICAgdGl0bGU6ICdOYW1lJyxcbiAgICAgICAgICBoZWxwVGV4dDogJ1VzZWQgd2hlbiBnZW5lcmF0aW5nIFpJUCBmaWxlcy4nLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdE5hbWVGb3JTb3VyY2VWYWx1ZV8oe30pXG4gICAgICAgIH0pKSxcbiAgICAgICAgbmV3IHN0dWRpby5Db2xvckZpZWxkKCdmb3JlQ29sb3InLCB7XG4gICAgICAgICAgdGl0bGU6ICdDb2xvcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnIzQ0OGFmZidcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBzdHVkaW8uQ29sb3JGaWVsZCgnYmFja0NvbG9yJywge1xuICAgICAgICAgIHRpdGxlOiAnQmFja2dyb3VuZCBjb2xvcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnI2Y1ZjVmNSdcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICB9KTtcbiAgICB0aGlzLmZvcm0ub25DaGFuZ2UoKCkgPT4gdGhpcy5yZWdlbmVyYXRlRGVib3VuY2VkXygpKTtcbiAgfVxuXG4gIHJlZ2VuZXJhdGUoKSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcblxuICAgIHRoaXMuemlwcGVyLmNsZWFyKCk7XG4gICAgdGhpcy56aXBwZXIuc2V0WmlwRmlsZW5hbWUoYCR7dmFsdWVzLm5hbWV9LnppcGApO1xuXG4gICAgdGhpcy5kZW5zaXRpZXMuZm9yRWFjaChkZW5zaXR5ID0+IHtcbiAgICAgIGxldCBtdWx0ID0gc3R1ZGlvLlV0aWwuZ2V0TXVsdEJhc2VNZHBpKGRlbnNpdHkpO1xuICAgICAgbGV0IGljb25TaXplID0gc3R1ZGlvLlV0aWwubXVsdFJvdW5kKElDT05fU0laRSwgbXVsdCk7XG5cbiAgICAgIGxldCBvdXRDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuICAgICAgbGV0IHRtcEN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChpY29uU2l6ZSk7XG5cbiAgICAgIG91dEN0eC5zYXZlKCk7XG4gICAgICBvdXRDdHguYmVnaW5QYXRoKCk7XG4gICAgICBvdXRDdHguYXJjKDI0ICogbXVsdCwgMjQgKiBtdWx0LCAyMiAqIG11bHQsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgIG91dEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHZhbHVlcy5iYWNrQ29sb3Iuc2V0QWxwaGEoMSk7XG4gICAgICBvdXRDdHguZmlsbFN0eWxlID0gdmFsdWVzLmJhY2tDb2xvci50b1JnYlN0cmluZygpO1xuICAgICAgb3V0Q3R4LmZpbGwoKTtcbiAgICAgIG91dEN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmICh2YWx1ZXMuc291cmNlLmN0eCkge1xuICAgICAgICBsZXQgc3JjQ3R4ID0gdmFsdWVzLnNvdXJjZS5jdHg7XG4gICAgICAgIGltYWdlbGliLkRyYXdpbmcuZHJhd0NlbnRlckluc2lkZShcbiAgICAgICAgICAgIHRtcEN0eCxcbiAgICAgICAgICAgIHNyY0N0eCxcbiAgICAgICAgICAgIHN0dWRpby5VdGlsLm11bHQoVEFSR0VUX1JFQ1QsIG11bHQpLFxuICAgICAgICAgICAge3g6IDAsIHk6IDAsIHc6IHNyY0N0eC5jYW52YXMud2lkdGgsIGg6IHNyY0N0eC5jYW52YXMuaGVpZ2h0fSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlcy5mb3JlQ29sb3Iuc2V0QWxwaGEoMSk7XG4gICAgICBpbWFnZWxpYi5FZmZlY3RzLmZ4KFtcbiAgICAgICAge2VmZmVjdDogJ2ZpbGwtY29sb3InLCBjb2xvcjogdmFsdWVzLmZvcmVDb2xvci50b1JnYlN0cmluZygpfVxuICAgICAgXSwgb3V0Q3R4LCB0bXBDdHgsIGljb25TaXplKTtcblxuICAgICAgdGhpcy56aXBwZXIuYWRkKHtcbiAgICAgICAgbmFtZTogYHJlcy9kcmF3YWJsZS0ke2RlbnNpdHl9LyR7dmFsdWVzLm5hbWV9LnBuZ2AsXG4gICAgICAgIGNhbnZhczogb3V0Q3R4LmNhbnZhc1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2V0SW1hZ2VGb3JTbG90XyhkZW5zaXR5LCBvdXRDdHguY2FudmFzLnRvRGF0YVVSTCgpKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3R1ZGlvfSBmcm9tICcuLi9zdHVkaW8nO1xuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vaW1hZ2VsaWInO1xuXG5jb25zdCBERU5TSVRJRVMgPSBuZXcgU2V0KFsneHh4aGRwaScsICd4eGhkcGknLCAneGhkcGknLCAnaGRwaScsICdtZHBpJ10pO1xuY29uc3QgUkVHRU5FUkFURV9ERUJPVU5DRV9USU1FID0gMjAwO1xuXG5jb25zdCBJQ09OX1NJWkUgPSB7IHc6IDI0LCBoOiAyNCB9O1xuY29uc3QgVEFSR0VUX1JFQ1QgPSB7IHg6IDAsIHk6IDAsIHc6IDI0LCBoOiAyNCB9O1xuXG5cbmV4cG9ydCBjbGFzcyBCYXNlR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZWdlbmVyYXRlRGVib3VuY2VkXyA9IHN0dWRpby5VdGlsLmRlYm91bmNlKFxuICAgICAgICBSRUdFTkVSQVRFX0RFQk9VTkNFX1RJTUUsXG4gICAgICAgICgpID0+IHRoaXMucmVnZW5lcmF0ZSgpKTtcblxuICAgIHRoaXMuc2V0dXBaaXBwZXIoKTtcbiAgICB0aGlzLnNldHVwT3V0cHV0VWkoKTtcbiAgICB0aGlzLnNldHVwT3V0cHV0U2xvdHMoKTtcbiAgICB0aGlzLnNldHVwRm9ybSgpO1xuICAgIHN0dWRpby5IYXNoLmJpbmRGb3JtVG9Eb2N1bWVudEhhc2godGhpcy5mb3JtKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVnZW5lcmF0ZSgpLCAwKTtcbiAgfVxuXG4gIHNldHVwWmlwcGVyKCkge1xuICAgIHRoaXMuemlwcGVyID0gc3R1ZGlvLlppcC5jcmVhdGVEb3dubG9hZGlmeVppcEJ1dHRvbigkKCcjZG93bmxvYWQtemlwLWJ1dHRvbicpKTtcbiAgfVxuXG4gIHNldHVwT3V0cHV0VWkoKSB7XG4gICAgLy8gZ3JpZCB0b2dnbGVcbiAgICBpZiAodGhpcy5ncmlkT3ZlcmxheVN2Zykge1xuICAgICAgbGV0IGRlZmF1bHRDaGVja2VkID0gKCdhc3NldFN0dWRpb1Nob3dHcmlkJyBpbiBsb2NhbFN0b3JhZ2UpXG4gICAgICAgICAgPyBsb2NhbFN0b3JhZ2UuYXNzZXRTdHVkaW9TaG93R3JpZCA9PT0gJ3RydWUnXG4gICAgICAgICAgOiB0cnVlO1xuICAgICAgJCgnI2dyaWQtdG9nZ2xlJykucHJvcCgnY2hlY2tlZCcsIGRlZmF1bHRDaGVja2VkKTtcbiAgICAgICQoJy5vdXRwdXRzLXBhbmVsJykudG9nZ2xlQ2xhc3MoJ3Nob3ctZ3JpZCcsIGRlZmF1bHRDaGVja2VkKTtcblxuICAgICAgJCgnI2dyaWQtdG9nZ2xlJykuY2xpY2soZXYgPT4ge1xuICAgICAgICBsZXQgY2hlY2tlZCA9ICQoZXYuY3VycmVudFRhcmdldCkuaXMoJzpjaGVja2VkJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5hc3NldFN0dWRpb1Nob3dHcmlkID0gU3RyaW5nKGNoZWNrZWQpO1xuICAgICAgICAkKCcub3V0cHV0cy1wYW5lbCcpLnRvZ2dsZUNsYXNzKCdzaG93LWdyaWQnLCBjaGVja2VkKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKCcjZ3JpZC10b2dnbGUtY29udGFpbmVyJykuaGlkZSgpO1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgc2xvdHMgdG9nZ2xlXG4gICAgJCgnLm91dHB1dHMtYWRkaXRpb25hbC10b2dnbGUnKS5jbGljaygoKSA9PiAkKCcub3V0cHV0cy1wYW5lbCcpLnRvZ2dsZUNsYXNzKCdpcy1zaG93aW5nLWFsbCcpKTtcbiAgfVxuXG4gIHNldHVwT3V0cHV0U2xvdHMoKSB7XG4gICAgdGhpcy5kZW5zaXRpZXMuZm9yRWFjaChkZW5zaXR5ID0+IHtcbiAgICAgIHRoaXMuY3JlYXRlSW1hZ2VPdXRwdXRTbG90Xyh7XG4gICAgICAgIGNvbnRhaW5lcjogKGRlbnNpdHkgPT0gJ3h4eGhkcGknKSA/ICQoJy5vdXRwdXRzLW1haW4nKSA6ICQoJy5vdXRwdXRzLWFkZGl0aW9uYWwnKSxcbiAgICAgICAgaWQ6IGRlbnNpdHksXG4gICAgICAgIGxhYmVsOiBkZW5zaXR5XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBkZW5zaXRpZXMoKSB7XG4gICAgcmV0dXJuIERFTlNJVElFUztcbiAgfVxuXG4gIGNyZWF0ZUltYWdlT3V0cHV0U2xvdF8ocGFyYW1zKSB7XG4gICAgbGV0ICRpbWFnZUNvbnRhaW5lciA9ICQoJzxkaXY+JylcbiAgICAgICAgLmFkZENsYXNzKCdvdXRwdXRzLWltYWdlLWNvbnRhaW5lcicpXG4gICAgICAgIC5hcHBlbmQoJCgnPGltZz4nKVxuICAgICAgICAgIC5hZGRDbGFzcygnb3V0cHV0cy1pbWFnZScpXG4gICAgICAgICAgLmF0dHIoJ2RhdGEtaWQnLCBgb3V0LWljb24tJHtwYXJhbXMuaWR9YCkpO1xuXG4gICAgaWYgKHRoaXMuZ3JpZE92ZXJsYXlTdmcpIHtcbiAgICAgICQoJzxkaXY+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ291dHB1dHMtaW1hZ2Utb3ZlcmxheScpXG4gICAgICAgICAgLmh0bWwodGhpcy5ncmlkT3ZlcmxheVN2ZylcbiAgICAgICAgICAuYXBwZW5kVG8oJGltYWdlQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBsZXQgJGJsb2NrID0gJCgnPGRpdj4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ291dHB1dHMtaW1hZ2UtYmxvY2snKVxuICAgICAgICAuYXBwZW5kKCQoJzxkaXY+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ291dHB1dHMtbGFiZWwnKVxuICAgICAgICAgIC50ZXh0KHBhcmFtcy5sYWJlbCkpXG4gICAgICAgIC5hcHBlbmQoJGltYWdlQ29udGFpbmVyKVxuICAgICAgICAuYXBwZW5kVG8ocGFyYW1zLmNvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gJGJsb2NrO1xuICB9XG5cbiAgc2V0SW1hZ2VGb3JTbG90XyhpZCwgdXJsKSB7XG4gICAgc3R1ZGlvLlV0aWwubG9hZEltYWdlRnJvbVVyaSh1cmwpXG4gICAgICAgIC50aGVuKGltZyA9PiAkKGBbZGF0YS1pZD1cIm91dC1pY29uLSR7aWR9XCJdYCkuYXR0cignc3JjJywgaW1nLnNyYykpO1xuICB9XG5cbiAgc2V0dXBGb3JtKCkge1xuICB9XG5cbiAgcmVnZW5lcmF0ZSgpIHtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3R1ZGlvfSBmcm9tICcuLi9zdHVkaW8nO1xuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vaW1hZ2VsaWInO1xuaW1wb3J0IHtCYXNlR2VuZXJhdG9yfSBmcm9tICcuL0Jhc2VHZW5lcmF0b3InO1xuXG5jb25zdCBJQ09OX1NJWkUgPSB7dzogMjQsIGg6IDI0fTtcbmNvbnN0IFRBUkdFVF9SRUNUID0ge3g6IDEsIHk6IDEsIHc6IDIyLCBoOiAyMn07XG5cbmV4cG9ydCBjbGFzcyBHZW5lcmljSWNvbkdlbmVyYXRvciBleHRlbmRzIEJhc2VHZW5lcmF0b3Ige1xuICBzZXR1cEZvcm0oKSB7XG4gICAgc3VwZXIuc2V0dXBGb3JtKCk7XG5cbiAgICBsZXQgZGVmYXVsdE5hbWVGb3JTb3VyY2VWYWx1ZV8gPSB2ID0+IHtcbiAgICAgIGxldCBuYW1lID0gc3R1ZGlvLlV0aWwuc2FuaXRpemVSZXNvdXJjZU5hbWUodi5uYW1lIHx8ICdleGFtcGxlJyk7XG4gICAgICByZXR1cm4gYGljXyR7bmFtZX1gO1xuICAgIH07XG5cbiAgICBsZXQgbmFtZUZpZWxkO1xuICAgIHRoaXMuZm9ybSA9IG5ldyBzdHVkaW8uRm9ybSh7XG4gICAgICBpZDogJ2ljb25mb3JtJyxcbiAgICAgIGNvbnRhaW5lcjogJyNpbnB1dHMtZm9ybScsXG4gICAgICBmaWVsZHM6IFtcbiAgICAgICAgbmV3IHN0dWRpby5JbWFnZUZpZWxkKCdzb3VyY2UnLCB7XG4gICAgICAgICAgdGl0bGU6ICdTb3VyY2UnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnTXVzdCBiZSB0cmFuc3BhcmVudCcsXG4gICAgICAgICAgbWF4RmluYWxTaXplOiB7IHc6IDcyMCwgaDogNzIwIH0sIC8vIG1heCByZW5kZXIgc2l6ZSwgZm9yIFNWR3NcbiAgICAgICAgICBkZWZhdWx0VmFsdWVDbGlwYXJ0OiAnYWNfdW5pdCcsXG4gICAgICAgICAgZHJvcFRhcmdldDogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICBvbkNoYW5nZTogKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWVGaWVsZC5nZXRWYWx1ZSgpID09IGRlZmF1bHROYW1lRm9yU291cmNlVmFsdWVfKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICBuYW1lRmllbGQuc2V0VmFsdWUoZGVmYXVsdE5hbWVGb3JTb3VyY2VWYWx1ZV8obmV3VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgc3R1ZGlvLlJhbmdlRmllbGQoJ3NpemUnLCB7XG4gICAgICAgICAgbmV3R3JvdXA6IHRydWUsXG4gICAgICAgICAgdGl0bGU6ICdBc3NldCBzaXplJyxcbiAgICAgICAgICBoZWxwVGV4dDogJ1NpemUgb2YgdGhlIGZpbmFsIGFzc2V0JyxcbiAgICAgICAgICBtaW46IDQsXG4gICAgICAgICAgbWF4OiAyMDAsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAzMixcbiAgICAgICAgICB0ZXh0Rm46IGQgPT4gYCR7ZH1kcGAsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgc3R1ZGlvLlJhbmdlRmllbGQoJ3BhZGRpbmcnLCB7XG4gICAgICAgICAgdGl0bGU6ICdBc3NldCBwYWRkaW5nJyxcbiAgICAgICAgICBoZWxwVGV4dDogJ1BhZGRpbmcgYXJvdW5kIHRoZSBpY29uIGFzc2V0JyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IDgsXG4gICAgICAgICAgdGV4dEZuOiBkID0+IGAke2R9ZHBgLFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHN0dWRpby5Db2xvckZpZWxkKCdjb2xvcicsIHtcbiAgICAgICAgICB0aXRsZTogJ0NvbG9yJyxcbiAgICAgICAgICBoZWxwVGV4dDogJ1NldCB0byB0cmFuc3BhcmVudCB0byByZXRhaW4gb3JpZ2luYWwgY29sb3JzJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdyZ2JhKDAsIDAsIDAsIDAuNTQpJyxcbiAgICAgICAgICBhbHBoYTogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgKG5hbWVGaWVsZCA9IG5ldyBzdHVkaW8uVGV4dEZpZWxkKCduYW1lJywge1xuICAgICAgICAgIHRpdGxlOiAnTmFtZScsXG4gICAgICAgICAgaGVscFRleHQ6ICdVc2VkIHdoZW4gZ2VuZXJhdGluZyBaSVAgZmlsZXMgYXMgdGhlIHJlc291cmNlIG5hbWUuJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHROYW1lRm9yU291cmNlVmFsdWVfKHt9KVxuICAgICAgICB9KSlcbiAgICAgIF1cbiAgICB9KTtcbiAgICB0aGlzLmZvcm0ub25DaGFuZ2UoZmllbGQgPT4gdGhpcy5yZWdlbmVyYXRlRGVib3VuY2VkXygpKTtcbiAgfVxuXG4gIHJlZ2VuZXJhdGUoKSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcblxuICAgIHRoaXMuemlwcGVyLmNsZWFyKCk7XG4gICAgdGhpcy56aXBwZXIuc2V0WmlwRmlsZW5hbWUoYCR7dmFsdWVzLm5hbWV9LnppcGApO1xuXG4gICAgdGhpcy5kZW5zaXRpZXMuZm9yRWFjaChkZW5zaXR5ID0+IHtcbiAgICAgIGxldCBtdWx0ID0gc3R1ZGlvLlV0aWwuZ2V0TXVsdEJhc2VNZHBpKGRlbnNpdHkpO1xuICAgICAgbGV0IHRvdGFsU2l6ZSA9IHZhbHVlcy5zaXplO1xuICAgICAgbGV0IHBhZGRpbmcgPSBNYXRoLm1pbih2YWx1ZXMuc2l6ZSAvIDIgLSAxLCB2YWx1ZXMucGFkZGluZyk7XG4gICAgICBsZXQgaWNvblNpemUgPSBzdHVkaW8uVXRpbC5tdWx0Um91bmQoXG4gICAgICAgICAge3c6IHRvdGFsU2l6ZSwgaDogdG90YWxTaXplfSwgbXVsdCk7XG4gICAgICBsZXQgdGFyZ2V0UmVjdCA9IHN0dWRpby5VdGlsLm11bHRSb3VuZChcbiAgICAgICAgICB7eDogcGFkZGluZywgeTogcGFkZGluZywgdzogdG90YWxTaXplIC0gcGFkZGluZyAqIDIsIGg6IHRvdGFsU2l6ZSAtIHBhZGRpbmcgKiAyfSwgbXVsdCk7XG5cbiAgICAgIGxldCBvdXRDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuICAgICAgbGV0IHRtcEN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChpY29uU2l6ZSk7XG5cbiAgICAgIGlmICh2YWx1ZXMuc291cmNlLmN0eCkge1xuICAgICAgICBsZXQgc3JjQ3R4ID0gdmFsdWVzLnNvdXJjZS5jdHg7XG4gICAgICAgIGltYWdlbGliLkRyYXdpbmcuZHJhd0NlbnRlckluc2lkZShcbiAgICAgICAgICAgIHRtcEN0eCxcbiAgICAgICAgICAgIHNyY0N0eCxcbiAgICAgICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgICAgICB7eDogMCwgeTogMCwgdzogc3JjQ3R4LmNhbnZhcy53aWR0aCwgaDogc3JjQ3R4LmNhbnZhcy5oZWlnaHR9KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNvbG9yID0gdmFsdWVzLmNvbG9yO1xuICAgICAgbGV0IGFscGhhID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICAgIGlmIChhbHBoYSA+IDApIHtcbiAgICAgICAgY29sb3Iuc2V0QWxwaGEoMSk7XG5cbiAgICAgICAgaW1hZ2VsaWIuRWZmZWN0cy5meChbXG4gICAgICAgICAge2VmZmVjdDogJ2ZpbGwtY29sb3InLCBjb2xvcjogY29sb3IudG9SZ2JTdHJpbmcoKSwgb3BhY2l0eTogYWxwaGF9XG4gICAgICAgIF0sIG91dEN0eCwgdG1wQ3R4LCBpY29uU2l6ZSk7XG5cbiAgICAgICAgY29sb3Iuc2V0QWxwaGEoYWxwaGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0Q3R4LmRyYXdJbWFnZSh0bXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy56aXBwZXIuYWRkKHtcbiAgICAgICAgbmFtZTogYHJlcy9kcmF3YWJsZS0ke2RlbnNpdHl9LyR7dmFsdWVzLm5hbWV9LnBuZ2AsXG4gICAgICAgIGNhbnZhczogb3V0Q3R4LmNhbnZhc1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2V0SW1hZ2VGb3JTbG90XyhkZW5zaXR5LCBvdXRDdHguY2FudmFzLnRvRGF0YVVSTCgpKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3R1ZGlvfSBmcm9tICcuLi9zdHVkaW8nO1xuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vaW1hZ2VsaWInO1xuaW1wb3J0IHtCYXNlR2VuZXJhdG9yfSBmcm9tICcuL0Jhc2VHZW5lcmF0b3InO1xuXG5jb25zdCBJQ09OX1NJWkUgPSB7IHc6IDQ4LCBoOiA0OCB9O1xuXG5jb25zdCBUQVJHRVRfUkVDVFNfQllfU0hBUEUgPSB7XG4gIG5vbmU6IHsgeDogIDMsIHk6ICAzLCB3OiAgNDIsIGg6ICA0MiB9LFxuICBjaXJjbGU6IHsgeDogIDIsIHk6ICAyLCB3OiAgNDQsIGg6ICA0NCB9LFxuICBzcXVhcmU6IHsgeDogIDUsIHk6ICA1LCB3OiAgMzgsIGg6ICAzOCB9LFxuICB2cmVjdDogeyB4OiAgOCwgeTogIDIsIHc6ICAzMiwgaDogIDQ0IH0sXG4gIGhyZWN0OiB7IHg6ICAyLCB5OiAgOCwgdzogIDQ0LCBoOiAgMzIgfSxcbn07XG5cbmNvbnN0IEdSSURfT1ZFUkxBWV9TVkcgPVxuICAgIGA8c3ZnIHdpZHRoPVwiNDhcIiBoZWlnaHQ9XCI0OFwiIHZpZXdCb3g9XCIwIDAgNDggNDhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiNDRcIiByeD1cIjNcIi8+XG4gICAgICAgICAgICA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIjVcIiB5PVwiNVwiIHdpZHRoPVwiMzhcIiBoZWlnaHQ9XCIzOFwiIHJ4PVwiM1wiLz5cbiAgICAgICAgICAgIDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiMlwiIHk9XCI4XCIgd2lkdGg9XCI0NFwiIGhlaWdodD1cIjMyXCIgcng9XCIzXCIvPlxuICAgICAgICAgICAgPGNpcmNsZSB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgY3g9XCIyNFwiIGN5PVwiMjRcIiByPVwiMTBcIi8+XG4gICAgICAgICAgICA8Y2lyY2xlIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiBjeD1cIjI0XCIgY3k9XCIyNFwiIHI9XCIyMlwiLz5cbiAgICAgICAgICAgIDxwYXRoIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiBkPVwiTTAgNDhMNDggME0wIDBsNDggNDhNMjQgNDhWME0xNyAwdjQ4TTMxIDB2NDhNNDggMjRIME0wIDMxaDQ4TTAgMTdoNDhcIi8+XG4gICAgICAgIDwvZz5cbiAgICA8L3N2Zz5gO1xuXG5cbmNvbnN0IERFRkFVTFRfRUZGRUNUX09QVElPTlMgPSBbXG4gIHsgaWQ6ICdub25lJywgdGl0bGU6ICdOb25lJyB9LFxuICB7IGlkOiAnZWxldmF0ZScsIHRpdGxlOiAnRWxldmF0ZScgfSxcbiAgeyBpZDogJ3NoYWRvdycsIHRpdGxlOiAnQ2FzdCBzaGFkb3cnIH0sXG4gIHsgaWQ6ICdzY29yZScsIHRpdGxlOiAnU2NvcmUnIH1cbl07XG5cblxuY29uc3QgTk9fU0hBUEVfRUZGRUNUX09QVElPTlMgPSBbXG4gIHsgaWQ6ICdub25lJywgdGl0bGU6ICdOb25lJyB9LFxuICB7IGlkOiAnc2NvcmUnLCB0aXRsZTogJ1Njb3JlJyB9XG5dO1xuXG5cbmV4cG9ydCBjbGFzcyBMYXVuY2hlckljb25HZW5lcmF0b3IgZXh0ZW5kcyBCYXNlR2VuZXJhdG9yIHtcbiAgZ2V0IGRlbnNpdGllcygpIHtcbiAgICByZXR1cm4gbmV3IFNldChbJ3h4eGhkcGknIC8qIG11c3QgYmUgZmlyc3QgKi8sICd3ZWInLCAneHhoZHBpJywgJ3hoZHBpJywgJ2hkcGknLCAnbWRwaSddKTtcbiAgfVxuXG4gIGdldCBncmlkT3ZlcmxheVN2ZygpIHtcbiAgICByZXR1cm4gR1JJRF9PVkVSTEFZX1NWRztcbiAgfVxuXG4gIHNldHVwRm9ybSgpIHtcbiAgICBsZXQgYmFja0NvbG9yVHlwZSwgYmFja0NvbG9yRmllbGQsIGJhY2tHcmFkaWVudEZpZWxkLCBiYWNrR3JhZGllbnREaXJlY3Rpb24sIGVmZmVjdHNGaWVsZDtcbiAgICBsZXQgc2hhZG93Q29sb3JGaWVsZCwgc2hhZG93QWxwaGFGaWVsZDtcbiAgICB0aGlzLmZvcm0gPSBuZXcgc3R1ZGlvLkZvcm0oe1xuICAgICAgaWQ6ICdpY29uZm9ybScsXG4gICAgICBjb250YWluZXI6ICcjaW5wdXRzLWZvcm0nLFxuICAgICAgZmllbGRzOiBbXG4gICAgICAgIG5ldyBzdHVkaW8uSW1hZ2VGaWVsZCgnZm9yZWdyb3VuZCcsIHtcbiAgICAgICAgICB0aXRsZTogJ0ZvcmVncm91bmQnLFxuICAgICAgICAgIG1heEZpbmFsU2l6ZTogeyB3OiA3MjAsIGg6IDcyMCB9LCAvLyBtYXggcmVuZGVyIHNpemUsIGZvciBTVkdzXG4gICAgICAgICAgZGVmYXVsdFZhbHVlVHJpbTogMSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWVQYWRkaW5nOiAuMjUsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlVG9wOiAwLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZUxlZnQ6IDAsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlQ2xpcGFydDogJ2FuZHJvaWQnLFxuICAgICAgICAgIGRyb3BUYXJnZXQ6IGRvY3VtZW50LmJvZHlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBzdHVkaW8uQ29sb3JGaWVsZCgnZm9yZUNvbG9yJywge1xuICAgICAgICAgIG5ld0dyb3VwOiB0cnVlLFxuICAgICAgICAgIHRpdGxlOiAnQ29sb3InLFxuICAgICAgICAgIGhlbHBUZXh0OiAnU2V0IHRvIHRyYW5zcGFyZW50IHRvIHVzZSBvcmlnaW5hbCBjb2xvcnMnLFxuICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ3JnYmEoOTYsIDEyNSwgMTM5LCAwKSdcbiAgICAgICAgfSksXG4gICAgICAgIChiYWNrQ29sb3JUeXBlID0gbmV3IHN0dWRpby5FbnVtRmllbGQoJ2JhY2tncm91bmRUeXBlJywge1xuICAgICAgICAgIHRpdGxlOiAnQmFja2dyb3VuZCB0eXBlJyxcbiAgICAgICAgICBidXR0b25zOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHsgaWQ6ICdzb2xpZCcsIHRpdGxlOiAnU29saWQnIH0sXG4gICAgICAgICAgICB7IGlkOiAnZ3JhZGllbnQnLCB0aXRsZTogJ0dyYWRpZW50JyB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdzb2xpZCcsXG4gICAgICAgICAgb25DaGFuZ2U6IG5ld1ZhbHVlID0+IHtcbiAgICAgICAgICAgIGJhY2tDb2xvckZpZWxkLnNldEVuYWJsZWQobmV3VmFsdWUgPT0gJ3NvbGlkJyk7XG4gICAgICAgICAgICBiYWNrR3JhZGllbnRGaWVsZC5zZXRFbmFibGVkKG5ld1ZhbHVlID09ICdncmFkaWVudCcpO1xuICAgICAgICAgICAgYmFja0dyYWRpZW50RGlyZWN0aW9uLnNldEVuYWJsZWQobmV3VmFsdWUgPT0gJ2dyYWRpZW50JylcbiAgICAgICAgICB9XG4gICAgICAgIH0pKSxcbiAgICAgICAgKGJhY2tDb2xvckZpZWxkID0gbmV3IHN0dWRpby5Db2xvckZpZWxkKCdiYWNrQ29sb3InLCB7XG4gICAgICAgICAgdGl0bGU6ICdCYWNrZ3JvdW5kIGNvbG9yJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcjNDQ4YWZmJ1xuICAgICAgICB9KSksXG4gICAgICAgIChiYWNrR3JhZGllbnRGaWVsZCA9IG5ldyBzdHVkaW8uR3JhZGllbnRGaWVsZCgnYmFja0dyYWRpZW50Jywge1xuICAgICAgICAgIHRpdGxlOiAnQmFja2dyb3VuZCBncmFkaWVudCcsXG4gICAgICAgICAgZGVmYXVsdEZyb206ICcjOWNiMmUxJyxcbiAgICAgICAgICBkZWZhdWx0VG86ICcjM2M0NzY5J1xuICAgICAgICB9KSksXG4gICAgICAgIChiYWNrR3JhZGllbnREaXJlY3Rpb24gPSBuZXcgc3R1ZGlvLkVudW1GaWVsZCgnYmFja0dyYWRpZW50RGlyZWN0aW9uJywge1xuICAgICAgICAgIHRpdGxlOiAnQmFja2dyb3VuZCBncmFkaWVudCBkaXJlY3Rpb24nLFxuICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHsgaWQ6ICd0LXQtYicsIHRpdGxlOiAnVG9wIHRvIGJvdHRvbScgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdsLXQtcicsIHRpdGxlOiAnTGVmdCB0byByaWdodCd9LFxuICAgICAgICAgICAgeyBpZDogJ2x0Yy10LXJiYycsIHRpdGxlOiAnTGVmdCB0b3AgY29ybmVyIHRvIHJpZ2h0IGJvdHRvbSBjb3JuZXInIH0sXG4gICAgICAgICAgICB7IGlkOiAnbGJjLXQtcnRjJywgdGl0bGU6ICdMZWZ0IGJvdHRvbSBjb3JuZXIgdG8gcmlnaHQgdG9wIGNvcm5lcicgfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ3QtdC1iJ1xuICAgICAgICB9KSksXG4gICAgICAgIG5ldyBzdHVkaW8uQm9vbGVhbkZpZWxkKCdjcm9wJywge1xuICAgICAgICAgIHRpdGxlOiAnU2NhbGluZycsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgICBvZmZUZXh0OiAnQ2VudGVyJyxcbiAgICAgICAgICBvblRleHQ6ICdDcm9wJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHN0dWRpby5FbnVtRmllbGQoJ2JhY2tncm91bmRTaGFwZScsIHtcbiAgICAgICAgICB0aXRsZTogJ1NoYXBlJyxcbiAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICB7IGlkOiAnbm9uZScsIHRpdGxlOiAnTm9uZScgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdzcXVhcmUnLCB0aXRsZTogJ1NxdWFyZScgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdjaXJjbGUnLCB0aXRsZTogJ0NpcmNsZScgfSxcbiAgICAgICAgICAgIHsgaWQ6ICd2cmVjdCcsIHRpdGxlOiAnVGFsbCByZWN0JyB9LFxuICAgICAgICAgICAgeyBpZDogJ2hyZWN0JywgdGl0bGU6ICdXaWRlIHJlY3QnIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ3NxdWFyZScsXG4gICAgICAgICAgb25DaGFuZ2U6IG5ld1ZhbHVlID0+IHtcbiAgICAgICAgICAgIGJhY2tDb2xvclR5cGUuc2V0RW5hYmxlZChuZXdWYWx1ZSAhPSAnbnVsbCcpO1xuICAgICAgICAgICAgYmFja0NvbG9yRmllbGQuc2V0RW5hYmxlZChuZXdWYWx1ZSAhPSAnbm9uZScgJiYgYmFja0NvbG9yVHlwZS5nZXRWYWx1ZSgpID09ICdzb2xpZCcpO1xuICAgICAgICAgICAgYmFja0dyYWRpZW50RmllbGQuc2V0RW5hYmxlZChuZXdWYWx1ZSAhPSAnbm9uZScgJiYgYmFja0NvbG9yVHlwZS5nZXRWYWx1ZSgpID09ICdncmFkaWVudCcpO1xuICAgICAgICAgICAgYmFja0dyYWRpZW50RGlyZWN0aW9uLnNldEVuYWJsZWQobmV3VmFsdWUgIT0gJ25vbmUnICYmIGJhY2tDb2xvclR5cGUuZ2V0VmFsdWUoKSA9PSAnZ3JhZGllbnQnKTtcbiAgICAgICAgICAgIGxldCBuZXdFZmZlY3RzT3B0aW9ucyA9IG5ld1ZhbHVlID09ICdub25lJ1xuICAgICAgICAgICAgICAgID8gTk9fU0hBUEVfRUZGRUNUX09QVElPTlNcbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfRUZGRUNUX09QVElPTlM7XG4gICAgICAgICAgICBpZiAoIW5ld0VmZmVjdHNPcHRpb25zLmZpbmQoZSA9PiBlLmlkID09IGVmZmVjdHNGaWVsZC5nZXRWYWx1ZSgpKSkge1xuICAgICAgICAgICAgICBlZmZlY3RzRmllbGQuc2V0VmFsdWUobmV3RWZmZWN0c09wdGlvbnNbMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWZmZWN0c0ZpZWxkLnNldE9wdGlvbnMobmV3RWZmZWN0c09wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIChlZmZlY3RzRmllbGQgPSBuZXcgc3R1ZGlvLkVudW1GaWVsZCgnZWZmZWN0cycsIHtcbiAgICAgICAgICB0aXRsZTogJ0VmZmVjdCcsXG4gICAgICAgICAgYnV0dG9uczogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25zOiBERUZBVUxUX0VGRkVDVF9PUFRJT05TLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ25vbmUnLFxuICAgICAgICAgIG9uQ2hhbmdlOiBuZXdWYWx1ZSA9PiB7XG4gICAgICAgICAgICBzaGFkb3dDb2xvckZpZWxkLnNldEVuYWJsZWQobmV3VmFsdWUgPT0gJ3NoYWRvdycpO1xuICAgICAgICAgICAgc2hhZG93QWxwaGFGaWVsZC5zZXRFbmFibGVkKG5ld1ZhbHVlID09ICdzaGFkb3cnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKSxcbiAgICAgICAgKHNoYWRvd0NvbG9yRmllbGQgPSBuZXcgc3R1ZGlvLkNvbG9yRmllbGQoJ3NoYWRvd0NvbG9yJywge1xuICAgICAgICAgIHRpdGxlOiAnU2hhZG93IGNvbG9yJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcjMDAwMDAwJ1xuICAgICAgICB9KSksXG4gICAgICAgIChzaGFkb3dBbHBoYUZpZWxkID0gbmV3IHN0dWRpby5SYW5nZUZpZWxkKCdzaGFkb3dBbHBoYScsIHtcbiAgICAgICAgICB0aXRsZTogXCJTaGFkb3cgYWxwaGFcIixcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgIHN0ZXA6IDAuMDEsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAwLjIsXG4gICAgICAgICAgc2hvd1RleHQ6IHRydWVcbiAgICAgICAgfSkpLFxuICAgICAgICBuZXcgc3R1ZGlvLlRleHRGaWVsZCgnbmFtZScsIHtcbiAgICAgICAgICB0aXRsZTogJ05hbWUnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ2ljX2xhdW5jaGVyJ1xuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pO1xuICAgIHRoaXMuZm9ybS5vbkNoYW5nZShmaWVsZCA9PiB0aGlzLnJlZ2VuZXJhdGVEZWJvdW5jZWRfKCkpO1xuICB9XG5cbiAgcmVnZW5lcmF0ZSgpIHtcbiAgICBsZXQgdmFsdWVzID0gdGhpcy5mb3JtLmdldFZhbHVlcygpO1xuXG4gICAgdGhpcy56aXBwZXIuY2xlYXIoKTtcbiAgICB0aGlzLnppcHBlci5zZXRaaXBGaWxlbmFtZShgJHt2YWx1ZXMubmFtZX0uemlwYCk7XG5cbiAgICBsZXQgeHh4aGRwaUN0eCA9IG51bGw7XG5cbiAgICB0aGlzLmRlbnNpdGllcy5mb3JFYWNoKGRlbnNpdHkgPT4ge1xuICAgICAgbGV0IGN0eDtcbiAgICAgIGlmIChkZW5zaXR5ID09ICd4eHhoZHBpJyB8fCBkZW5zaXR5ID09ICd3ZWInKSB7XG4gICAgICAgIGN0eCA9IHRoaXMucmVnZW5lcmF0ZVJhd0F0RGVuc2l0eV8oZGVuc2l0eSk7XG4gICAgICAgIGlmIChkZW5zaXR5ID09ICd4eHhoZHBpJykge1xuICAgICAgICAgIHh4eGhkcGlDdHggPSBjdHg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGp1c3Qgc2NhbGUgZG93biB4eHhoZHBpXG4gICAgICAgIGxldCBtdWx0ID0gc3R1ZGlvLlV0aWwuZ2V0TXVsdEJhc2VNZHBpKGRlbnNpdHkpO1xuICAgICAgICBsZXQgaWNvblNpemUgPSBzdHVkaW8uVXRpbC5tdWx0Um91bmQoSUNPTl9TSVpFLCBtdWx0KTtcbiAgICAgICAgY3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KGljb25TaXplKTtcbiAgICAgICAgaW1hZ2VsaWIuRHJhd2luZy5kcmF3SW1hZ2VTY2FsZWQoXG4gICAgICAgICAgICBjdHgsIHh4eGhkcGlDdHgsXG4gICAgICAgICAgICAwLCAwLCAxOTIsIDE5MixcbiAgICAgICAgICAgIDAsIDAsIGljb25TaXplLncsIGljb25TaXplLmgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnppcHBlci5hZGQoe1xuICAgICAgICBuYW1lOiAoZGVuc2l0eSA9PSAnd2ViJylcbiAgICAgICAgICAgID8gJ3dlYl9oaV9yZXNfNTEyLnBuZydcbiAgICAgICAgICAgIDogYHJlcy9taXBtYXAtJHtkZW5zaXR5fS8ke3ZhbHVlcy5uYW1lfS5wbmdgLFxuICAgICAgICBjYW52YXM6IGN0eC5jYW52YXNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldEltYWdlRm9yU2xvdF8oZGVuc2l0eSwgY3R4LmNhbnZhcy50b0RhdGFVUkwoKSk7XG4gICAgfSk7XG4gIH1cblxuICByZWdlbmVyYXRlUmF3QXREZW5zaXR5XyhkZW5zaXR5KSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcbiAgICBsZXQgZm9yZVNyY0N0eCA9IHZhbHVlcy5mb3JlZ3JvdW5kID8gdmFsdWVzLmZvcmVncm91bmQuY3R4IDogbnVsbDtcbiAgICBsZXQgbXVsdCA9IHN0dWRpby5VdGlsLmdldE11bHRCYXNlTWRwaShkZW5zaXR5KTtcbiAgICBpZiAoZGVuc2l0eSA9PSAnd2ViJykge1xuICAgICAgbXVsdCA9IDUxMiAvIDQ4O1xuICAgIH1cblxuICAgIGxldCBpY29uU2l6ZSA9IHN0dWRpby5VdGlsLm11bHRSb3VuZChJQ09OX1NJWkUsIG11bHQpO1xuICAgIGxldCB0YXJnZXRSZWN0ID0gVEFSR0VUX1JFQ1RTX0JZX1NIQVBFW3ZhbHVlcy5iYWNrZ3JvdW5kU2hhcGVdO1xuXG4gICAgbGV0IG91dEN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChpY29uU2l6ZSk7XG5cbiAgICBsZXQgcm91bmRSZWN0UGF0aF8gPSAoY3R4LCB7eCwgeSwgdywgaH0sIHIpID0+IHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHcgLSByLCB5KTtcbiAgICAgIGN0eC5hcmNUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByLCByKTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgICBjdHguYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCByKTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICAgIGN0eC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSByLCByKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIHIpO1xuICAgICAgY3R4LmFyY1RvKHgsIHksIHggKyByLCB5LCByKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9O1xuXG4gICAgbGV0IGJhY2tncm91bmRMYXllciA9IHtcbiAgICAgIC8vIGJhY2tncm91bmQgbGF5ZXJcbiAgICAgIGRyYXc6IGN0eCA9PiB7XG4gICAgICAgIGN0eC5zY2FsZShtdWx0LCBtdWx0KTtcblxuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IFRBUkdFVF9SRUNUU19CWV9TSEFQRVt2YWx1ZXMuYmFja2dyb3VuZFNoYXBlXTtcblxuICAgICAgICBpZiAodmFsdWVzLmJhY2tncm91bmRUeXBlID09ICdzb2xpZCcpIHtcbiAgICAgICAgICB2YWx1ZXMuYmFja0NvbG9yLnNldEFscGhhKDEpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZXMuYmFja0NvbG9yLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzLmJhY2tncm91bmRUeXBlID09ICdncmFkaWVudCcpIHtcbiAgICAgICAgICB2YWx1ZXMuYmFja0dyYWRpZW50LmZyb20uc2V0QWxwaGEoMSk7XG4gICAgICAgICAgdmFsdWVzLmJhY2tHcmFkaWVudC50by5zZXRBbHBoYSgxKTtcblxuICAgICAgICAgIGxldCBncmFkaWVudERpcmVjdGlvbiA9IHZhbHVlcy5iYWNrR3JhZGllbnREaXJlY3Rpb247XG4gICAgICAgICAgbGV0IGdyYWRpZW50O1xuXG4gICAgICAgICAgaWYgKGdyYWRpZW50RGlyZWN0aW9uID09ICdsdGMtdC1yYmMnKSB7XG4gICAgICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB0YXJnZXRSZWN0LncsIHRhcmdldFJlY3QuaCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChncmFkaWVudERpcmVjdGlvbiA9PSAnbGJjLXQtcnRjJykge1xuICAgICAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgdGFyZ2V0UmVjdC5oLCB0YXJnZXRSZWN0LncsIDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3JhZGllbnREaXJlY3Rpb24gPT0gJ2wtdC1yJykge1xuICAgICAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgdGFyZ2V0UmVjdC5oLCB0YXJnZXRSZWN0LncsIHRhcmdldFJlY3QuaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIHRhcmdldFJlY3QuaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHZhbHVlcy5iYWNrR3JhZGllbnQuZnJvbS50b1JnYlN0cmluZygpKTtcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgdmFsdWVzLmJhY2tHcmFkaWVudC50by50b1JnYlN0cmluZygpKTtcblxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodmFsdWVzLmJhY2tncm91bmRTaGFwZSkge1xuICAgICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgICAgY2FzZSAndnJlY3QnOlxuICAgICAgICAgIGNhc2UgJ2hyZWN0JzpcbiAgICAgICAgICAgIHJvdW5kUmVjdFBhdGhfKGN0eCwgdGFyZ2V0UmVjdCwgMyk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICB0YXJnZXRSZWN0LnggKyB0YXJnZXRSZWN0LncgLyAyLFxuICAgICAgICAgICAgICAgIHRhcmdldFJlY3QueSArIHRhcmdldFJlY3QuaCAvIDIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVjdC53IC8gMixcbiAgICAgICAgICAgICAgICAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWFzazogdHJ1ZVxuICAgIH07XG5cbiAgICBsZXQgZm9yZWdyb3VuZExheWVyID0ge1xuICAgICAgLy8gZm9yZWdyb3VuZCBjb250ZW50IGxheWVyXG4gICAgICBkcmF3OiBjdHggPT4ge1xuICAgICAgICBpZiAoIWZvcmVTcmNDdHgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZHJhd0ZuXyA9IGltYWdlbGliLkRyYXdpbmdbdmFsdWVzLmNyb3AgPyAnZHJhd0NlbnRlckNyb3AnIDogJ2RyYXdDZW50ZXJJbnNpZGUnXTtcbiAgICAgICAgZHJhd0ZuXyhjdHgsIGZvcmVTcmNDdHgsIHN0dWRpby5VdGlsLm11bHQodGFyZ2V0UmVjdCwgbXVsdCksXG4gICAgICAgICAgICB7eDogMCwgeTogMCwgdzogZm9yZVNyY0N0eC5jYW52YXMud2lkdGgsIGg6IGZvcmVTcmNDdHguY2FudmFzLmhlaWdodH0pO1xuICAgICAgfSxcbiAgICAgIGVmZmVjdHM6IFtdLFxuICAgICAgbWFzazogISEodmFsdWVzLmJhY2tncm91bmRTaGFwZSA9PSAnbm9uZScpXG4gICAgfTtcblxuICAgIGxldCBzaGFkb3dDb2xvclZhbHVlID0gdmFsdWVzLnNoYWRvd0NvbG9yLnRvUmdiU3RyaW5nKClcblxuICAgIGxldCBzaGFkb3dDb2xvciA9IHRpbnljb2xvcihzaGFkb3dDb2xvclZhbHVlKS5zZXRBbHBoYSh2YWx1ZXMuc2hhZG93QWxwaGEpLnRvUmdiU3RyaW5nKCk7XG5cbiAgICBpZiAodmFsdWVzLmJhY2tncm91bmRTaGFwZSAhPSAnbm9uZScgJiYgdmFsdWVzLmVmZmVjdHMgPT0gJ3NoYWRvdycpIHtcbiAgICAgIGZvcmVncm91bmRMYXllci5lZmZlY3RzLnB1c2goe2VmZmVjdDogJ2Nhc3Qtc2hhZG93JywgY29sb3I6IHNoYWRvd0NvbG9yfSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5mb3JlQ29sb3IuZ2V0QWxwaGEoKSkge1xuICAgICAgZm9yZWdyb3VuZExheWVyLmVmZmVjdHMucHVzaCh7XG4gICAgICAgIGVmZmVjdDogJ2ZpbGwtY29sb3InLFxuICAgICAgICBjb2xvcjogdmFsdWVzLmZvcmVDb2xvci50b1JnYlN0cmluZygpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmJhY2tncm91bmRTaGFwZSAhPSAnbm9uZScgJiZcbiAgICAgICAgKHZhbHVlcy5lZmZlY3RzID09ICdlbGV2YXRlJyB8fCB2YWx1ZXMuZWZmZWN0cyA9PSAnc2hhZG93JykpIHtcbiAgICAgIGZvcmVncm91bmRMYXllci5lZmZlY3RzID0gZm9yZWdyb3VuZExheWVyLmVmZmVjdHMuY29uY2F0KFtcbiAgICAgICAge1xuICAgICAgICAgIGVmZmVjdDogJ291dGVyLXNoYWRvdycsXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IC4yNSAqIG11bHRcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGVmZmVjdDogJ291dGVyLXNoYWRvdycsXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLFxuICAgICAgICAgIGJsdXI6IDEgKiBtdWx0LFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDEgKiBtdWx0XG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgIH1cblxuICAgIGxldCBzY29yZUxheWVyID0ge1xuICAgICAgZHJhdzogY3R4ID0+IHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIC4xKSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBpY29uU2l6ZS53LCBpY29uU2l6ZS5oIC8gMik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGltYWdlbGliLkRyYXdpbmcuZHJhd0xheWVycyhvdXRDdHgsIGljb25TaXplLCB7XG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICB2YWx1ZXMuYmFja2dyb3VuZFNoYXBlICE9ICdub25lJyA/IGJhY2tncm91bmRMYXllciA6IG51bGwsXG4gICAgICAgIGZvcmVncm91bmRMYXllcixcbiAgICAgICAgdmFsdWVzLmVmZmVjdHMgPT0gJ3Njb3JlJyA/IHNjb3JlTGF5ZXIgOiBudWxsLFxuICAgICAgXSxcbiAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGVmZmVjdDogJ2lubmVyLXNoYWRvdycsXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiknLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IC4yNSAqIG11bHRcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGVmZmVjdDogJ2lubmVyLXNoYWRvdycsXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IC0uMjUgKiBtdWx0XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBlZmZlY3Q6ICdmaWxsLXJhZGlhbGdyYWRpZW50JyxcbiAgICAgICAgICBjZW50ZXJYOiAwLFxuICAgICAgICAgIGNlbnRlclk6IDAsXG4gICAgICAgICAgcmFkaXVzOiBpY29uU2l6ZS53LFxuICAgICAgICAgIGNvbG9yczogW1xuICAgICAgICAgICAgeyBvZmZzZXQ6IDAsIGNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwuMSknIH0sXG4gICAgICAgICAgICB7IG9mZnNldDogMS4wLCBjb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMCknIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBlZmZlY3Q6ICdvdXRlci1zaGFkb3cnLFxuICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjMpJyxcbiAgICAgICAgICBibHVyOiAuNyAqIG11bHQsXG4gICAgICAgICAgdHJhbnNsYXRlWTogLjcgKiBtdWx0XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRDdHg7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge3N0dWRpb30gZnJvbSAnLi4vc3R1ZGlvJztcbmltcG9ydCB7aW1hZ2VsaWJ9IGZyb20gJy4uL2ltYWdlbGliJztcbmltcG9ydCB7QmFzZUdlbmVyYXRvcn0gZnJvbSAnLi9CYXNlR2VuZXJhdG9yJztcblxuY29uc3QgSUNPTl9TSVpFID0ge3c6IDI0LCBoOiAyNH07XG5jb25zdCBUQVJHRVRfUkVDVCA9IHt4OiAxLCB5OiAxLCB3OiAyMiwgaDogMjJ9O1xuXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uSWNvbkdlbmVyYXRvciBleHRlbmRzIEJhc2VHZW5lcmF0b3Ige1xuICBzZXR1cEZvcm0oKSB7XG4gICAgc3VwZXIuc2V0dXBGb3JtKCk7XG4gICAgJCgnLm91dHB1dHMtcGFuZWwnKS5hdHRyKCdkYXRhLXRoZW1lJywgJ2RhcmsnKTtcblxuICAgIGxldCBkZWZhdWx0TmFtZUZvclNvdXJjZVZhbHVlXyA9IHYgPT4ge1xuICAgICAgbGV0IG5hbWUgPSBzdHVkaW8uVXRpbC5zYW5pdGl6ZVJlc291cmNlTmFtZSh2Lm5hbWUgfHwgJ2V4YW1wbGUnKTtcbiAgICAgIHJldHVybiBgaWNfc3RhdF8ke25hbWV9YDtcbiAgICB9O1xuXG4gICAgbGV0IG5hbWVGaWVsZDtcbiAgICB0aGlzLmZvcm0gPSBuZXcgc3R1ZGlvLkZvcm0oe1xuICAgICAgaWQ6ICdpY29uZm9ybScsXG4gICAgICBjb250YWluZXI6ICcjaW5wdXRzLWZvcm0nLFxuICAgICAgZmllbGRzOiBbXG4gICAgICAgIG5ldyBzdHVkaW8uSW1hZ2VGaWVsZCgnc291cmNlJywge1xuICAgICAgICAgIHRpdGxlOiAnU291cmNlJyxcbiAgICAgICAgICBoZWxwVGV4dDogJ011c3QgYmUgdHJhbnNwYXJlbnQnLFxuICAgICAgICAgIG1heEZpbmFsU2l6ZTogeyB3OiAxMjgsIGg6IDEyOCB9LFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZUNsaXBhcnQ6ICdhY191bml0JyxcbiAgICAgICAgICBkcm9wVGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgIG9uQ2hhbmdlOiAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZUZpZWxkLmdldFZhbHVlKCkgPT0gZGVmYXVsdE5hbWVGb3JTb3VyY2VWYWx1ZV8ob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgIG5hbWVGaWVsZC5zZXRWYWx1ZShkZWZhdWx0TmFtZUZvclNvdXJjZVZhbHVlXyhuZXdWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIChuYW1lRmllbGQgPSBuZXcgc3R1ZGlvLlRleHRGaWVsZCgnbmFtZScsIHtcbiAgICAgICAgICBuZXdHcm91cDogdHJ1ZSxcbiAgICAgICAgICB0aXRsZTogJ05hbWUnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnVXNlZCB3aGVuIGdlbmVyYXRpbmcgWklQIGZpbGVzLicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0TmFtZUZvclNvdXJjZVZhbHVlXyh7fSlcbiAgICAgICAgfSkpXG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5mb3JtLm9uQ2hhbmdlKGZpZWxkID0+IHRoaXMucmVnZW5lcmF0ZURlYm91bmNlZF8oKSk7XG4gIH1cblxuICByZWdlbmVyYXRlKCkge1xuICAgIGxldCB2YWx1ZXMgPSB0aGlzLmZvcm0uZ2V0VmFsdWVzKCk7XG5cbiAgICB0aGlzLnppcHBlci5jbGVhcigpO1xuICAgIHRoaXMuemlwcGVyLnNldFppcEZpbGVuYW1lKGAke3ZhbHVlcy5uYW1lfS56aXBgKTtcblxuICAgIHRoaXMuZGVuc2l0aWVzLmZvckVhY2goZGVuc2l0eSA9PiB7XG4gICAgICBsZXQgbXVsdCA9IHN0dWRpby5VdGlsLmdldE11bHRCYXNlTWRwaShkZW5zaXR5KTtcbiAgICAgIGxldCBpY29uU2l6ZSA9IHN0dWRpby5VdGlsLm11bHRSb3VuZChJQ09OX1NJWkUsIG11bHQpO1xuXG4gICAgICBsZXQgb3V0Q3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KGljb25TaXplKTtcbiAgICAgIGxldCB0bXBDdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoaWNvblNpemUpO1xuXG4gICAgICBpZiAodmFsdWVzLnNvdXJjZS5jdHgpIHtcbiAgICAgICAgbGV0IHNyY0N0eCA9IHZhbHVlcy5zb3VyY2UuY3R4O1xuICAgICAgICBpbWFnZWxpYi5EcmF3aW5nLmRyYXdDZW50ZXJJbnNpZGUoXG4gICAgICAgICAgICB0bXBDdHgsXG4gICAgICAgICAgICBzcmNDdHgsXG4gICAgICAgICAgICBzdHVkaW8uVXRpbC5tdWx0KFRBUkdFVF9SRUNULCBtdWx0KSxcbiAgICAgICAgICAgIHt4OiAwLCB5OiAwLCB3OiBzcmNDdHguY2FudmFzLndpZHRoLCBoOiBzcmNDdHguY2FudmFzLmhlaWdodH0pO1xuICAgICAgfVxuXG4gICAgICBpbWFnZWxpYi5FZmZlY3RzLmZ4KFtcbiAgICAgICAge2VmZmVjdDogJ2ZpbGwtY29sb3InLCBjb2xvcjogJyNmZmYnfVxuICAgICAgXSwgb3V0Q3R4LCB0bXBDdHgsIGljb25TaXplKTtcblxuICAgICAgdGhpcy56aXBwZXIuYWRkKHtcbiAgICAgICAgbmFtZTogYHJlcy9kcmF3YWJsZS0ke2RlbnNpdHl9LyR7dmFsdWVzLm5hbWV9LnBuZ2AsXG4gICAgICAgIGNhbnZhczogb3V0Q3R4LmNhbnZhc1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2V0SW1hZ2VGb3JTbG90XyhkZW5zaXR5LCBvdXRDdHguY2FudmFzLnRvRGF0YVVSTCgpKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TGF1bmNoZXJJY29uR2VuZXJhdG9yfSBmcm9tICcuL0xhdW5jaGVySWNvbkdlbmVyYXRvcic7XG5pbXBvcnQge0FwcFNob3J0Y3V0SWNvbkdlbmVyYXRvcn0gZnJvbSAnLi9BcHBTaG9ydGN1dEljb25HZW5lcmF0b3InO1xuaW1wb3J0IHtBY3Rpb25CYXJJY29uR2VuZXJhdG9yfSBmcm9tICcuL0FjdGlvbkJhckljb25HZW5lcmF0b3InO1xuaW1wb3J0IHtOb3RpZmljYXRpb25JY29uR2VuZXJhdG9yfSBmcm9tICcuL05vdGlmaWNhdGlvbkljb25HZW5lcmF0b3InO1xuaW1wb3J0IHtHZW5lcmljSWNvbkdlbmVyYXRvcn0gZnJvbSAnLi9HZW5lcmljSWNvbkdlbmVyYXRvcic7XG5pbXBvcnQge05pbmVQYXRjaEdlbmVyYXRvcn0gZnJvbSAnLi9uaW5lcGF0Y2gvTmluZVBhdGNoR2VuZXJhdG9yJztcblxuZXhwb3J0IGNvbnN0IHBhZ2VzID0ge1xuICBMYXVuY2hlckljb25HZW5lcmF0b3IsXG4gIEFwcFNob3J0Y3V0SWNvbkdlbmVyYXRvcixcbiAgQWN0aW9uQmFySWNvbkdlbmVyYXRvcixcbiAgTm90aWZpY2F0aW9uSWNvbkdlbmVyYXRvcixcbiAgR2VuZXJpY0ljb25HZW5lcmF0b3IsXG4gIE5pbmVQYXRjaEdlbmVyYXRvcixcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtzdHVkaW99IGZyb20gJy4uLy4uL3N0dWRpbyc7XG5pbXBvcnQge2ltYWdlbGlifSBmcm9tICcuLi8uLi9pbWFnZWxpYic7XG5pbXBvcnQge0Jhc2VHZW5lcmF0b3J9IGZyb20gJy4uL0Jhc2VHZW5lcmF0b3InO1xuXG5pbXBvcnQge05pbmVQYXRjaFN0YWdlfSBmcm9tICcuL05pbmVQYXRjaFN0YWdlJztcbmltcG9ydCB7TmluZVBhdGNoUHJldmlld30gZnJvbSAnLi9OaW5lUGF0Y2hQcmV2aWV3JztcbmltcG9ydCB7TmluZVBhdGNoTG9hZGVyfSBmcm9tICcuL05pbmVQYXRjaExvYWRlcic7XG5cblxuY29uc3QgREVOU0lUSUVTID0gbmV3IFNldChbJ3h4eGhkcGknLCAneHhoZHBpJywgJ3hoZHBpJywgJ2hkcGknLCAnbWRwaSddKTtcbmNvbnN0IFNPVVJDRV9ERU5TSVRZX09QVElPTlMgPSBbXG4gIHsgaWQ6ICcxNjAnLCB0aXRsZTogICAnbWRwaTxicj48c21hbGw+KDE2MCk8L3NtYWxsPicgfSxcbiAgeyBpZDogJzI0MCcsIHRpdGxlOiAgICdoZHBpPGJyPjxzbWFsbD4oMjQwKTwvc21hbGw+JyB9LFxuICB7IGlkOiAnMzIwJywgdGl0bGU6ICAneGhkcGk8YnI+PHNtYWxsPigzMjApPC9zbWFsbD4nIH0sXG4gIHsgaWQ6ICc0ODAnLCB0aXRsZTogJ3h4aGRwaTxicj48c21hbGw+KDQ4MCk8L3NtYWxsPicgfSxcbiAgeyBpZDogJzY0MCcsIHRpdGxlOiAneHh4aGRwaTxicj48c21hbGw+KDY0MCk8L3NtYWxsPicgfVxuXTtcblxuXG5pZiAoZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoLmluZGV4T2YoJ2V4dHJhZGVuc2l0aWVzJykgPj0gMCkge1xuICBERU5TSVRJRVMuYWRkKCdsZHBpJyk7XG4gIERFTlNJVElFUy5hZGQoJ3R2ZHBpJyk7XG4gIC8vIFNPVVJDRV9ERU5TSVRZX09QVElPTlMucHVzaCh7IGlkOiAnMTIwJywgdGl0bGU6ICAgJ2xkcGk8YnI+PHNtYWxsPigxMjApPC9zbWFsbD4nIH0pO1xuICAvLyBTT1VSQ0VfREVOU0lUWV9PUFRJT05TLnB1c2goeyBpZDogJzIxMycsIHRpdGxlOiAgJ3R2ZHBpPGJyPjxzbWFsbD4oMjEzKTwvc21hbGw+JyB9KTtcbn1cblxuXG5leHBvcnQgY2xhc3MgTmluZVBhdGNoR2VuZXJhdG9yIGV4dGVuZHMgQmFzZUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdGFnZSA9IG5ldyBOaW5lUGF0Y2hTdGFnZSgpO1xuICAgIHRoaXMucHJldmlldyA9IG5ldyBOaW5lUGF0Y2hQcmV2aWV3KHRoaXMuc3RhZ2UpO1xuXG4gICAgdGhpcy5zdGFnZS5vbkNoYW5nZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGUoKTtcbiAgICAgIHRoaXMucHJldmlldy5yZWRyYXcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0dXBPdXRwdXRzUHJldmlld1RhYnMoKTtcbiAgfVxuXG4gIHNldHVwT3V0cHV0c1ByZXZpZXdUYWJzKCkge1xuICAgICQoJy5vdXRwdXRzLXByZXZpZXctdGFicyBpbnB1dCcpLm9uKCdjaGFuZ2UnLCBldiA9PiB7XG4gICAgICAkKCcub3V0cHV0cy1wcmV2aWV3LXNpZGViYXInKS5hdHRyKCdkYXRhLXZpZXcnLCAkKGV2LmN1cnJlbnRUYXJnZXQpLnZhbCgpKTtcbiAgICAgICQoJy5vdXRwdXRzLXByZXZpZXctdGFicyBpbnB1dCcpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAkKGV2LmN1cnJlbnRUYXJnZXQpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBkZW5zaXRpZXMoKSB7XG4gICAgcmV0dXJuIERFTlNJVElFUztcbiAgfVxuXG4gIHNldHVwRm9ybSgpIHtcbiAgICBzdXBlci5zZXR1cEZvcm0oKTtcbiAgICBsZXQgbmFtZUZpZWxkO1xuICAgIHRoaXMuZm9ybSA9IG5ldyBzdHVkaW8uRm9ybSh7XG4gICAgICBpZDogJ25pbmVwYXRjaGZvcm0nLFxuICAgICAgY29udGFpbmVyOiAnI2lucHV0cy1mb3JtJyxcbiAgICAgIGZpZWxkczogW1xuICAgICAgICBuZXcgc3R1ZGlvLkltYWdlRmllbGQoJ3NvdXJjZScsIHtcbiAgICAgICAgICB0aXRsZTogJ1NvdXJjZSBncmFwaGljJyxcbiAgICAgICAgICBpbWFnZU9ubHk6IHRydWUsXG4gICAgICAgICAgbm9UcmltRm9ybTogdHJ1ZSxcbiAgICAgICAgICBub1ByZXZpZXc6IHRydWUsXG4gICAgICAgICAgZHJvcFRhcmdldDogZG9jdW1lbnQuYm9keVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHN0dWRpby5FbnVtRmllbGQoJ3NvdXJjZURlbnNpdHknLCB7XG4gICAgICAgICAgdGl0bGU6ICdTb3VyY2UgZGVuc2l0eScsXG4gICAgICAgICAgYnV0dG9uczogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25zOiBTT1VSQ0VfREVOU0lUWV9PUFRJT05TLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJzMyMCdcbiAgICAgICAgfSksXG4gICAgICAgIChuYW1lRmllbGQgPSBuZXcgc3R1ZGlvLlRleHRGaWVsZCgnbmFtZScsIHtcbiAgICAgICAgICB0aXRsZTogJ0RyYXdhYmxlIG5hbWUnLFxuICAgICAgICAgIGhlbHBUZXh0OiAnVXNlZCB3aGVuIGdlbmVyYXRpbmcgWklQIGZpbGVzLiBCZWNvbWVzIDxjb2RlPiZsdDtuYW1lJmd0Oy45LnBuZzwvY29kZT4uJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICdleGFtcGxlJ1xuICAgICAgICB9KSlcbiAgICAgIF1cbiAgICB9KTtcbiAgICB0aGlzLmZvcm0ub25DaGFuZ2UoZmllbGQgPT4ge1xuICAgICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcbiAgICAgIGlmICghZmllbGQgfHwgZmllbGQuaWRfID09ICdzb3VyY2UnKSB7XG4gICAgICAgIGlmICh2YWx1ZXMuc291cmNlKSB7XG4gICAgICAgICAgaWYgKCF2YWx1ZXMuc291cmNlLmN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc3JjID0gdmFsdWVzLnNvdXJjZTtcbiAgICAgICAgICBsZXQgc2l6ZSA9IHsgdzogc3JjLmN0eC5jYW52YXMud2lkdGgsIGg6IHNyYy5jdHguY2FudmFzLmhlaWdodCB9O1xuICAgICAgICAgIHRoaXMuc3RhZ2UubmFtZSA9IGAke3NyYy5uYW1lfS0ke3NpemUud314JHtzaXplLmh9YDtcbiAgICAgICAgICAvLyBsZXQgaXNTdmcgPSAhIXNyYy5uYW1lLm1hdGNoKC9cXC5zdmckL2kpO1xuICAgICAgICAgIGlmIChzcmMubmFtZSAmJiBzcmMubmFtZS5tYXRjaCgvXFwuOVxcLnBuZyQvaSkpIHtcbiAgICAgICAgICAgIE5pbmVQYXRjaExvYWRlci5sb2FkTmluZVBhdGNoSW50b1N0YWdlKHNyYy5jdHgsIHRoaXMuc3RhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmxvYWRTb3VyY2VJbWFnZShzcmMuY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNyYy5uYW1lKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHN0dWRpby5VdGlsLnNhbml0aXplUmVzb3VyY2VOYW1lKHNyYy5uYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9IG5hbWVGaWVsZC5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgIG5hbWVGaWVsZC5zZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFnZS5sb2FkU291cmNlSW1hZ2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVnZW5lcmF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVnZW5lcmF0ZSgpIHtcbiAgICAvLyB0aGlzLnByZXZpZXcudXBkYXRlKCk7XG5cbiAgICBpZiAoIXRoaXMuc3RhZ2Uuc3JjQ3R4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuZm9ybS5nZXRWYWx1ZXMoKTtcblxuICAgIHRoaXMuemlwcGVyLmNsZWFyKCk7XG4gICAgdGhpcy56aXBwZXIuc2V0WmlwRmlsZW5hbWUoYCR7dmFsdWVzLm5hbWV9LjkuemlwYCk7XG5cbiAgICB0aGlzLmRlbnNpdGllcy5mb3JFYWNoKGRlbnNpdHkgPT4ge1xuICAgICAgbGV0IGRwaSA9IHN0dWRpby5VdGlsLmdldERwaUZvckRlbnNpdHkoZGVuc2l0eSk7XG5cbiAgICAgIC8vIHNjYWxlIHNvdXJjZSBncmFwaGljXG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGJldHRlci1zbW9vdGhpbmcgb3B0aW9uXG4gICAgICBsZXQgc2NhbGUgPSBkcGkgLyB2YWx1ZXMuc291cmNlRGVuc2l0eTtcbiAgICAgIGxldCBvdXRTaXplID0ge1xuICAgICAgICB3OiBNYXRoLmNlaWwodGhpcy5zdGFnZS5zcmNTaXplLncgKiBzY2FsZSkgKyAyLFxuICAgICAgICBoOiBNYXRoLmNlaWwodGhpcy5zdGFnZS5zcmNTaXplLmggKiBzY2FsZSkgKyAyXG4gICAgICB9O1xuICAgICAgbGV0IG91dEN0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChvdXRTaXplKTtcbiAgICAgIGltYWdlbGliLkRyYXdpbmcuZHJhd0ltYWdlU2NhbGVkKG91dEN0eCwgdGhpcy5zdGFnZS5zcmNDdHgsXG4gICAgICAgICAgMCwgMCwgdGhpcy5zdGFnZS5zcmNTaXplLncsIHRoaXMuc3RhZ2Uuc3JjU2l6ZS5oLFxuICAgICAgICAgIDEsIDEsIG91dFNpemUudyAtIDIsIG91dFNpemUuaCAtIDIpO1xuXG4gICAgICAvLyBkcmF3IEFuZHJvaWQgNC4zIG9wdGljYWwgYm91bmRzXG4gICAgICBvdXRDdHguc3Ryb2tlU3R5bGUgPSAnI2YwMCc7XG4gICAgICBvdXRDdHgubGluZVdpZHRoID0gMTtcbiAgICAgIG91dEN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgb3V0Q3R4Lm1vdmVUbygxLCBvdXRTaXplLmggLSAwLjUpO1xuICAgICAgb3V0Q3R4LmxpbmVUbygxICsgTWF0aC5mbG9vcihzY2FsZSAqIHRoaXMuc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QueCksIG91dFNpemUuaCAtIDAuNSk7XG4gICAgICBvdXRDdHguc3Ryb2tlKCk7XG5cbiAgICAgIG91dEN0eC5tb3ZlVG8oTWF0aC5jZWlsKHNjYWxlICogKHRoaXMuc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QueCArIHRoaXMuc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QudykpICsgMSwgb3V0U2l6ZS5oIC0gMC41KTtcbiAgICAgIG91dEN0eC5saW5lVG8ob3V0U2l6ZS53IC0gMSwgb3V0U2l6ZS5oIC0gMC41KTtcbiAgICAgIG91dEN0eC5zdHJva2UoKTtcblxuICAgICAgb3V0Q3R4Lm1vdmVUbyhvdXRTaXplLncgLSAwLjUsIDEpO1xuICAgICAgb3V0Q3R4LmxpbmVUbyhvdXRTaXplLncgLSAwLjUsIDEgKyBNYXRoLmZsb29yKHNjYWxlICogdGhpcy5zdGFnZS5vcHRpY2FsQm91bmRzUmVjdC55KSk7XG4gICAgICBvdXRDdHguc3Ryb2tlKCk7XG5cbiAgICAgIG91dEN0eC5tb3ZlVG8ob3V0U2l6ZS53IC0gMC41LCBNYXRoLmNlaWwoc2NhbGUgKiAodGhpcy5zdGFnZS5vcHRpY2FsQm91bmRzUmVjdC55ICsgdGhpcy5zdGFnZS5vcHRpY2FsQm91bmRzUmVjdC5oKSkgKyAxKTtcbiAgICAgIG91dEN0eC5saW5lVG8ob3V0U2l6ZS53IC0gMC41LCBvdXRTaXplLmggLSAxKTtcbiAgICAgIG91dEN0eC5zdHJva2UoKTtcblxuICAgICAgb3V0Q3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAvLyBkcmF3IG5pbmUtcGF0Y2ggdGljayBtYXJrc1xuICAgICAgb3V0Q3R4LnN0cm9rZVN0eWxlID0gJyMwMDAnO1xuICAgICAgb3V0Q3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBvdXRDdHgubW92ZVRvKDEgKyBNYXRoLmZsb29yKHNjYWxlICogdGhpcy5zdGFnZS5zdHJldGNoUmVjdC54KSwgMC41KTtcbiAgICAgIG91dEN0eC5saW5lVG8oMSArIE1hdGguY2VpbChzY2FsZSAqICh0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LnggKyB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LncpKSwgMC41KTtcbiAgICAgIG91dEN0eC5zdHJva2UoKTtcblxuICAgICAgb3V0Q3R4Lm1vdmVUbygwLjUsIDEgKyBNYXRoLmZsb29yKHNjYWxlICogdGhpcy5zdGFnZS5zdHJldGNoUmVjdC55KSk7XG4gICAgICBvdXRDdHgubGluZVRvKDAuNSwgMSArIE1hdGguY2VpbChzY2FsZSAqICh0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LnkgKyB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LmgpKSk7XG4gICAgICBvdXRDdHguc3Ryb2tlKCk7XG5cbiAgICAgIG91dEN0eC5tb3ZlVG8oMSArIE1hdGguZmxvb3Ioc2NhbGUgKiB0aGlzLnN0YWdlLmNvbnRlbnRSZWN0LngpLCBvdXRTaXplLmggLSAwLjUpO1xuICAgICAgb3V0Q3R4LmxpbmVUbygxICsgTWF0aC5jZWlsKHNjYWxlICogKHRoaXMuc3RhZ2UuY29udGVudFJlY3QueCArIHRoaXMuc3RhZ2UuY29udGVudFJlY3QudykpLCBvdXRTaXplLmggLSAwLjUpO1xuICAgICAgb3V0Q3R4LnN0cm9rZSgpO1xuXG4gICAgICBvdXRDdHgubW92ZVRvKG91dFNpemUudyAtIDAuNSwgMSArIE1hdGguZmxvb3Ioc2NhbGUgKiB0aGlzLnN0YWdlLmNvbnRlbnRSZWN0LnkpKTtcbiAgICAgIG91dEN0eC5saW5lVG8ob3V0U2l6ZS53IC0gMC41LCAxICsgTWF0aC5jZWlsKHNjYWxlICogKHRoaXMuc3RhZ2UuY29udGVudFJlY3QueSArIHRoaXMuc3RhZ2UuY29udGVudFJlY3QuaCkpKTtcbiAgICAgIG91dEN0eC5zdHJva2UoKTtcblxuICAgICAgb3V0Q3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAvLyBhZGQgdG8gemlwIGFuZCBzaG93IHByZXZpZXdcblxuICAgICAgdGhpcy56aXBwZXIuYWRkKHtcbiAgICAgICAgbmFtZTogYHJlcy9kcmF3YWJsZS0ke2RlbnNpdHl9LyR7dmFsdWVzLm5hbWV9LjkucG5nYCxcbiAgICAgICAgY2FudmFzOiBvdXRDdHguY2FudmFzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zZXRJbWFnZUZvclNsb3RfKGRlbnNpdHksIG91dEN0eC5jYW52YXMudG9EYXRhVVJMKCkpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vLi4vaW1hZ2VsaWInO1xuXG5jb25zdCBudW1iZXJGb3JSR0JBID0gKHIsZyxiLGEpID0+IChyIDw8IDE2KSArIChnIDw8IDgpICsgKGIgPDwgMCkgKyAoYSA8PCAyNCk7XG5jb25zdCBCTEFDSyA9IG51bWJlckZvclJHQkEoMCwwLDAsMjU1KTtcbmNvbnN0IFJFRCA9IG51bWJlckZvclJHQkEoMjU1LDAsMCwyNTUpO1xuXG5leHBvcnQgY29uc3QgTmluZVBhdGNoTG9hZGVyID0ge1xuICBsb2FkTmluZVBhdGNoSW50b1N0YWdlKGN0eCwgc3RhZ2UpIHtcbiAgICBsZXQgc3JjU2l6ZSA9IHsgdzogY3R4LmNhbnZhcy53aWR0aCwgaDogY3R4LmNhbnZhcy5oZWlnaHQgfTtcbiAgICBsZXQgaW1nRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc3JjU2l6ZS53LCBzcmNTaXplLmgpO1xuICAgIGxldCBzaXplID0geyB3OiBzcmNTaXplLncgLSAyLCBoOiBzcmNTaXplLmggLSAyIH07XG4gICAgbGV0IHJlY3RzID0ge1xuICAgICAgY29udGVudFJlY3Q6IHsgeDogMCwgeTogMCwgdzogc2l6ZS53LCBoOiBzaXplLmggfSxcbiAgICAgIHN0cmV0Y2hSZWN0OiB7IHg6IDAsIHk6IDAsIHc6IHNpemUudywgaDogc2l6ZS5oIH0sXG4gICAgICBvcHRpY2FsQm91bmRzUmVjdDogeyB4OiAwLCB5OiAwLCB3OiBzaXplLncsIGg6IHNpemUuaCB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9nZXRQaXhlbCh4LCB5KSB7XG4gICAgICByZXR1cm4gKGltZ0RhdGEuZGF0YVsoeSAqIHNyY1NpemUudyArIHgpICogNCArIDBdIDw8IDE2KSAvLyByXG4gICAgICAgICAgKyAoaW1nRGF0YS5kYXRhWyh5ICogc3JjU2l6ZS53ICsgeCkgKiA0ICsgMV0gPDwgOCkgLy8gZ1xuICAgICAgICAgICsgKGltZ0RhdGEuZGF0YVsoeSAqIHNyY1NpemUudyArIHgpICogNCArIDJdIDw8IDApIC8vIGJcbiAgICAgICAgICArIChpbWdEYXRhLmRhdGFbKHkgKiBzcmNTaXplLncgKyB4KSAqIDQgKyAzXSA8PCAyNCk7IC8vIGFcbiAgICB9XG5cbiAgICBsZXQgaW5SZWdpb247XG5cbiAgICAvLyBSZWFkIHN0cmV0Y2ggcmVjdFxuICAgIGluUmVnaW9uID0gZmFsc2U7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplLnc7IHgrKykge1xuICAgICAgbGV0IHAgPSBfZ2V0UGl4ZWwoeCArIDEsIDApO1xuICAgICAgaWYgKCFpblJlZ2lvbiAmJiBwID09IEJMQUNLKSB7XG4gICAgICAgIHJlY3RzLnN0cmV0Y2hSZWN0LnggPSB4O1xuICAgICAgICBpblJlZ2lvbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGluUmVnaW9uICYmIHAgIT0gQkxBQ0spIHtcbiAgICAgICAgcmVjdHMuc3RyZXRjaFJlY3QudyA9IHggLSByZWN0cy5zdHJldGNoUmVjdC54O1xuICAgICAgICBpblJlZ2lvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluUmVnaW9uID0gZmFsc2U7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplLmg7IHkrKykge1xuICAgICAgbGV0IHAgPSBfZ2V0UGl4ZWwoMCwgeSArIDEpO1xuICAgICAgaWYgKCFpblJlZ2lvbiAmJiBwID09IEJMQUNLKSB7XG4gICAgICAgIHJlY3RzLnN0cmV0Y2hSZWN0LnkgPSB5O1xuICAgICAgICBpblJlZ2lvbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGluUmVnaW9uICYmIHAgIT0gQkxBQ0spIHtcbiAgICAgICAgcmVjdHMuc3RyZXRjaFJlY3QuaCA9IHkgLSByZWN0cy5zdHJldGNoUmVjdC55O1xuICAgICAgICBpblJlZ2lvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlYWQgY29udGVudCByZWN0XG4gICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemUudzsgeCsrKSB7XG4gICAgICBsZXQgcCA9IF9nZXRQaXhlbCh4ICsgMSwgc3JjU2l6ZS5oIC0gMSk7XG4gICAgICBpZiAoIWluUmVnaW9uICYmIHAgPT0gQkxBQ0spIHtcbiAgICAgICAgcmVjdHMuY29udGVudFJlY3QueCA9IHg7XG4gICAgICAgIGluUmVnaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5SZWdpb24gJiYgcCAhPSBCTEFDSykge1xuICAgICAgICByZWN0cy5jb250ZW50UmVjdC53ID0geCAtIHJlY3RzLmNvbnRlbnRSZWN0Lng7XG4gICAgICAgIGluUmVnaW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemUuaDsgeSsrKSB7XG4gICAgICBsZXQgcCA9IF9nZXRQaXhlbChzcmNTaXplLncgLSAxLCB5ICsgMSk7XG4gICAgICBpZiAoIWluUmVnaW9uICYmIHAgPT0gQkxBQ0spIHtcbiAgICAgICAgcmVjdHMuY29udGVudFJlY3QueSA9IHk7XG4gICAgICAgIGluUmVnaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5SZWdpb24gJiYgcCAhPSBCTEFDSykge1xuICAgICAgICByZWN0cy5jb250ZW50UmVjdC5oID0geSAtIHJlY3RzLmNvbnRlbnRSZWN0Lnk7XG4gICAgICAgIGluUmVnaW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVhZCBvcHRpY2FsIGJvdW5kcyByZWN0XG4gICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemUudzsgeCsrKSB7XG4gICAgICBsZXQgcCA9IF9nZXRQaXhlbCh4ICsgMSwgc3JjU2l6ZS5oIC0gMSk7XG4gICAgICBpZiAoIWluUmVnaW9uICYmIHAgIT0gUkVEKSB7XG4gICAgICAgIHJlY3RzLm9wdGljYWxCb3VuZHNSZWN0LnggPSB4O1xuICAgICAgICBpblJlZ2lvbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGluUmVnaW9uICYmIHAgPT0gUkVEKSB7XG4gICAgICAgIHJlY3RzLm9wdGljYWxCb3VuZHNSZWN0LncgPSB4IC0gcmVjdHMub3B0aWNhbEJvdW5kc1JlY3QueDtcbiAgICAgICAgaW5SZWdpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplLmg7IHkrKykge1xuICAgICAgbGV0IHAgPSBfZ2V0UGl4ZWwoc3JjU2l6ZS53IC0gMSwgeSArIDEpO1xuICAgICAgaWYgKCFpblJlZ2lvbiAmJiBwICE9IFJFRCkge1xuICAgICAgICByZWN0cy5vcHRpY2FsQm91bmRzUmVjdC55ID0geTtcbiAgICAgICAgaW5SZWdpb24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpblJlZ2lvbiAmJiBwID09IFJFRCkge1xuICAgICAgICByZWN0cy5vcHRpY2FsQm91bmRzUmVjdC5oID0geSAtIHJlY3RzLm9wdGljYWxCb3VuZHNSZWN0Lnk7XG4gICAgICAgIGluUmVnaW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5zZXQgdGhlIGNvbnRleHRcbiAgICBsZXQgbmV3Q3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgIG5ld0N0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcywgMSwgMSwgc2l6ZS53LCBzaXplLmgsIDAsIDAsIHNpemUudywgc2l6ZS5oKTtcbiAgICBzdGFnZS5sb2FkU291cmNlSW1hZ2UobmV3Q3R4LCByZWN0cyk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNsYXNzIE5pbmVQYXRjaFByZXZpZXcge1xuICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICB0aGlzLnNpemUgPSB7dzogMjAwLCBoOiAyMDB9O1xuICAgIHRoaXMuc2V0dXBVaSgpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH1cblxuICBzZXR1cFVpKCkge1xuICAgIGxldCBzdGFydFdpZHRoLCBzdGFydEhlaWdodCwgc3RhcnRYLCBzdGFydFk7XG5cbiAgICBsZXQgbW91c2VNb3ZlSGFuZGxlcl8gPSBldiA9PiB7XG4gICAgICB0aGlzLnNpemUudyA9IE1hdGgubWF4KDEsIHN0YXJ0V2lkdGggKyAoZXYucGFnZVggLSBzdGFydFgpICogMik7XG4gICAgICB0aGlzLnNpemUuaCA9IE1hdGgubWF4KDEsIHN0YXJ0SGVpZ2h0ICsgKGV2LnBhZ2VZIC0gc3RhcnRZKSAqIDIpO1xuICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9O1xuXG4gICAgbGV0IG1vdXNlVXBIYW5kbGVyXyA9IGV2ID0+IHtcbiAgICAgICQod2luZG93KVxuICAgICAgICAgIC5vZmYoJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXJfKVxuICAgICAgICAgIC5vZmYoJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcl8pO1xuICAgIH07XG5cbiAgICAkKCcucHJldmlldy1hcmVhJylcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBldiA9PiB7XG4gICAgICAgICAgc3RhcnRXaWR0aCA9IHRoaXMuc2l6ZS53O1xuICAgICAgICAgIHN0YXJ0SGVpZ2h0ID0gdGhpcy5zaXplLmg7XG4gICAgICAgICAgc3RhcnRYID0gZXYucGFnZVg7XG4gICAgICAgICAgc3RhcnRZID0gZXYucGFnZVk7XG5cbiAgICAgICAgICAkKHdpbmRvdylcbiAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyXylcbiAgICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXJfKTtcbiAgICAgICAgfSk7XG5cbiAgICAkKCcjcHJldmlldy13aXRoLWNvbnRlbnQnKS5jbGljayhldiA9PiAkKCcudGV4dC1wcmV2aWV3JykudG9nZ2xlKCQoZXYuY3VycmVudFRhcmdldCkuaXMoJzpjaGVja2VkJykpKTtcbiAgfVxuXG4gIHJlZHJhdygpIHtcbiAgICBsZXQgY2FudmFzID0gJCgnLnByZXZpZXctYXJlYSBjYW52YXMnKS5nZXQoMCk7XG4gICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplLnc7XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS5oO1xuXG4gICAgaWYgKHRoaXMuc3RhZ2Uuc3JjQ3R4KSB7XG4gICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGxldCBmaXhlZCA9IHtcbiAgICAgICAgbDogdGhpcy5zdGFnZS5zdHJldGNoUmVjdC54LFxuICAgICAgICB0OiB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LnksXG4gICAgICAgIHI6IHRoaXMuc3RhZ2Uuc3JjU2l6ZS53IC0gdGhpcy5zdGFnZS5zdHJldGNoUmVjdC54IC0gdGhpcy5zdGFnZS5zdHJldGNoUmVjdC53LFxuICAgICAgICBiOiB0aGlzLnN0YWdlLnNyY1NpemUuaCAtIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QueSAtIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QuaFxuICAgICAgfTtcblxuICAgICAgLy8gVExcbiAgICAgIGlmIChmaXhlZC5sICYmIGZpeGVkLnQpXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5zdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgICAgMCwgMCwgZml4ZWQubCwgZml4ZWQudCxcbiAgICAgICAgICAgIDAsIDAsIGZpeGVkLmwsIGZpeGVkLnQpO1xuXG4gICAgICAvLyBCTFxuICAgICAgaWYgKGZpeGVkLmwgJiYgZml4ZWQuYilcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICAwLCB0aGlzLnN0YWdlLnNyY1NpemUuaCAtIGZpeGVkLmIsIGZpeGVkLmwsIGZpeGVkLmIsXG4gICAgICAgICAgICAwLCB0aGlzLnNpemUuaCAtIGZpeGVkLmIsIGZpeGVkLmwsIGZpeGVkLmIpO1xuXG4gICAgICAvLyBUUlxuICAgICAgaWYgKGZpeGVkLnIgJiYgZml4ZWQudClcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICB0aGlzLnN0YWdlLnNyY1NpemUudyAtIGZpeGVkLnIsIDAsIGZpeGVkLnIsIGZpeGVkLnQsXG4gICAgICAgICAgICB0aGlzLnNpemUudyAtIGZpeGVkLnIsIDAsIGZpeGVkLnIsIGZpeGVkLnQpO1xuXG4gICAgICAvLyBCUlxuICAgICAgaWYgKGZpeGVkLnIgJiYgZml4ZWQuYilcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICB0aGlzLnN0YWdlLnNyY1NpemUudyAtIGZpeGVkLnIsIHRoaXMuc3RhZ2Uuc3JjU2l6ZS5oIC0gZml4ZWQuYiwgZml4ZWQuciwgZml4ZWQuYixcbiAgICAgICAgICAgIHRoaXMuc2l6ZS53IC0gZml4ZWQuciwgdGhpcy5zaXplLmggLSBmaXhlZC5iLCBmaXhlZC5yLCBmaXhlZC5iKTtcblxuICAgICAgLy8gVG9wXG4gICAgICBpZiAoZml4ZWQudClcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICBmaXhlZC5sLCAwLCB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LncsIGZpeGVkLnQsXG4gICAgICAgICAgICBmaXhlZC5sLCAwLCB0aGlzLnNpemUudyAtIGZpeGVkLmwgLSBmaXhlZC5yLCBmaXhlZC50KTtcblxuICAgICAgLy8gTGVmdFxuICAgICAgaWYgKGZpeGVkLmwpXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5zdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgICAgMCwgZml4ZWQudCwgZml4ZWQubCwgdGhpcy5zdGFnZS5zdHJldGNoUmVjdC5oLFxuICAgICAgICAgICAgMCwgZml4ZWQudCwgZml4ZWQubCwgdGhpcy5zaXplLmggLSBmaXhlZC50IC0gZml4ZWQuYik7XG5cbiAgICAgIC8vIFJpZ2h0XG4gICAgICBpZiAoZml4ZWQucilcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgICB0aGlzLnN0YWdlLnNyY1NpemUudyAtIGZpeGVkLnIsIGZpeGVkLnQsIGZpeGVkLnIsIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QuaCxcbiAgICAgICAgICAgIHRoaXMuc2l6ZS53IC0gZml4ZWQuciwgZml4ZWQudCwgZml4ZWQuciwgdGhpcy5zaXplLmggLSBmaXhlZC50IC0gZml4ZWQuYik7XG5cbiAgICAgIC8vIEJvdHRvbVxuICAgICAgaWYgKGZpeGVkLmIpXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5zdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgICAgZml4ZWQubCwgdGhpcy5zdGFnZS5zcmNTaXplLmggLSBmaXhlZC5iLCB0aGlzLnN0YWdlLnN0cmV0Y2hSZWN0LncsIGZpeGVkLmIsXG4gICAgICAgICAgICBmaXhlZC5sLCB0aGlzLnNpemUuaCAtIGZpeGVkLmIsIHRoaXMuc2l6ZS53IC0gZml4ZWQubCAtIGZpeGVkLnIsIGZpeGVkLmIpO1xuXG4gICAgICAvLyBNaWRkbGVcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5zdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgIGZpeGVkLmwsIGZpeGVkLnQsIHRoaXMuc3RhZ2Uuc3RyZXRjaFJlY3QudywgdGhpcy5zdGFnZS5zdHJldGNoUmVjdC5oLFxuICAgICAgICAgIGZpeGVkLmwsIGZpeGVkLnQsIHRoaXMuc2l6ZS53IC0gZml4ZWQubCAtIGZpeGVkLnIsIHRoaXMuc2l6ZS5oIC0gZml4ZWQudCAtIGZpeGVkLmIpO1xuXG4gICAgICAvLyBwcmV2aWV3IGNvbnRlbnRcbiAgICAgICQoJy5wcmV2aWV3LWFyZWEgLnRleHQtcHJldmlldycpXG4gICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnN0YWdlLmNvbnRlbnRSZWN0LnggKyBcInB4XCIsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc3RhZ2UuY29udGVudFJlY3QueSArIFwicHhcIixcbiAgICAgICAgICAgIHdpZHRoOiAodGhpcy5zaXplLncgLSB0aGlzLnN0YWdlLnNyY1NpemUudyArIHRoaXMuc3RhZ2UuY29udGVudFJlY3QudykgKyBcInB4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6ICh0aGlzLnNpemUuaCAtIHRoaXMuc3RhZ2Uuc3JjU2l6ZS5oICsgdGhpcy5zdGFnZS5jb250ZW50UmVjdC5oKSArIFwicHhcIlxuICAgICAgICAgIH0pO1xuICAgIH1cbiAgfVxufSIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2ltYWdlbGlifSBmcm9tICcuLi8uLi9pbWFnZWxpYic7XG5pbXBvcnQge05pbmVQYXRjaFRyaW1taW5nfSBmcm9tICcuL05pbmVQYXRjaFRyaW1taW5nJztcblxuY29uc3QgRU1QVFlfUkVDVCA9IHt4OiAwLCB5OiAwLCB3OiAwLCBoOiAwfTtcblxuY29uc3QgU0xPUF9QSVhFTFMgPSAxMDtcblxuZXhwb3J0IGNsYXNzIE5pbmVQYXRjaFN0YWdlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy56b29tID0gMTtcbiAgICB0aGlzLm1hdHRlQ29sb3IgPSAnbGlnaHQnO1xuICAgIHRoaXMuZWRpdE1vZGUgPSAnc3RyZXRjaCc7XG4gICAgdGhpcy5zdHJldGNoUmVjdCA9IE9iamVjdC5hc3NpZ24oe30sIEVNUFRZX1JFQ1QpO1xuICAgIHRoaXMuY29udGVudFJlY3QgPSBPYmplY3QuYXNzaWduKHt9LCBFTVBUWV9SRUNUKTtcbiAgICB0aGlzLm9wdGljYWxCb3VuZHNSZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgRU1QVFlfUkVDVCk7XG4gICAgdGhpcy5uYW1lID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IFtdO1xuXG4gICAgdGhpcy4kc3RhZ2UgPSAkKCcubmluZS1wYXRjaC1zdGFnZScpO1xuICAgIHRoaXMuJGNhbnZhc0NvbnRhaW5lciA9ICQoJy5zdGFnZS1jYW52YXMtY29udGFpbmVyJyk7XG5cbiAgICB0aGlzLnNldHVwVWkoKTtcbiAgICB0aGlzLnNldHVwRHJhZ2dpbmcoKTtcblxuICAgICQod2luZG93KS5vbigncmVzaXplJywgKCkgPT4ge1xuICAgICAgdGhpcy5yZWxheW91dCgpO1xuICAgICAgdGhpcy5yZWRyYXdPdmVybGF5KCk7XG4gICAgfSk7XG4gIH1cblxuICBvbkNoYW5nZShsaXN0ZW5lcikge1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIG5vdGlmeUNoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gIH1cblxuICBzZXR1cFVpKCkge1xuICAgIC8vIFN0YWdlIGNvZGVcbiAgICB0aGlzLiR0b3BMYWJlbCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2NhbnZhcy1sYWJlbCBsYWJlbC12ZXJ0aWNhbCcpLmhpZGUoKS5hcHBlbmRUbygnYm9keScpO1xuICAgIHRoaXMuJGxlZnRMYWJlbCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2NhbnZhcy1sYWJlbCBsYWJlbC1ob3Jpem9udGFsJykuaGlkZSgpLmFwcGVuZFRvKCdib2R5Jyk7XG4gICAgdGhpcy4kcmlnaHRMYWJlbCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2NhbnZhcy1sYWJlbCBsYWJlbC1ob3Jpem9udGFsJykuaGlkZSgpLmFwcGVuZFRvKCdib2R5Jyk7XG4gICAgdGhpcy4kYm90dG9tTGFiZWwgPSAkKCc8ZGl2PicpLmFkZENsYXNzKCdjYW52YXMtbGFiZWwgbGFiZWwtdmVydGljYWwnKS5oaWRlKCkuYXBwZW5kVG8oJ2JvZHknKTtcblxuICAgICQoJy5zdGFnZS13aGljaCBpbnB1dCcpLm9uKCdjaGFuZ2UnLCBldiA9PiB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gJChldi5jdXJyZW50VGFyZ2V0KS52YWwoKTtcbiAgICAgICQoJy50cmltLWJ1dHRvbicpLnRvZ2dsZSh0aGlzLmVkaXRNb2RlID09ICdzdHJldGNoJyk7XG4gICAgICAkKCcuZmluZC1yZWdpb24tYnV0dG9uJykudGV4dCh7XG4gICAgICAgIHN0cmV0Y2g6ICdBdXRvLXN0cmV0Y2gnLFxuICAgICAgICBwYWRkaW5nOiAnQXV0by1wYWRkaW5nJyxcbiAgICAgICAgb3B0aWNhbGJvdW5kczogJ0F1dG8tYm91bmRzJ1xuICAgICAgfVt0aGlzLmVkaXRNb2RlXSk7XG4gICAgICAkKCcuc3RhZ2Utd2hpY2ggaW5wdXQnKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgJChldi5jdXJyZW50VGFyZ2V0KS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG4gICAgICB0aGlzLnJlZHJhd092ZXJsYXkoKTtcbiAgICB9KTtcblxuICAgICQoJy5zdGFnZS1tYXR0ZS1jb2xvciBpbnB1dCcpLm9uKCdjaGFuZ2UnLCBldiA9PiB7XG4gICAgICB0aGlzLm1hdHRlQ29sb3IgPSAkKGV2LmN1cnJlbnRUYXJnZXQpLnZhbCgpO1xuICAgICAgJChkb2N1bWVudC5ib2R5KS5hdHRyKCdkYXRhLXRoZW1lJywgdGhpcy5tYXR0ZUNvbG9yKTtcbiAgICAgICQoJy5zdGFnZS1tYXR0ZS1jb2xvciBpbnB1dCcpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAkKGV2LmN1cnJlbnRUYXJnZXQpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICAgIHRoaXMucmVkcmF3SW1hZ2UoKTtcbiAgICB9KTtcblxuICAgICQoJy50cmltLWVkZ2UtYnV0dG9uJykuY2xpY2soKCkgPT4gTmluZVBhdGNoVHJpbW1pbmcudHJpbUVkZ2VzKHRoaXMpKTtcbiAgICAkKCcudHJpbS1zdHJldGNoLWJ1dHRvbicpLmNsaWNrKCgpID0+IE5pbmVQYXRjaFRyaW1taW5nLnRyaW1TdHJldGNoUmVnaW9uKHRoaXMpKTtcbiAgICAkKCcuZmluZC1yZWdpb24tYnV0dG9uJykuY2xpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlY3QgPSBOaW5lUGF0Y2hUcmltbWluZy5kZXRlY3RSZWdpb24odGhpcywgdGhpcy5lZGl0TW9kZSk7XG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PSAnc3RyZXRjaCcpIHtcbiAgICAgICAgdGhpcy5zdHJldGNoUmVjdCA9IHJlY3Q7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWRpdE1vZGUgPT0gJ29wdGljYWxib3VuZHMnKSB7XG4gICAgICAgIHRoaXMub3B0aWNhbEJvdW5kc1JlY3QgPSByZWN0O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVkaXRNb2RlID09ICdwYWRkaW5nJykge1xuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0ID0gcmVjdDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zYXZlUmVjdHMoKTtcbiAgICAgIHRoaXMucmVkcmF3T3ZlcmxheSgpO1xuICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VfKCk7XG4gICAgfSk7XG4gIH1cblxuICBzZXR1cERyYWdnaW5nKCkge1xuICAgIGxldCBtb3VzZVVwSGFuZGxlcl8sIGRyYWdnaW5nTW91c2VNb3ZlSGFuZGxlcl87XG5cbiAgICBsZXQgZ2V0RWRpdFJlY3RfID0gKCkgPT4gKHtcbiAgICAgIHN0cmV0Y2g6IHRoaXMuc3RyZXRjaFJlY3QsXG4gICAgICBwYWRkaW5nOiB0aGlzLmNvbnRlbnRSZWN0LFxuICAgICAgb3B0aWNhbGJvdW5kczogdGhpcy5vcHRpY2FsQm91bmRzUmVjdFxuICAgIH1bdGhpcy5lZGl0TW9kZV0pO1xuXG4gICAgdGhpcy4kY2FudmFzQ29udGFpbmVyXG4gICAgICAgIC5vbignbW91c2Vkb3duJywgZXYgPT4ge1xuICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVkcmF3T3ZlcmxheSgpO1xuICAgICAgICAgICQod2luZG93KVxuICAgICAgICAgICAgICAub24oJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcl8pXG4gICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZHJhZ2dpbmdNb3VzZU1vdmVIYW5kbGVyXyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZXYgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy4kaW1hZ2VDYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBoYW5kbGVkIGJ5IG90aGVyIG1vdXNlbW92ZSBoYW5kbGVyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGVkaXRSZWN0ID0gZ2V0RWRpdFJlY3RfKCk7XG4gICAgICAgICAgbGV0IG9mZnMgPSB0aGlzLiRjYW52YXNDb250YWluZXIub2Zmc2V0KCk7XG4gICAgICAgICAgbGV0IG9mZnNldFggPSBldi5wYWdlWCAtIG9mZnMubGVmdDtcbiAgICAgICAgICBsZXQgb2Zmc2V0WSA9IGV2LnBhZ2VZIC0gb2Zmcy50b3A7XG5cbiAgICAgICAgICB0aGlzLmVkaXRMZWZ0ID0gdGhpcy5lZGl0UmlnaHQgPSB0aGlzLmVkaXRUb3AgPSB0aGlzLmVkaXRCb3R0b20gPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChvZmZzZXRYID49IGVkaXRSZWN0LnggKiB0aGlzLnpvb20gLSBTTE9QX1BJWEVMUyAmJlxuICAgICAgICAgICAgICBvZmZzZXRYIDw9IGVkaXRSZWN0LnggKiB0aGlzLnpvb20gKyBTTE9QX1BJWEVMUykge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGVmdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXRYID49IChlZGl0UmVjdC54ICsgZWRpdFJlY3QudykgKiB0aGlzLnpvb20gLSBTTE9QX1BJWEVMUyAmJlxuICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA8PSAoZWRpdFJlY3QueCArIGVkaXRSZWN0LncpICogdGhpcy56b29tICsgU0xPUF9QSVhFTFMpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2Zmc2V0WSA+PSBlZGl0UmVjdC55ICogdGhpcy56b29tIC0gU0xPUF9QSVhFTFMgJiZcbiAgICAgICAgICAgICAgb2Zmc2V0WSA8PSBlZGl0UmVjdC55ICogdGhpcy56b29tICsgU0xPUF9QSVhFTFMpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFRvcCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXRZID49IChlZGl0UmVjdC55ICsgZWRpdFJlY3QuaCkgKiB0aGlzLnpvb20gLSBTTE9QX1BJWEVMUyAmJlxuICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA8PSAoZWRpdFJlY3QueSArIGVkaXRSZWN0LmgpICogdGhpcy56b29tICsgU0xPUF9QSVhFTFMpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdEJvdHRvbSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICBpZiAodGhpcy5lZGl0TGVmdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdFRvcCkge1xuICAgICAgICAgICAgICBjdXJzb3IgPSAnbnctcmVzaXplJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lZGl0Qm90dG9tKSB7XG4gICAgICAgICAgICAgIGN1cnNvciA9ICdzdy1yZXNpemUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3Vyc29yID0gJ3ctcmVzaXplJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWRpdFJpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0VG9wKSB7XG4gICAgICAgICAgICAgIGN1cnNvciA9ICduZS1yZXNpemUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVkaXRCb3R0b20pIHtcbiAgICAgICAgICAgICAgY3Vyc29yID0gJ3NlLXJlc2l6ZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJzb3IgPSAnZS1yZXNpemUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lZGl0VG9wKSB7XG4gICAgICAgICAgICBjdXJzb3IgPSAnbi1yZXNpemUnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lZGl0Qm90dG9tKSB7XG4gICAgICAgICAgICBjdXJzb3IgPSAncy1yZXNpemUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiRjYW52YXNDb250YWluZXIuY3NzKCdjdXJzb3InLCBjdXJzb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgbW91c2VVcEhhbmRsZXJfID0gZXYgPT4ge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnJlZHJhd092ZXJsYXkoKTtcbiAgICAgICAgICB0aGlzLnNhdmVSZWN0cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh3aW5kb3cpXG4gICAgICAgICAgICAub2ZmKCdtb3VzZW1vdmUnLCBkcmFnZ2luZ01vdXNlTW92ZUhhbmRsZXJfKVxuICAgICAgICAgICAgLm9mZignbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyXyk7XG4gICAgICB9O1xuXG4gICAgICBkcmFnZ2luZ01vdXNlTW92ZUhhbmRsZXJfID0gZXYgPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBsZXQgZWRpdFJlY3QgPSBnZXRFZGl0UmVjdF8oKTtcbiAgICAgICAgbGV0IG9mZnMgPSB0aGlzLiRjYW52YXNDb250YWluZXIub2Zmc2V0KCk7XG4gICAgICAgIGxldCBvZmZzZXRYID0gZXYucGFnZVggLSBvZmZzLmxlZnQ7XG4gICAgICAgIGxldCBvZmZzZXRZID0gZXYucGFnZVkgLSBvZmZzLnRvcDtcblxuICAgICAgICBpZiAodGhpcy5lZGl0TGVmdCkge1xuICAgICAgICAgIGxldCBuZXdYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZWRpdFJlY3QueCArIGVkaXRSZWN0LncgLSAxLCBNYXRoLnJvdW5kKG9mZnNldFggLyB0aGlzLnpvb20pKSk7XG4gICAgICAgICAgZWRpdFJlY3QudyA9IGVkaXRSZWN0LncgKyBlZGl0UmVjdC54IC0gbmV3WDtcbiAgICAgICAgICBlZGl0UmVjdC54ID0gbmV3WDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0VG9wKSB7XG4gICAgICAgICAgbGV0IG5ld1kgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlZGl0UmVjdC55ICsgZWRpdFJlY3QuaCAtIDEsIE1hdGgucm91bmQob2Zmc2V0WSAvIHRoaXMuem9vbSkpKTtcbiAgICAgICAgICBlZGl0UmVjdC5oID0gZWRpdFJlY3QuaCArIGVkaXRSZWN0LnkgLSBuZXdZO1xuICAgICAgICAgIGVkaXRSZWN0LnkgPSBuZXdZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRSaWdodCkge1xuICAgICAgICAgIGVkaXRSZWN0LncgPSBNYXRoLm1pbih0aGlzLnNyY1NpemUudyAtIGVkaXRSZWN0LngsXG4gICAgICAgICAgICAgIE1hdGgubWF4KDEsIE1hdGgucm91bmQob2Zmc2V0WCAvIHRoaXMuem9vbSkgLSBlZGl0UmVjdC54KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdEJvdHRvbSkge1xuICAgICAgICAgIGVkaXRSZWN0LmggPSBNYXRoLm1pbih0aGlzLnNyY1NpemUuaCAtIGVkaXRSZWN0LnksXG4gICAgICAgICAgICAgIE1hdGgubWF4KDEsIE1hdGgucm91bmQob2Zmc2V0WSAvIHRoaXMuem9vbSkgLSBlZGl0UmVjdC55KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZHJhd092ZXJsYXkoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VfKCk7XG4gICAgICB9O1xuICB9XG5cbiAgbG9hZFNvdXJjZUltYWdlKHNyY0N0eCwgaW5pdFJlY3RzID0ge30pIHtcbiAgICB0aGlzLiRjYW52YXNDb250YWluZXIuZW1wdHkoKTtcbiAgICAkKCcuZWRpdG9yLWJ1dHRvbicpLmF0dHIoJ2Rpc2FibGVkJywgc3JjQ3R4ID8gbnVsbCA6ICdkaXNhYmxlZCcpO1xuXG4gICAgaWYgKCFzcmNDdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNyY0N0eCA9IHNyY0N0eDtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc3RhZ2Ugc291cmNlIHNpemVcbiAgICBsZXQgc3JjU2l6ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgbmV3U3JjU2l6ZSA9IHsgdzogdGhpcy5zcmNDdHguY2FudmFzLndpZHRoLCBoOiB0aGlzLnNyY0N0eC5jYW52YXMuaGVpZ2h0IH07XG4gICAgc3JjU2l6ZUNoYW5nZWQgPSAhdGhpcy5zcmNTaXplXG4gICAgICAgIHx8IHRoaXMuc3JjU2l6ZS53ICE9IG5ld1NyY1NpemUud1xuICAgICAgICB8fCB0aGlzLnNyY1NpemUuaCAhPSBuZXdTcmNTaXplLmg7XG4gICAgdGhpcy5zcmNTaXplID0gbmV3U3JjU2l6ZTtcblxuICAgIC8vIFJlc2V0IHRoZSBzdHJldGNoLCBwYWRkaW5nL2NvbnRlbnQsIGFuZCBvcHRpY2FsIGJvdW5kcyByZWdpb25zXG4gICAgaWYgKHNyY1NpemVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnN0cmV0Y2hSZWN0ID0gaW5pdFJlY3RzLnN0cmV0Y2hSZWN0IHx8IHtcbiAgICAgICAgeDogTWF0aC5mbG9vcih0aGlzLnNyY1NpemUudyAvIDMpLFxuICAgICAgICB5OiBNYXRoLmZsb29yKHRoaXMuc3JjU2l6ZS5oIC8gMyksXG4gICAgICAgIHc6IE1hdGguY2VpbCh0aGlzLnNyY1NpemUudyAvIDMpLFxuICAgICAgICBoOiBNYXRoLmNlaWwodGhpcy5zcmNTaXplLmggLyAzKVxuICAgICAgfTtcblxuICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGluaXRSZWN0cy5jb250ZW50UmVjdCB8fCB7IHg6IDAsIHk6IDAsIHc6IHRoaXMuc3JjU2l6ZS53LCBoOiB0aGlzLnNyY1NpemUuaCB9O1xuICAgICAgdGhpcy5vcHRpY2FsQm91bmRzUmVjdCA9IGluaXRSZWN0cy5vcHRpY2FsQm91bmRzUmVjdCB8fCB7IHg6IDAsIHk6IDAsIHc6IHRoaXMuc3JjU2l6ZS53LCBoOiB0aGlzLnNyY1NpemUuaCB9O1xuICAgIH1cblxuICAgIGlmICghaW5pdFJlY3RzLnN0cmV0Y2hSZWN0KSB7XG4gICAgICB0aGlzLmxvYWRMYXN0UmVjdHMoKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIHN0YWdlIGNhbnZhc1xuICAgIHRoaXMuJGltYWdlQ2FudmFzID0gJCgnPGNhbnZhcz4nKVxuICAgICAgICAuYXR0cih7XG4gICAgICAgICAgd2lkdGg6IHRoaXMuc3JjU2l6ZS53LFxuICAgICAgICAgIGhlaWdodDogdGhpcy5zcmNTaXplLmhcbiAgICAgICAgfSlcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICB0aGlzLiRvdmVybGF5Q2FudmFzID0gJCgnPGNhbnZhcz4nKS5hZGRDbGFzcygnb3ZlcmxheScpLmFwcGVuZFRvKHRoaXMuJGNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICB0aGlzLnJlbGF5b3V0KCk7XG4gICAgdGhpcy5yZWRyYXdJbWFnZSgpO1xuICAgIHRoaXMucmVkcmF3T3ZlcmxheSgpO1xuICAgIHRoaXMubm90aWZ5Q2hhbmdlXygpO1xuICB9XG5cbiAgcmVsYXlvdXQoKSB7XG4gICAgaWYgKCF0aGlzLiRpbWFnZUNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgYSB6b29tIGxldmVsIHRoYXQnbGwgc2hvdyB0aGUgc3RhZ2UgYXMgbGFyZ2UgYXMgcG9zc2libGVcbiAgICBsZXQgaG9yaXpNYXhab29tID0gTWF0aC5mbG9vcih0aGlzLiRzdGFnZS53aWR0aCgpIC8gdGhpcy5zcmNTaXplLncpO1xuICAgIGxldCB2ZXJ0TWF4Wm9vbSA9IE1hdGguZmxvb3IodGhpcy4kc3RhZ2UuaGVpZ2h0KCkgLyB0aGlzLnNyY1NpemUuaCk7XG4gICAgdGhpcy56b29tID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oaG9yaXpNYXhab29tLCB2ZXJ0TWF4Wm9vbSkpO1xuICAgIHRoaXMuem9vbWVkU2l6ZSA9IHtcbiAgICAgIHc6IHRoaXMuc3JjU2l6ZS53ICogdGhpcy56b29tLFxuICAgICAgaDogdGhpcy5zcmNTaXplLmggKiB0aGlzLnpvb21cbiAgICB9O1xuXG4gICAgdGhpcy4kaW1hZ2VDYW52YXMuY3NzKHtcbiAgICAgIHdpZHRoOiB0aGlzLnpvb21lZFNpemUudyxcbiAgICAgIGhlaWdodDogdGhpcy56b29tZWRTaXplLmhcbiAgICB9KTtcbiAgICB0aGlzLiRvdmVybGF5Q2FudmFzLmF0dHIoe1xuICAgICAgd2lkdGg6IHRoaXMuem9vbWVkU2l6ZS53LFxuICAgICAgaGVpZ2h0OiB0aGlzLnpvb21lZFNpemUuaFxuICAgIH0pO1xuICB9XG5cbiAgcmVkcmF3SW1hZ2UoKSB7XG4gICAgaWYgKCF0aGlzLiRpbWFnZUNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBpbWdDdHggPSB0aGlzLiRpbWFnZUNhbnZhcy5nZXQoMCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpbWdDdHguZmlsbFN0eWxlID0gKHRoaXMubWF0dGVDb2xvciA9PSAnbGlnaHQnKSA/ICcjZWVlJyA6ICcjNTU1JztcbiAgICBpbWdDdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5zcmNTaXplLncsIHRoaXMuc3JjU2l6ZS5oKTtcblxuICAgIC8vIGRyYXcgc291cmNlIGdyYXBoaWNcbiAgICBpbWdDdHguZHJhd0ltYWdlKHRoaXMuc3JjQ3R4LmNhbnZhcywgMCwgMCk7XG4gIH1cblxuICByZWRyYXdPdmVybGF5KCkge1xuICAgIGlmICghdGhpcy5zcmNDdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZWRpdFJlY3QgPSB7XG4gICAgICBzdHJldGNoOiB0aGlzLnN0cmV0Y2hSZWN0LFxuICAgICAgcGFkZGluZzogdGhpcy5jb250ZW50UmVjdCxcbiAgICAgIG9wdGljYWxib3VuZHM6IHRoaXMub3B0aWNhbEJvdW5kc1JlY3RcbiAgICB9W3RoaXMuZWRpdE1vZGVdO1xuXG4gICAgbGV0IGN0eCA9IHRoaXMuJG92ZXJsYXlDYW52YXMuZ2V0KDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnpvb21lZFNpemUudywgdGhpcy56b29tZWRTaXplLmgpO1xuICAgIGN0eC5zYXZlKCk7XG5cbiAgICAvLyBkcmF3IGN1cnJlbnQgZWRpdCByZWdpb25cbiAgICBpZiAoZWRpdFJlY3QgPT09IHRoaXMuc3RyZXRjaFJlY3QpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgY3R4Lm1vdmVUbygwLCBlZGl0UmVjdC55ICogdGhpcy56b29tICsgLjUpO1xuICAgICAgY3R4LmxpbmVUbyh0aGlzLnpvb21lZFNpemUudywgZWRpdFJlY3QueSAqIHRoaXMuem9vbSArIC41KTtcblxuICAgICAgY3R4Lm1vdmVUbygwLCAoZWRpdFJlY3QueSArIGVkaXRSZWN0LmgpICogdGhpcy56b29tIC0gLjUpO1xuICAgICAgY3R4LmxpbmVUbyh0aGlzLnpvb21lZFNpemUudywgKGVkaXRSZWN0LnkgKyBlZGl0UmVjdC5oKSAqIHRoaXMuem9vbSAtIC41KTtcblxuICAgICAgY3R4Lm1vdmVUbyhlZGl0UmVjdC54ICogdGhpcy56b29tICsgLjUsIDApO1xuICAgICAgY3R4LmxpbmVUbyhlZGl0UmVjdC54ICogdGhpcy56b29tICsgLjUsIHRoaXMuem9vbWVkU2l6ZS5oKTtcblxuICAgICAgY3R4Lm1vdmVUbygoZWRpdFJlY3QueCArIGVkaXRSZWN0LncpICogdGhpcy56b29tIC0gLjUsIDApO1xuICAgICAgY3R4LmxpbmVUbygoZWRpdFJlY3QueCArIGVkaXRSZWN0LncpICogdGhpcy56b29tIC0gLjUsIHRoaXMuem9vbWVkU2l6ZS5oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnJlY3QoXG4gICAgICAgICAgZWRpdFJlY3QueCAqIHRoaXMuem9vbSArIC41LCBlZGl0UmVjdC55ICogdGhpcy56b29tICsgLjUsXG4gICAgICAgICAgZWRpdFJlY3QudyAqIHRoaXMuem9vbSAtIDEsIGVkaXRSZWN0LmggKiB0aGlzLnpvb20gLSAxKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMSknO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDIzLCA2OCwgMSknO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIC41KSc7XG4gICAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIC41KSc7XG4gICAgICBjdHguc2V0TGluZURhc2goWzMsIDNdKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAvLyBkcmF3IGRpc3RhbmNlIGxhYmVsc1xuICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICBsZXQgc3RhZ2VPZmZzZXQgPSB0aGlzLiRjYW52YXNDb250YWluZXIub2Zmc2V0KCk7XG5cbiAgICAgIHRoaXMuJGxlZnRMYWJlbFxuICAgICAgICAgIC50ZXh0KGVkaXRSZWN0LngpXG4gICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICBsZWZ0OiBzdGFnZU9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgd2lkdGg6IGVkaXRSZWN0LnggKiB0aGlzLnpvb20sXG4gICAgICAgICAgICB0b3A6IHN0YWdlT2Zmc2V0LnRvcCArIChlZGl0UmVjdC55ICsgZWRpdFJlY3QuaCAvIDIpICogdGhpcy56b29tXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2hvdygpO1xuXG4gICAgICB0aGlzLiRyaWdodExhYmVsXG4gICAgICAgICAgLnRleHQodGhpcy5zcmNTaXplLncgLSBlZGl0UmVjdC54IC0gZWRpdFJlY3QudylcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YWdlT2Zmc2V0LmxlZnQgKyAoZWRpdFJlY3QueCArIGVkaXRSZWN0LncpICogdGhpcy56b29tLFxuICAgICAgICAgICAgd2lkdGg6ICh0aGlzLnNyY1NpemUudyAtIGVkaXRSZWN0LnggLSBlZGl0UmVjdC53KSAqIHRoaXMuem9vbSxcbiAgICAgICAgICAgIHRvcDogc3RhZ2VPZmZzZXQudG9wICsgKGVkaXRSZWN0LnkgKyBlZGl0UmVjdC5oIC8gMikgKiB0aGlzLnpvb21cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zaG93KCk7XG5cbiAgICAgIHRoaXMuJHRvcExhYmVsXG4gICAgICAgICAgLnRleHQoZWRpdFJlY3QueSlcbiAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgIHRvcDogc3RhZ2VPZmZzZXQudG9wLFxuICAgICAgICAgICAgaGVpZ2h0OiBlZGl0UmVjdC55ICogdGhpcy56b29tLFxuICAgICAgICAgICAgbGVmdDogc3RhZ2VPZmZzZXQubGVmdCArIChlZGl0UmVjdC54ICsgZWRpdFJlY3QudyAvIDIpICogdGhpcy56b29tXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2hvdygpO1xuXG4gICAgICB0aGlzLiRib3R0b21MYWJlbFxuICAgICAgICAgIC50ZXh0KHRoaXMuc3JjU2l6ZS5oIC0gZWRpdFJlY3QueSAtIGVkaXRSZWN0LmgpXG4gICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICB0b3A6IHN0YWdlT2Zmc2V0LnRvcCArIChlZGl0UmVjdC55ICsgZWRpdFJlY3QuaCkgKiB0aGlzLnpvb20sXG4gICAgICAgICAgICBoZWlnaHQ6ICh0aGlzLnNyY1NpemUuaCAtIGVkaXRSZWN0LnkgLSBlZGl0UmVjdC5oKSAqIHRoaXMuem9vbSxcbiAgICAgICAgICAgIGxlZnQ6IHN0YWdlT2Zmc2V0LmxlZnQgKyAoZWRpdFJlY3QueCArIGVkaXRSZWN0LncgLyAyKSAqIHRoaXMuem9vbVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kdG9wTGFiZWwuaGlkZSgpO1xuICAgICAgdGhpcy4kbGVmdExhYmVsLmhpZGUoKTtcbiAgICAgIHRoaXMuJHJpZ2h0TGFiZWwuaGlkZSgpO1xuICAgICAgdGhpcy4kYm90dG9tTGFiZWwuaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsb2NhbFN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIGBhc3NldFN0dWRpb05pbmVQYXRjaFN0YWdlLSR7dGhpcy5uYW1lfWA7XG4gIH1cblxuICBzYXZlUmVjdHMoKSB7XG4gICAgbG9jYWxTdG9yYWdlW3RoaXMubG9jYWxTdG9yYWdlS2V5XSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHN0cmV0Y2hSZWN0OiB0aGlzLnN0cmV0Y2hSZWN0LFxuICAgICAgY29udGVudFJlY3Q6IHRoaXMuY29udGVudFJlY3QsXG4gICAgICBvcHRpY2FsQm91bmRzUmVjdDogdGhpcy5vcHRpY2FsQm91bmRzUmVjdFxuICAgIH0pO1xuICB9XG5cbiAgbG9hZExhc3RSZWN0cygpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IHN0b3JlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXldKTtcbiAgICAgIGlmIChzdG9yZS5zdHJldGNoUmVjdCAmJiBzdG9yZS5jb250ZW50UmVjdCAmJiBzdG9yZS5vcHRpY2FsQm91bmRzUmVjdCkge1xuICAgICAgICB0aGlzLnN0cmV0Y2hSZWN0ID0gZml0UmVjdF8oc3RvcmUuc3RyZXRjaFJlY3QsIHRoaXMuc3JjU2l6ZSk7XG4gICAgICAgIHRoaXMuY29udGVudFJlY3QgPSBmaXRSZWN0XyhzdG9yZS5jb250ZW50UmVjdCwgdGhpcy5zcmNTaXplKTtcbiAgICAgICAgdGhpcy5vcHRpY2FsQm91bmRzUmVjdCA9IGZpdFJlY3RfKHN0b3JlLm9wdGljYWxCb3VuZHNSZWN0LCB0aGlzLnNyY1NpemUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gZml0UmVjdF8ocmVjdCwgc2l6ZSkge1xuICBsZXQgbmV3UmVjdCA9IHt9O1xuICBuZXdSZWN0LnggPSBNYXRoLm1heCgwLCByZWN0LngpO1xuICBuZXdSZWN0LnkgPSBNYXRoLm1heCgwLCByZWN0LnkpO1xuICBuZXdSZWN0LncgPSBNYXRoLm1pbihzaXplLncgLSByZWN0LngsIHJlY3Qudyk7XG4gIG5ld1JlY3QuaCA9IE1hdGgubWluKHNpemUuaCAtIHJlY3QueSwgcmVjdC5oKTtcbiAgcmV0dXJuIG5ld1JlY3Q7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vLi4vaW1hZ2VsaWInO1xuaW1wb3J0IHtTdW1tZXJ9IGZyb20gJy4vU3VtbWVyJztcblxuZXhwb3J0IGNvbnN0IE5pbmVQYXRjaFRyaW1taW5nID0ge1xuICAvKipcbiAgICogVHJpbXMgZXhjZXNzIGVkZ2VzIG9mIHRoZSBuaW5lIHBhdGNoLi4uIGFueSBwaXhlbHMgdGhhdCBhcmUgdGhlIHNhbWVcbiAgICogYXMgdGhlIHRvcC1sZWZ0IG1vc3QgcGl4ZWwgY29sb3IuIFNhbWUgYXMgUGhvdG9zaG9wJ3MgVHJpbSBmZWF0dXJlLlxuICAgKi9cbiAgdHJpbUVkZ2VzKHN0YWdlKSB7XG4gICAgaWYgKCFzdGFnZS5zcmNDdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzcmNEYXRhID0gc3RhZ2Uuc3JjQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBzdGFnZS5zcmNTaXplLncsIHN0YWdlLnNyY1NpemUuaCk7XG5cbiAgICAvLyBBbHdheXMgdHJpbSBieSB0b3AtbGVmdCBwaXhlbCBjb2xvclxuICAgIGNvbnN0IHRyaW1QaXhlbCA9IGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgMCwgMCk7XG5cbiAgICBsZXQgaW5zZXRSZWN0ID0ge2w6MCwgdDowLCByOjAsIGI6MH07XG4gICAgbGV0IHgsIHk7XG5cbiAgICAvLyBUcmltIHRvcFxuICAgIHRyaW1Ub3A6XG4gICAgZm9yICh5ID0gMDsgeSA8IHN0YWdlLnNyY1NpemUuaDsgeSsrKSB7XG4gICAgICBmb3IgKHggPSAwOyB4IDwgc3RhZ2Uuc3JjU2l6ZS53OyB4KyspIHtcbiAgICAgICAgaWYgKGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgeCwgeSkgIT0gdHJpbVBpeGVsKSB7XG4gICAgICAgICAgYnJlYWsgdHJpbVRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnNldFJlY3QudCA9IHk7XG4gICAgLy8gVHJpbSBsZWZ0XG4gICAgdHJpbUxlZnQ6XG4gICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgICAgaWYgKGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgeCwgeSkgIT0gdHJpbVBpeGVsKSB7XG4gICAgICAgICAgYnJlYWsgdHJpbUxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zZXRSZWN0LmwgPSB4O1xuICAgIC8vIFRyaW0gYm90dG9tXG4gICAgdHJpbUJvdHRvbTpcbiAgICBmb3IgKHkgPSBzdGFnZS5zcmNTaXplLmggLSAxOyB5ID49IDA7IHktLSkge1xuICAgICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICAgIGlmIChnZXRQaXhlbF8oc3RhZ2UsIHNyY0RhdGEsIHgsIHkpICE9IHRyaW1QaXhlbCkge1xuICAgICAgICAgIGJyZWFrIHRyaW1Cb3R0b207XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zZXRSZWN0LmIgPSBzdGFnZS5zcmNTaXplLmggLSB5IC0gMTtcbiAgICAvLyBUcmltIHJpZ2h0XG4gICAgdHJpbVJpZ2h0OlxuICAgIGZvciAoeCA9IHN0YWdlLnNyY1NpemUudyAtIDE7IHggPj0gMDsgeC0tKSB7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgICAgaWYgKGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgeCwgeSkgIT0gdHJpbVBpeGVsKSB7XG4gICAgICAgICAgYnJlYWsgdHJpbVJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGluc2V0UmVjdC5yID0gc3RhZ2Uuc3JjU2l6ZS53IC0geCAtIDE7XG5cbiAgICBpZiAoaW5zZXRSZWN0LmwgPD0gMCAmJiBpbnNldFJlY3QudCA8PSAwICYmIGluc2V0UmVjdC5yIDw9IDAgJiYgaW5zZXRSZWN0LmIgPD0gMCkge1xuICAgICAgLy8gTm8tb3BcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBhIG5ldyBzdGFnZSB3aXRoIGluc2V0IHZhbHVlc1xuICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICB3OiBzdGFnZS5zcmNTaXplLncgLSBpbnNldFJlY3QubCAtIGluc2V0UmVjdC5yLFxuICAgICAgaDogc3RhZ2Uuc3JjU2l6ZS5oIC0gaW5zZXRSZWN0LnQgLSBpbnNldFJlY3QuYlxuICAgIH07XG5cbiAgICBjb25zdCByZWN0cyA9IHtcbiAgICAgIGNvbnRlbnRSZWN0OiBjb25zdHJhaW5fKHNpemUsIHtcbiAgICAgICAgeDogc3RhZ2UuY29udGVudFJlY3QueCAtIGluc2V0UmVjdC5sLFxuICAgICAgICB5OiBzdGFnZS5jb250ZW50UmVjdC55IC0gaW5zZXRSZWN0LnQsXG4gICAgICAgIHc6IHN0YWdlLmNvbnRlbnRSZWN0LncsXG4gICAgICAgIGg6IHN0YWdlLmNvbnRlbnRSZWN0LmhcbiAgICAgIH0pLFxuICAgICAgc3RyZXRjaFJlY3Q6IGNvbnN0cmFpbl8oc2l6ZSwge1xuICAgICAgICB4OiBzdGFnZS5zdHJldGNoUmVjdC54IC0gaW5zZXRSZWN0LmwsXG4gICAgICAgIHk6IHN0YWdlLnN0cmV0Y2hSZWN0LnkgLSBpbnNldFJlY3QudCxcbiAgICAgICAgdzogc3RhZ2Uuc3RyZXRjaFJlY3QudyxcbiAgICAgICAgaDogc3RhZ2Uuc3RyZXRjaFJlY3QuaFxuICAgICAgfSksXG4gICAgICBvcHRpY2FsQm91bmRzUmVjdDogY29uc3RyYWluXyhzaXplLCB7XG4gICAgICAgIHg6IHN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LnggLSBpbnNldFJlY3QubCxcbiAgICAgICAgeTogc3RhZ2Uub3B0aWNhbEJvdW5kc1JlY3QueSAtIGluc2V0UmVjdC50LFxuICAgICAgICB3OiBzdGFnZS5vcHRpY2FsQm91bmRzUmVjdC53LFxuICAgICAgICBoOiBzdGFnZS5vcHRpY2FsQm91bmRzUmVjdC5oXG4gICAgICB9KVxuICAgIH07XG5cbiAgICBzdGFnZS5uYW1lID0gYCR7c3RhZ2UubmFtZX0tRURHRVNfVFJJTU1FRGA7XG4gICAgbGV0IG5ld0N0eCA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dChzaXplKTtcbiAgICBuZXdDdHguZHJhd0ltYWdlKHN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgIGluc2V0UmVjdC5sLCBpbnNldFJlY3QudCwgc2l6ZS53LCBzaXplLmgsXG4gICAgICAgIDAsIDAsIHNpemUudywgc2l6ZS5oKTtcbiAgICBzdGFnZS5sb2FkU291cmNlSW1hZ2UobmV3Q3R4LCByZWN0cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyaW1zIGV4Y2VzcyByb3dzIGFuZCBjb2x1bW5zIGZyb20gdGhlIHN0cmV0Y2ggcmVnaW9uIG9mIHRoZSBnaXZlblxuICAgKiBuaW5lIHBhdGNoIHN0YWdlLlxuICAgKi9cbiAgdHJpbVN0cmV0Y2hSZWdpb24oc3RhZ2UpIHtcbiAgICBpZiAoIXN0YWdlLnNyY0N0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNyY0RhdGEgPSBzdGFnZS5zcmNDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHN0YWdlLnNyY1NpemUudywgc3RhZ2Uuc3JjU2l6ZS5oKTtcblxuICAgIGxldCBjb2xsYXBzZVggPSBzdGFnZS5zdHJldGNoUmVjdC53ID4gNDsgLy8gZ2VuZXJhbGx5IGdvaW5nIHRvIHN0YXJ0IGFzIHRydWVcbiAgICBsZXQgY29sbGFwc2VZID0gc3RhZ2Uuc3RyZXRjaFJlY3QuaCA+IDQ7IC8vIGdlbmVyYWxseSBnb2luZyB0byBzdGFydCBhcyB0cnVlXG4gICAgbGV0IHgsIHk7XG5cbiAgICAvLyBTZWUgaWYgY29sbGFwc2UgaXMgcG9zc2libGUgaW4gZWl0aGVyIGRpcmVjdGlvbiBieSBjb21wYXJpbmcgcm93L2NvbHVtbiBzdW1zLlxuICAgIGNvbnN0IHN1bW1lciA9IG5ldyBTdW1tZXIoKTtcblxuICAgIC8vIFNlZSBpZiBjYW4gYmUgaG9yaXpvbnRhbGx5IGNvbGxhcHNlZC5cbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBmaXJzdFN1bSA9IC0xO1xuICAgIGZvciAoeCA9IHN0YWdlLnN0cmV0Y2hSZWN0Lng7IHggPCAoc3RhZ2Uuc3RyZXRjaFJlY3QueCArIHN0YWdlLnN0cmV0Y2hSZWN0LncpOyB4KyspIHtcbiAgICAgIC8vIENvbXB1dGUgY29sdW1uXG4gICAgICBzdW1tZXIucmVzZXQoKTtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgICBzdW1tZXIuYWRkTmV4dChnZXRQaXhlbF8oc3RhZ2UsIHNyY0RhdGEsIHgsIHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdFN1bSA9IHN1bW1lci5jb21wdXRlKCk7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHN1bW1lci5jb21wdXRlKCkgIT0gZmlyc3RTdW0pIHtcbiAgICAgICAgY29sbGFwc2VYID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICBmb3IgKHkgPSBzdGFnZS5zdHJldGNoUmVjdC55OyB5IDwgKHN0YWdlLnN0cmV0Y2hSZWN0LnkgKyBzdGFnZS5zdHJldGNoUmVjdC5oKTsgeSsrKSB7XG4gICAgICAvLyBDb21wdXRlIHJvd1xuICAgICAgc3VtbWVyLnJlc2V0KCk7XG4gICAgICBmb3IgKHggPSAwOyB4IDwgc3RhZ2Uuc3JjU2l6ZS53OyB4KyspIHtcbiAgICAgICAgc3VtbWVyLmFkZE5leHQoZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCB4LCB5KSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3RTdW0gPSBzdW1tZXIuY29tcHV0ZSgpO1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChzdW1tZXIuY29tcHV0ZSgpICE9IGZpcnN0U3VtKSB7XG4gICAgICAgIGNvbGxhcHNlWSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbGxhcHNlWCAmJiAhY29sbGFwc2VZKSB7XG4gICAgICAvLyBOby1vcFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpeGVkID0ge1xuICAgICAgbDogc3RhZ2Uuc3RyZXRjaFJlY3QueCxcbiAgICAgIHQ6IHN0YWdlLnN0cmV0Y2hSZWN0LnksXG4gICAgICByOiBzdGFnZS5zcmNTaXplLncgLSBzdGFnZS5zdHJldGNoUmVjdC54IC0gc3RhZ2Uuc3RyZXRjaFJlY3QudyxcbiAgICAgIGI6IHN0YWdlLnNyY1NpemUuaCAtIHN0YWdlLnN0cmV0Y2hSZWN0LnkgLSBzdGFnZS5zdHJldGNoUmVjdC5oXG4gICAgfTtcblxuICAgIGNvbnN0IG1pZGRsZSA9IHtcbiAgICAgIHc6IGNvbGxhcHNlWCA/IDQgOiBzdGFnZS5zdHJldGNoUmVjdC53LFxuICAgICAgaDogY29sbGFwc2VZID8gNCA6IHN0YWdlLnN0cmV0Y2hSZWN0LmhcbiAgICB9O1xuXG4gICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgIHc6IGZpeGVkLmwgKyBtaWRkbGUudyArIGZpeGVkLnIsXG4gICAgICBoOiBmaXhlZC50ICsgbWlkZGxlLmggKyBmaXhlZC5iXG4gICAgfTtcblxuICAgIC8vIFJlZHJhdyBjb21wb25lbnRzXG4gICAgY29uc3QgY3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KHNpemUpO1xuXG4gICAgLy8gVExcbiAgICBpZiAoZml4ZWQubCAmJiBmaXhlZC50KVxuICAgICAgY3R4LmRyYXdJbWFnZShzdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgIDAsIDAsIGZpeGVkLmwsIGZpeGVkLnQsXG4gICAgICAgICAgMCwgMCwgZml4ZWQubCwgZml4ZWQudCk7XG5cbiAgICAvLyBCTFxuICAgIGlmIChmaXhlZC5sICYmIGZpeGVkLmIpXG4gICAgICBjdHguZHJhd0ltYWdlKHN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgMCwgc3RhZ2Uuc3JjU2l6ZS5oIC0gZml4ZWQuYiwgZml4ZWQubCwgZml4ZWQuYixcbiAgICAgICAgICAwLCBzaXplLmggLSBmaXhlZC5iLCBmaXhlZC5sLCBmaXhlZC5iKTtcblxuICAgIC8vIFRSXG4gICAgaWYgKGZpeGVkLnIgJiYgZml4ZWQudClcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICBzdGFnZS5zcmNTaXplLncgLSBmaXhlZC5yLCAwLCBmaXhlZC5yLCBmaXhlZC50LFxuICAgICAgICAgIHNpemUudyAtIGZpeGVkLnIsIDAsIGZpeGVkLnIsIGZpeGVkLnQpO1xuXG4gICAgLy8gQlJcbiAgICBpZiAoZml4ZWQuciAmJiBmaXhlZC5iKVxuICAgICAgY3R4LmRyYXdJbWFnZShzdGFnZS5zcmNDdHguY2FudmFzLFxuICAgICAgICAgIHN0YWdlLnNyY1NpemUudyAtIGZpeGVkLnIsIHN0YWdlLnNyY1NpemUuaCAtIGZpeGVkLmIsIGZpeGVkLnIsIGZpeGVkLmIsXG4gICAgICAgICAgc2l6ZS53IC0gZml4ZWQuciwgc2l6ZS5oIC0gZml4ZWQuYiwgZml4ZWQuciwgZml4ZWQuYik7XG5cbiAgICAvLyBUb3BcbiAgICBpZiAoZml4ZWQudClcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICBmaXhlZC5sLCAwLCBzdGFnZS5zdHJldGNoUmVjdC53LCBmaXhlZC50LFxuICAgICAgICAgIGZpeGVkLmwsIDAsIHNpemUudyAtIGZpeGVkLmwgLSBmaXhlZC5yLCBmaXhlZC50KTtcblxuICAgIC8vIExlZnRcbiAgICBpZiAoZml4ZWQubClcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICAwLCBmaXhlZC50LCBmaXhlZC5sLCBzdGFnZS5zdHJldGNoUmVjdC5oLFxuICAgICAgICAgIDAsIGZpeGVkLnQsIGZpeGVkLmwsIHNpemUuaCAtIGZpeGVkLnQgLSBmaXhlZC5iKTtcblxuICAgIC8vIFJpZ2h0XG4gICAgaWYgKGZpeGVkLnIpXG4gICAgICBjdHguZHJhd0ltYWdlKHN0YWdlLnNyY0N0eC5jYW52YXMsXG4gICAgICAgICAgc3RhZ2Uuc3JjU2l6ZS53IC0gZml4ZWQuciwgZml4ZWQudCwgZml4ZWQuciwgc3RhZ2Uuc3RyZXRjaFJlY3QuaCxcbiAgICAgICAgICBzaXplLncgLSBmaXhlZC5yLCBmaXhlZC50LCBmaXhlZC5yLCBzaXplLmggLSBmaXhlZC50IC0gZml4ZWQuYik7XG5cbiAgICAvLyBCb3R0b21cbiAgICBpZiAoZml4ZWQuYilcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgICBmaXhlZC5sLCBzdGFnZS5zcmNTaXplLmggLSBmaXhlZC5iLCBzdGFnZS5zdHJldGNoUmVjdC53LCBmaXhlZC5iLFxuICAgICAgICAgIGZpeGVkLmwsIHNpemUuaCAtIGZpeGVkLmIsIHNpemUudyAtIGZpeGVkLmwgLSBmaXhlZC5yLCBmaXhlZC5iKTtcblxuICAgIC8vIE1pZGRsZVxuICAgIGN0eC5kcmF3SW1hZ2Uoc3RhZ2Uuc3JjQ3R4LmNhbnZhcyxcbiAgICAgICAgZml4ZWQubCwgZml4ZWQudCwgc3RhZ2Uuc3RyZXRjaFJlY3Qudywgc3RhZ2Uuc3RyZXRjaFJlY3QuaCxcbiAgICAgICAgZml4ZWQubCwgZml4ZWQudCwgc2l6ZS53IC0gZml4ZWQubCAtIGZpeGVkLnIsIHNpemUuaCAtIGZpeGVkLnQgLSBmaXhlZC5iKTtcblxuICAgIGNvbnN0IHJlY3RzID0ge1xuICAgICAgc3RyZXRjaFJlY3Q6IHtcbiAgICAgICAgeDogc3RhZ2Uuc3RyZXRjaFJlY3QueCxcbiAgICAgICAgeTogc3RhZ2Uuc3RyZXRjaFJlY3QueSxcbiAgICAgICAgdzogbWlkZGxlLncsXG4gICAgICAgIGg6IG1pZGRsZS5oXG4gICAgICB9LFxuICAgICAgY29udGVudFJlY3Q6IHtcbiAgICAgICAgeDogc3RhZ2UuY29udGVudFJlY3QueCxcbiAgICAgICAgeTogc3RhZ2UuY29udGVudFJlY3QueSxcbiAgICAgICAgdzogc3RhZ2UuY29udGVudFJlY3QudyArIG1pZGRsZS53IC0gc3RhZ2Uuc3RyZXRjaFJlY3QudyxcbiAgICAgICAgaDogc3RhZ2UuY29udGVudFJlY3QuaCArIG1pZGRsZS5oIC0gc3RhZ2Uuc3RyZXRjaFJlY3QuaFxuICAgICAgfSxcbiAgICAgIG9wdGljYWxCb3VuZHNSZWN0OiB7XG4gICAgICAgIHg6IHN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LngsXG4gICAgICAgIHk6IHN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LnksXG4gICAgICAgIHc6IHN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LncgKyBtaWRkbGUudyAtIHN0YWdlLnN0cmV0Y2hSZWN0LncsXG4gICAgICAgIGg6IHN0YWdlLm9wdGljYWxCb3VuZHNSZWN0LmggKyBtaWRkbGUuaCAtIHN0YWdlLnN0cmV0Y2hSZWN0LmhcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhZ2UubmFtZSA9IGAke3N0YWdlLm5hbWV9LVNUUkVUQ0hfVFJJTU1FRGA7XG4gICAgc3RhZ2UubG9hZFNvdXJjZUltYWdlKGN0eCwgcmVjdHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmllcyB0byBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZ2l2ZW4gcmVnaW9uLlxuICAgKlxuICAgKiBSZWdpb24gc2hvdWxkIGJlIG9uZSBvZiAnc3RyZXRjaCcsICdwYWRkaW5nJywgb3IgJ29wdGljYWxib3VuZHMnXG4gICAqL1xuICBkZXRlY3RSZWdpb24oc3RhZ2UsIHJlZ2lvblRvRmluZCkge1xuICAgIGlmICghc3RhZ2Uuc3JjQ3R4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzcmNEYXRhID0gc3RhZ2Uuc3JjQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBzdGFnZS5zcmNTaXplLncsIHN0YWdlLnNyY1NpemUuaCk7XG5cbiAgICBsZXQgeCwgeTtcblxuICAgIC8vIEZpcnN0IGZpbmQgb3B0aWNhbCBib3VuZHNcbiAgICAvLyBUaGlzIHdvcmtzIGJ5IHRha2luZyBhbiBhbHBoYSB2YWx1ZSBoaXN0b2dyYW0gYW5kIGZpbmRpbmcgdHdvIG1heGltYSB0byBkZXRlcm1pbmVcbiAgICAvLyBsb3cgYW5kIGhpZ2ggYWxwaGFzLlxuICAgIGxldCBhbHBoYUhpc3RvZ3JhbSA9IFtdO1xuICAgIGZvciAoeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHN0YWdlLnNyY1NpemUuaDsgeSsrKSB7XG4gICAgICAgIGxldCBhbHBoYSA9IHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDNdO1xuICAgICAgICBhbHBoYUhpc3RvZ3JhbVthbHBoYV0gPSBhbHBoYUhpc3RvZ3JhbVthbHBoYV0gPyBhbHBoYUhpc3RvZ3JhbVthbHBoYV0gKyAxIDogMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbWF4MSA9IDAsIG1heDFGcmVxID0gMCwgbWF4MiA9IDAsIG1heDJGcmVxID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoYWxwaGFIaXN0b2dyYW1baV0gPiBtYXgxRnJlcSkge1xuICAgICAgICBtYXgyID0gbWF4MTtcbiAgICAgICAgbWF4MkZyZXEgPSBtYXgxRnJlcTtcbiAgICAgICAgbWF4MSA9IGk7XG4gICAgICAgIG1heDFGcmVxID0gYWxwaGFIaXN0b2dyYW1baV07XG4gICAgICB9IGVsc2UgaWYgKGFscGhhSGlzdG9ncmFtW2ldID4gbWF4MkZyZXEpIHtcbiAgICAgICAgbWF4MiA9IGk7XG4gICAgICAgIG1heDJGcmVxID0gYWxwaGFIaXN0b2dyYW1baV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGFscGhhTWluID0gKG1heDEgPCBtYXgyKSA/IG1heDEgOiBtYXgyO1xuICAgIGxldCBhbHBoYU1heCA9IChtYXgxID4gbWF4MikgPyBtYXgxIDogbWF4MjtcblxuICAgIGNvbnN0IEFMUEhBX1RIUkVTSE9MRCA9IDU7XG5cbiAgICB2YXIgb3B0aWNhbEJvdW5kc1JlY3QgPSB7bDotMSwgcjotMSwgdDotMSwgYjotMX07XG5cbiAgICAvLyBGaW5kIGxlZnQgb3B0aWNhbCBib3VuZFxuICAgIG9ickxlZnQ6XG4gICAgZm9yICh4ID0gMDsgeCA8IHN0YWdlLnNyY1NpemUudzsgeCsrKSB7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgICAgdmFyIGFscGhhID0gc3JjRGF0YS5kYXRhWyh5ICogc3RhZ2Uuc3JjU2l6ZS53ICsgeCkgKiA0ICsgM107XG4gICAgICAgIGlmIChhbHBoYSA+PSBhbHBoYU1heCAtIEFMUEhBX1RIUkVTSE9MRCkge1xuICAgICAgICAgIG9wdGljYWxCb3VuZHNSZWN0LmwgPSB4O1xuICAgICAgICAgIGJyZWFrIG9ickxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCByaWdodCBvcHRpY2FsIGJvdW5kXG4gICAgb2JyUmlnaHQ6XG4gICAgZm9yICh4ID0gc3RhZ2Uuc3JjU2l6ZS53IC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgICB2YXIgYWxwaGEgPSBzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAzXTtcbiAgICAgICAgaWYgKGFscGhhID49IGFscGhhTWF4IC0gQUxQSEFfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgb3B0aWNhbEJvdW5kc1JlY3QuciA9IHg7XG4gICAgICAgICAgYnJlYWsgb2JyUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCB0b3Agb3B0aWNhbCBib3VuZFxuICAgIG9iclRvcDpcbiAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgIGZvciAoeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgICB2YXIgYWxwaGEgPSBzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAzXTtcbiAgICAgICAgaWYgKGFscGhhID49IGFscGhhTWF4IC0gQUxQSEFfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgb3B0aWNhbEJvdW5kc1JlY3QudCA9IHk7XG4gICAgICAgICAgYnJlYWsgb2JyVG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgYm90dG9tIG9wdGljYWwgYm91bmRcbiAgICBvYnJCb3R0b206XG4gICAgZm9yICh5ID0gc3RhZ2Uuc3JjU2l6ZS5oIC0gMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgIGZvciAoeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgICBsZXQgYWxwaGEgPSBzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAzXTtcbiAgICAgICAgaWYgKGFscGhhID49IGFscGhhTWF4IC0gQUxQSEFfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgb3B0aWNhbEJvdW5kc1JlY3QuYiA9IHk7XG4gICAgICAgICAgYnJlYWsgb2JyQm90dG9tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJldHVyblJlY3Q7XG5cbiAgICBpZiAob3B0aWNhbEJvdW5kc1JlY3QubCA+PSAwICYmIG9wdGljYWxCb3VuZHNSZWN0LnIgPiBvcHRpY2FsQm91bmRzUmVjdC5sXG4gICAgICAgICYmIG9wdGljYWxCb3VuZHNSZWN0LnQgPj0gMCAmJiBvcHRpY2FsQm91bmRzUmVjdC5iID4gb3B0aWNhbEJvdW5kc1JlY3QudCkge1xuICAgICAgbGV0IHJlY3QgPSB7XG4gICAgICAgIHg6IG9wdGljYWxCb3VuZHNSZWN0LmwsXG4gICAgICAgIHk6IG9wdGljYWxCb3VuZHNSZWN0LnQsXG4gICAgICAgIHc6IG9wdGljYWxCb3VuZHNSZWN0LnIgLSBvcHRpY2FsQm91bmRzUmVjdC5sICsgMSxcbiAgICAgICAgaDogb3B0aWNhbEJvdW5kc1JlY3QuYiAtIG9wdGljYWxCb3VuZHNSZWN0LnQgKyAxXG4gICAgICB9O1xuXG4gICAgICBpZiAocmVnaW9uVG9GaW5kID09ICdvcHRpY2FsYm91bmRzJyB8fCByZWdpb25Ub0ZpbmQgPT0gJ3BhZGRpbmcnKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5leHQgZmluZCBzdHJldGNoIHJlZ2lvbnMuIE9ubHkgdXNlIHRoZW0gaWYgdGhleSdyZSB3aXRoaW4gdGhlIG9wdGljYWwgYm91bmRzXG4gICAgaWYgKHJlZ2lvblRvRmluZCA9PSAnc3RyZXRjaCcpIHtcbiAgICAgIGxldCBuZXdTdHJldGNoUmVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHN0YWdlLnN0cmV0Y2hSZWN0KTtcblxuICAgICAgY29uc3Qgc3VtbWVyID0gbmV3IFN1bW1lcigpO1xuICAgICAgbGV0IHN1bXMgPSBbXTtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzdGFnZS5zcmNTaXplLmg7IHkrKykge1xuICAgICAgICAvLyBDb21wdXRlIHJvd1xuICAgICAgICBzdW1tZXIucmVzZXQoKTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgICAgIHN1bW1lci5hZGROZXh0KGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgeCwgeSkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bXMucHVzaChzdW1tZXIuY29tcHV0ZSgpKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJhbmdlcyA9IGdldEVxdWFsUmFuZ2VzXyhzdW1zKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbGV0IHBhc3Nlc1RocmVzaG9sZCA9IGZhbHNlO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHJvdyBoYXMgYSBtaW5pbXVtIGFscGhhXG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgICAgIGxldCBhbHBoYSA9IHNyY0RhdGEuZGF0YVsocmFuZ2Uuc3RhcnQgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAzXTtcbiAgICAgICAgICBpZiAoYWxwaGEgPj0gYWxwaGFNYXggLSBBTFBIQV9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIHBhc3Nlc1RocmVzaG9sZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhc3Nlc1RocmVzaG9sZCkge1xuICAgICAgICAgIG5ld1N0cmV0Y2hSZWN0LnkgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICBuZXdTdHJldGNoUmVjdC5oID0gcmFuZ2UubGVuZ3RoO1xuICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgLy8gaW5zZXQgYSBiaXQgdG8gcHJldmVudCBzY2FsaW5nIGFydGlmYWN0c1xuICAgICAgICAgICAgbmV3U3RyZXRjaFJlY3QueSsrO1xuICAgICAgICAgICAgbmV3U3RyZXRjaFJlY3QuaCAtPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdW1tZXIucmVzZXQoKTtcbiAgICAgIHN1bXMgPSBbXTtcbiAgICAgIGZvciAoeCA9IDA7IHggPCBzdGFnZS5zcmNTaXplLnc7IHgrKykge1xuICAgICAgICAvLyBDb21wdXRlIGNvbHVtblxuICAgICAgICBzdW1tZXIucmVzZXQoKTtcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IHN0YWdlLnNyY1NpemUuaDsgeSsrKSB7XG4gICAgICAgICAgc3VtbWVyLmFkZE5leHQoZ2V0UGl4ZWxfKHN0YWdlLCBzcmNEYXRhLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vtcy5wdXNoKHN1bW1lci5jb21wdXRlKCkpO1xuICAgICAgfVxuXG4gICAgICByYW5nZXMgPSBnZXRFcXVhbFJhbmdlc18oc3Vtcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIGxldCBwYXNzZXNUaHJlc2hvbGQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjb2x1bW4gaGFzIGEgbWluaW11bSBhbHBoYVxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgc3RhZ2Uuc3JjU2l6ZS5oOyB5KyspIHtcbiAgICAgICAgICBsZXQgYWxwaGEgPSBzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyByYW5nZS5zdGFydCkgKiA0ICsgM107XG4gICAgICAgICAgaWYgKGFscGhhID49IGFscGhhTWF4IC0gQUxQSEFfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICBwYXNzZXNUaHJlc2hvbGQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhc3Nlc1RocmVzaG9sZCkge1xuICAgICAgICAgIG5ld1N0cmV0Y2hSZWN0LnggPSByYW5nZS5zdGFydDtcbiAgICAgICAgICBuZXdTdHJldGNoUmVjdC53ID0gcmFuZ2UubGVuZ3RoO1xuICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgLy8gaW5zZXQgYSBiaXQgdG8gcHJldmVudCBzY2FsaW5nIGFydGlmYWN0c1xuICAgICAgICAgICAgbmV3U3RyZXRjaFJlY3QueCsrO1xuICAgICAgICAgICAgbmV3U3RyZXRjaFJlY3QudyAtPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RyZXRjaFJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG59O1xuXG5cbmZ1bmN0aW9uIGdldFBpeGVsXyhzdGFnZSwgc3JjRGF0YSwgeCwgeSkge1xuICByZXR1cm4gKHNyY0RhdGEuZGF0YVsoeSAqIHN0YWdlLnNyY1NpemUudyArIHgpICogNCArIDBdIDw8IDE2KSAvLyByXG4gICAgICArIChzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAxXSA8PCA4KSAvLyBnXG4gICAgICArIChzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAyXSA8PCAwKSAvLyBiXG4gICAgICArIChzcmNEYXRhLmRhdGFbKHkgKiBzdGFnZS5zcmNTaXplLncgKyB4KSAqIDQgKyAzXSA8PCAyNCk7IC8vIGFcbn1cblxuXG5mdW5jdGlvbiBjb25zdHJhaW5fKHNpemUsIHJlY3QpIHtcbiAgaWYgKHJlY3QueCA8IDApIHtcbiAgICByZWN0LncgKz0gcmVjdC54O1xuICAgIHJlY3QueCArPSAtcmVjdC54O1xuICB9XG4gIGlmIChyZWN0LnggKyByZWN0LncgPiBzaXplLncpIHtcbiAgICByZWN0LncgPSBzaXplLncgLSByZWN0Lng7XG4gIH1cbiAgaWYgKHJlY3QueSA8IDApIHtcbiAgICByZWN0LmggKz0gcmVjdC55O1xuICAgIHJlY3QueSArPSAtcmVjdC55O1xuICB9XG4gIGlmIChyZWN0LnkgKyByZWN0LmggPiBzaXplLmgpIHtcbiAgICByZWN0LmggPSBzaXplLmggLSByZWN0Lnk7XG4gIH1cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8vIEZpbmRzIHJhbmdlcyBvZiBlcXVhbCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5XG5mdW5jdGlvbiBnZXRFcXVhbFJhbmdlc18oYXJyKSB7XG4gIHZhciBlcXVhbFJhbmdlcyA9IFtdO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIHN0YXJ0VmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICBzdGFydCA9IGk7XG4gICAgICBzdGFydFZhbCA9IGFycltpXTtcbiAgICB9IGVsc2UgaWYgKGFycltpXSAhPSBzdGFydFZhbCkge1xuICAgICAgaWYgKHN0YXJ0ICE9IGkgLSAxKSB7XG4gICAgICAgIGVxdWFsUmFuZ2VzLnB1c2goe3N0YXJ0OiBzdGFydCwgbGVuZ3RoOiBpIC0gc3RhcnR9KTtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBpO1xuICAgICAgc3RhcnRWYWwgPSBhcnJbaV07XG4gICAgfVxuICB9XG4gIGlmIChzdGFydCAhPSBhcnIubGVuZ3RoIC0gMSkge1xuICAgIGVxdWFsUmFuZ2VzLnB1c2goe3N0YXJ0OiBzdGFydCwgbGVuZ3RoOiBhcnIubGVuZ3RoIC0gc3RhcnR9KTtcbiAgfVxuICByZXR1cm4gZXF1YWxSYW5nZXMuc29ydChmdW5jdGlvbih4LCB5KXsgcmV0dXJuIHkubGVuZ3RoIC0geC5sZW5ndGg7IH0pO1xufSIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FkbGVyMzJcbmNvbnN0IE1PRF9BRExFUiA9IDY1NTIxO1xuXG5jbGFzcyBBZGxlcjMyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fYSA9IDE7XG4gICAgdGhpcy5fYiA9IDA7XG4gICAgdGhpcy5faW5kZXggPSAwO1xuICB9XG5cbiAgYWRkTmV4dCh2YWx1ZSkge1xuICAgIHRoaXMuX2EgPSAodGhpcy5fYSArIHZhbHVlKSAlIE1PRF9BRExFUjtcbiAgICB0aGlzLl9iID0gKHRoaXMuX2IgKyB0aGlzLl9hKSAlIE1PRF9BRExFUjtcbiAgfVxuXG4gIGNvbXB1dGUoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iIDw8IDE2KSB8IHRoaXMuX2E7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFN1bW1lciA9IEFkbGVyMzI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtVdGlsfSBmcm9tICcuL1V0aWwnO1xuXG5leHBvcnQgY29uc3QgSGFzaCA9IHtcbiAgYmluZEZvcm1Ub0RvY3VtZW50SGFzaChmb3JtKSB7XG4gICAgaWYgKHRoaXMuYm91bmRGb3JtXykge1xuICAgICAgY29uc29sZS5lcnJvcignYWxyZWFkeSBib3VuZCB0byBhIGZvcm0nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kRm9ybV8gPSBmb3JtO1xuXG4gICAgZm9ybS5vbkNoYW5nZShVdGlsLmRlYm91bmNlKDEwMCwgKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50SGFzaF8gPSBwYXJhbXNUb0hhc2hfKGZvcm0uZ2V0VmFsdWVzU2VyaWFsaXplZCgpKTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsICcjJyArIHRoaXMuY3VycmVudEhhc2hfKTtcbiAgICB9KSk7XG5cbiAgICBsZXQgbWF5YmVVcGRhdGVIYXNoXyA9ICgpID0+IHtcbiAgICAgIC8vIERvbid0IHVzZSBkb2N1bWVudC5sb2NhdGlvbi5oYXNoIGJlY2F1c2UgaXQgYXV0b21hdGljYWxseVxuICAgICAgLy8gcmVzb2x2ZXMgVVJJLWVzY2FwZWQgZW50aXRpZXMuXG4gICAgICBsZXQgbmV3SGFzaCA9IHBhcmFtc1RvSGFzaF8oaGFzaFRvUGFyYW1zXyhcbiAgICAgICAgICAoZG9jdW1lbnQubG9jYXRpb24uaHJlZi5tYXRjaCgvIy4qLykgfHwgWycnXSlbMF0pKTtcbiAgICAgIGlmIChuZXdIYXNoICE9IHRoaXMuY3VycmVudEhhc2hfKSB7XG4gICAgICAgIGZvcm0uc2V0VmFsdWVzU2VyaWFsaXplZChoYXNoVG9QYXJhbXNfKG5ld0hhc2gpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50SGFzaF8gPSBuZXdIYXNoO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCBtYXliZVVwZGF0ZUhhc2hfKTtcblxuICAgIG1heWJlVXBkYXRlSGFzaF8oKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFzaFRvUGFyYW1zXyhoYXNoKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHt9O1xuICBoYXNoID0gaGFzaC5yZXBsYWNlKC9eWz8jXS8sICcnKTtcblxuICBoYXNoLnNwbGl0KCcmJykuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgbGV0IFtwYXRoLCB2YWxdID0gZW50cnkuc3BsaXQoJz0nLCAyKTtcbiAgICBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGggfHwgJycpO1xuICAgIHZhbCA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWwgfHwgJycpO1xuXG4gICAgLy8gTW9zdCBvZiB0aGUgdGltZSBwYXRoID09IGtleSwgYnV0IGZvciBvYmplY3RzIGxpa2UgYS5iPTEsIHdlIG5lZWQgdG9cbiAgICAvLyBkZXNjZW5kIGludG8gdGhlIGhpZXJhY2h5LlxuICAgIGxldCBwYXRoQXJyID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBvYmogPSBwYXJhbXM7XG4gICAgcGF0aEFyci5zbGljZSgwLCAtMSkuZm9yRWFjaChwYXRoUGFydCA9PiB7XG4gICAgICBvYmpbcGF0aFBhcnRdID0gb2JqW3BhdGhQYXJ0XSB8fCB7fTtcbiAgICAgIG9iaiA9IG9ialtwYXRoUGFydF07XG4gICAgfSk7XG4gICAgbGV0IGtleSA9IHBhdGhBcnJbcGF0aEFyci5sZW5ndGggLSAxXTtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgLy8gSGFuZGxlIGFycmF5IHZhbHVlcy5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IFtvYmpba2V5XSwgdmFsXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBwYXJhbXNUb0hhc2hfKHBhcmFtcywgcHJlZml4KSB7XG4gIGNvbnN0IGhhc2hBcnIgPSBbXTtcbiAgY29uc3Qga2V5UGF0aF8gPSBrID0+IGVuY29kZVVSSUNvbXBvbmVudCgocHJlZml4ID8gcHJlZml4ICsgJy4nIDogJycpICsgayk7XG4gIGNvbnN0IHB1c2hLZXlWYWx1ZV8gPSAoaywgdikgPT4ge1xuICAgIGlmICh2ID09PSBmYWxzZSkgdiA9IDA7XG4gICAgaWYgKHYgPT09IHRydWUpICB2ID0gMTtcbiAgICBoYXNoQXJyLnB1c2goa2V5UGF0aF8oaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodi50b1N0cmluZygpKSk7XG4gIH07XG5cbiAgZm9yIChsZXQga2V5IGluIHBhcmFtcykge1xuICAgIGxldCB2YWwgPSBwYXJhbXNba2V5XTtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaCh2ID0+IHB1c2hLZXlWYWx1ZV8oa2V5LCB2KSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09ICdvYmplY3QnKSB7XG4gICAgICBoYXNoQXJyLnB1c2gocGFyYW1zVG9IYXNoXyh2YWwsIGtleVBhdGhfKGtleSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEtleVZhbHVlXyhrZXksIHZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc2hBcnIuam9pbignJicpO1xufSIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgVXRpbCA9IHtcbiAgZ2V0TXVsdEJhc2VNZHBpKGRlbnNpdHkpIHtcbiAgICBzd2l0Y2ggKGRlbnNpdHkpIHtcbiAgICAgIGNhc2UgJ3h4eGhkcGknOiByZXR1cm4gNC4wMDtcbiAgICAgIGNhc2UgICd4eGhkcGknOiByZXR1cm4gMy4wMDtcbiAgICAgIGNhc2UgICAneGhkcGknOiByZXR1cm4gMi4wMDtcbiAgICAgIGNhc2UgICAgJ2hkcGknOiByZXR1cm4gMS41MDtcbiAgICAgIGNhc2UgICAndHZkcGknOiByZXR1cm4gMS4zMzEyNTtcbiAgICAgIGNhc2UgICAgJ21kcGknOiByZXR1cm4gMS4wMDtcbiAgICAgIGNhc2UgICAgJ2xkcGknOiByZXR1cm4gMC43NTtcbiAgICB9XG4gICAgcmV0dXJuIDEuMDtcbiAgfSxcblxuICBnZXREcGlGb3JEZW5zaXR5KGRlbnNpdHkpIHtcbiAgICBzd2l0Y2ggKGRlbnNpdHkpIHtcbiAgICAgIGNhc2UgJ3h4eGhkcGknOiByZXR1cm4gNjQwO1xuICAgICAgY2FzZSAgJ3h4aGRwaSc6IHJldHVybiA0ODA7XG4gICAgICBjYXNlICAgJ3hoZHBpJzogcmV0dXJuIDMyMDtcbiAgICAgIGNhc2UgICAgJ2hkcGknOiByZXR1cm4gMjQwO1xuICAgICAgY2FzZSAgICd0dmRwaSc6IHJldHVybiAyMTM7XG4gICAgICBjYXNlICAgICdtZHBpJzogcmV0dXJuIDE2MDtcbiAgICAgIGNhc2UgICAgJ2xkcGknOiByZXR1cm4gMTIwO1xuICAgIH1cbiAgICByZXR1cm4gMTYwO1xuICB9LFxuXG4gIG11bHQocywgbXVsdCkge1xuICAgIGxldCBkID0ge307XG4gICAgZm9yIChsZXQgayBpbiBzKSB7XG4gICAgICBkW2tdID0gc1trXSAqIG11bHQ7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9LFxuXG4gIG11bHRSb3VuZChzLCBtdWx0KSB7XG4gICAgbGV0IGQgPSB7fTtcbiAgICBmb3IgKGxldCBrIGluIHMpIHtcbiAgICAgIGRba10gPSBNYXRoLnJvdW5kKHNba10gKiBtdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH0sXG5cbiAgc2FuaXRpemVSZXNvdXJjZU5hbWUocykge1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW1xccy1cXC5dL2csICdfJykucmVwbGFjZSgvW15cXHdfXS9nLCAnJyk7XG4gIH0sXG5cbiAgLy8gVE9ETzogc3VwcG9ydCBTYWZhcmlcbiAgZG93bmxvYWRGaWxlKGNvbnRlbnQsIGZpbGVuYW1lKSB7XG4gICAgbGV0IGFuY2hvciA9ICQoJzxhPicpLmhpZGUoKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICBsZXQgYmxvYiA9IGNvbnRlbnQ7XG4gICAgaWYgKCEoY29udGVudCBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7dHlwZTogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSd9KTtcbiAgICB9XG4gICAgbGV0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGFuY2hvci5hdHRyKHtcbiAgICAgIGhyZWY6IHVybCxcbiAgICAgIGRvd25sb2FkOiBmaWxlbmFtZVxuICAgIH0pO1xuICAgIGFuY2hvci5nZXQoMCkuY2xpY2soKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFuY2hvci5yZW1vdmUoKTtcbiAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgfSwgNTAwMCk7XG4gIH0sXG5cbiAgbG9hZEltYWdlRnJvbVVyaSh1cmkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KCk7XG4gICAgICBpbWcuc3JjID0gdXJpO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlYnVnQ3R4KGN0eCkge1xuICAgIGlmIChVdGlsLmRlYnVnQ3R4LiRsYXN0RWwpIHtcbiAgICAgIFV0aWwuZGVidWdDdHguJGxhc3RFbC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBVdGlsLmRlYnVnQ3R4LiRsYXN0RWwgPSAkKCc8aW1nPicpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgMCwgMCwgMC41KScsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICB9KVxuICAgICAgICAuYXR0cignc3JjJywgY3R4LmNhbnZhcy50b0RhdGFVUkwoKSlcbiAgICAgICAgLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICB9LFxuXG4gIGRlYm91bmNlKGRlbGF5LCBmbikge1xuICAgIGxldCB0aW1lb3V0O1xuXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGZuKC4uLmFyZ3MpXG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG4gIH0sXG59OyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2RlZmF1bHQgYXMgemlwanN9IGZyb20gJ3ppcGpzLWJyb3dzZXJpZnknO1xuXG5pbXBvcnQge1V0aWx9IGZyb20gJy4vVXRpbCc7XG5cbmNvbnN0IFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMO1xuXG5cbmV4cG9ydCBjb25zdCBaaXAgPSB7XG4gIGNyZWF0ZURvd25sb2FkaWZ5WmlwQnV0dG9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERvd25sb2FkWmlwQnV0dG9uKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG59O1xuXG5cbmNsYXNzIERvd25sb2FkWmlwQnV0dG9uIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuZmlsZVNwZWNzXyA9IFtdO1xuICAgIHRoaXMuZWxfID0gZWxlbWVudDtcbiAgICB0aGlzLmVsXy5jbGljaygoKSA9PiB0aGlzLmdlbmVyYXRlQW5kRG93bmxvYWRaaXBGaWxlXygpKTtcbiAgICB0aGlzLnVwZGF0ZVVJXygpO1xuICB9XG5cbiAgc2V0WmlwRmlsZW5hbWUoemlwRmlsZW5hbWUpIHtcbiAgICB0aGlzLnppcEZpbGVuYW1lXyA9IHppcEZpbGVuYW1lO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5maWxlU3BlY3NfID0gW107XG4gICAgdGhpcy51cGRhdGVVSV8oKTtcbiAgfVxuXG4gIGFkZChzcGVjKSB7XG4gICAgdGhpcy5maWxlU3BlY3NfLnB1c2goc3BlYyk7XG4gICAgdGhpcy51cGRhdGVVSV8oKTtcbiAgfVxuXG4gIHVwZGF0ZVVJXygpIHtcbiAgICBpZiAodGhpcy5maWxlU3BlY3NfLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0aW5nXykge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbF8uYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICBnZW5lcmF0ZUFuZERvd25sb2FkWmlwRmlsZV8oKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gdGhpcy56aXBGaWxlbmFtZV8gfHwgJ291dHB1dC56aXAnO1xuICAgIGlmICghdGhpcy5maWxlU3BlY3NfLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNHZW5lcmF0aW5nXyA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVVSV8oKTtcblxuICAgIHppcGpzLmNyZWF0ZVdyaXRlcihuZXcgemlwanMuQmxvYldyaXRlcigpLCB3cml0ZXIgPT4ge1xuICAgICAgbGV0IGkgPSAtMTtcbiAgICAgIGxldCBuZXh0RmlsZV8gPSAoKSA9PiB7XG4gICAgICAgICsraTtcbiAgICAgICAgaWYgKGkgPj0gdGhpcy5maWxlU3BlY3NfLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGNsb3NlXG4gICAgICAgICAgd3JpdGVyLmNsb3NlKGJsb2IgPT4gVXRpbC5kb3dubG9hZEZpbGUoYmxvYiwgZmlsZW5hbWUpKTtcbiAgICAgICAgICB0aGlzLmlzR2VuZXJhdGluZ18gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVVJXygpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkIG5leHQgZmlsZVxuICAgICAgICAgIGxldCBmaWxlU3BlYyA9IHRoaXMuZmlsZVNwZWNzX1tpXTtcbiAgICAgICAgICB3cml0ZXIuYWRkKFxuICAgICAgICAgICAgICBmaWxlU3BlYy5uYW1lLFxuICAgICAgICAgICAgICBmaWxlU3BlYy5jYW52YXNcbiAgICAgICAgICAgICAgICAgID8gbmV3IHppcGpzLkRhdGE2NFVSSVJlYWRlcihmaWxlU3BlYy5jYW52YXMudG9EYXRhVVJMKCkpXG4gICAgICAgICAgICAgICAgICA6IG5ldyB6aXBqcy5UZXh0UmVhZGVyKGZpbGVTcGVjLnRleHREYXRhKSxcbiAgICAgICAgICAgICAgbmV4dEZpbGVfKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG5leHRGaWxlXygpO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5pc0dlbmVyYXRpbmdfID0gZmFsc2U7XG4gICAgICB0aGlzLnVwZGF0ZVVJXygpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtFbnVtRmllbGR9IGZyb20gJy4vRW51bUZpZWxkJztcblxuZXhwb3J0IGNsYXNzIEJvb2xlYW5GaWVsZCBleHRlbmRzIEVudW1GaWVsZCB7XG4gIGNvbnN0cnVjdG9yKGlkLCBwYXJhbXMpIHtcbiAgICBzdXBlcihpZCwgcGFyYW1zKTtcbiAgICBwYXJhbXMub3B0aW9ucyA9IFtcbiAgICAgIHsgaWQ6ICcxJywgdGl0bGU6IHBhcmFtcy5vblRleHQgfHwgJ1llcycgfSxcbiAgICAgIHsgaWQ6ICcwJywgdGl0bGU6IHBhcmFtcy5vZmZUZXh0IHx8ICdObycgfVxuICAgIF07XG4gICAgcGFyYW1zLmRlZmF1bHRWYWx1ZSA9IHBhcmFtcy5kZWZhdWx0VmFsdWUgPyAnMScgOiAnMCc7XG4gICAgcGFyYW1zLmJ1dHRvbnMgPSB0cnVlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFZhbHVlKCkgPT0gJzEnO1xuICB9XG5cbiAgc2V0VmFsdWUodmFsLCBwYXVzZVVpKSB7XG4gICAgc3VwZXIuc2V0VmFsdWUodmFsID8gJzEnIDogJzAnLCBwYXVzZVVpKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCkgPyAnMScgOiAnMCc7XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKHMpIHtcbiAgICB0aGlzLnNldFZhbHVlKHMgPT0gJzEnKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7ZGVmYXVsdCBhcyB0aW55Y29sb3J9IGZyb20gJ3Rpbnljb2xvcjInO1xuXG5pbXBvcnQge0ZpZWxkfSBmcm9tICcuL0ZpZWxkJztcblxuZXhwb3J0IGNsYXNzIENvbG9yRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gIGNyZWF0ZVVpKGNvbnRhaW5lcikge1xuICAgIHZhciBmaWVsZENvbnRhaW5lciA9ICQoJy5mb3JtLWZpZWxkLWNvbnRhaW5lcicsIHN1cGVyLmNyZWF0ZVVpKGNvbnRhaW5lcikpO1xuXG4gICAgdGhpcy5lbF8gPSAkKCc8aW5wdXQ+JylcbiAgICAgICAgLmF0dHIoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICBsZXQgdXBkYXRlXyA9IGNvbG9yID0+IHRoaXMuc2V0VmFsdWUoY29sb3IsIHRydWUpO1xuXG4gICAgdGhpcy5lbF8uc3BlY3RydW0oe1xuICAgICAgY29sb3I6IHRoaXMuZ2V0VmFsdWUoKS50b1JnYlN0cmluZygpLFxuICAgICAgc2hvd0lucHV0OiB0cnVlLFxuICAgICAgc2hvd1BhbGV0dGU6IHRydWUsXG4gICAgICBzaG93QWxwaGE6IHRoaXMucGFyYW1zXy5hbHBoYSxcbiAgICAgIHByZWZlcnJlZEZvcm1hdDogJ2hleCcsXG4gICAgICBwYWxldHRlOiBbXG4gICAgICAgIFsnI2ZmZmZmZicsICcjMDAwMDAwJ10sXG4gICAgICAgIFsnI2Y0NDMzNicsICcjZTkxZTYzJ10sXG4gICAgICAgIFsnIzljMjdiMCcsICcjNjczYWI3J10sXG4gICAgICAgIFsnIzNmNTFiNScsICcjMjE5NmYzJ10sXG4gICAgICAgIFsnIzAzYTlmNCcsICcjMDBiY2Q0J10sXG4gICAgICAgIFsnIzAwOTY4OCcsICcjNGNhZjUwJ10sXG4gICAgICAgIFsnIzhiYzM0YScsICcjY2RkYzM5J10sXG4gICAgICAgIFsnI2ZmZWIzYicsICcjZmZjMTA3J10sXG4gICAgICAgIFsnI2ZmOTgwMCcsICcjZmY1NzIyJ10sXG4gICAgICAgIFsnIzllOWU5ZScsICcjNjA3ZDhiJ11cbiAgICAgIF0sXG4gICAgICBsb2NhbFN0b3JhZ2VLZXk6ICdyZWNlbnRjb2xvcnMnLFxuICAgICAgc2hvd0luaXRpYWw6IHRydWUsXG4gICAgICBzaG93QnV0dG9uczogZmFsc2UsXG4gICAgICBjaGFuZ2U6IHVwZGF0ZV8sXG4gICAgICBtb3ZlOiB1cGRhdGVfXG4gICAgfSk7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZV8gfHwgdGlueWNvbG9yKHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWUgfHwgJyMwMDAnKTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbCwgcGF1c2VVaSkge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIHRoaXMudmFsdWVfID0gKHZhbC5oYXNPd25Qcm9wZXJ0eSgnX3InKSlcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB0aW55Y29sb3IodmFsIHx8IHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWUgfHwgJyMwMDAnKTtcbiAgICBpZiAoIXBhdXNlVWkpIHtcbiAgICAgIHRoaXMuZWxfLnNwZWN0cnVtKCdzZXQnLCB0aGlzLnZhbHVlXy50b1JnYlN0cmluZygpKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlDaGFuZ2VkXyh2YWwsIG9sZFZhbHVlKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCkudG9SZ2JTdHJpbmcoKTtcbiAgfVxuXG4gIGRlc2VyaWFsaXplVmFsdWUocykge1xuICAgIHRoaXMuc2V0VmFsdWUocyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0ZpZWxkfSBmcm9tICcuL0ZpZWxkJztcblxuZXhwb3J0IGNsYXNzIEVudW1GaWVsZCBleHRlbmRzIEZpZWxkIHtcbiAgY3JlYXRlVWkoY29udGFpbmVyKSB7XG4gICAgbGV0IGZpZWxkQ29udGFpbmVyID0gJCgnLmZvcm0tZmllbGQtY29udGFpbmVyJywgc3VwZXIuY3JlYXRlVWkoY29udGFpbmVyKSk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXNfLmJ1dHRvbnMpIHtcbiAgICAgIHRoaXMuZWxfID0gJCgnPGRpdj4nKVxuICAgICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgICAgLmFkZENsYXNzKCdmb3JtLWZpZWxkLWJ1dHRvbnNldCcpXG4gICAgICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXyA9ICQoJzxkaXY+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0tZmllbGQtc2VsZWN0JylcbiAgICAgICAgICAuYXR0cignaWQnLCB0aGlzLmdldEh0bWxJZCgpKVxuICAgICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICAgIHRoaXMuc2VsZWN0RWxfID0gJCgnPHNlbGVjdD4nKVxuICAgICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgICAgLm9uKCdpbnB1dCcsIGV2ID0+IHRoaXMuc2V0VmFsdWVJbnRlcm5hbF8oJChldi5jdXJyZW50VGFyZ2V0KS52YWwoKSwgdHJ1ZSkpXG4gICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldE9wdGlvbnModGhpcy5wYXJhbXNfLm9wdGlvbnMpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmVsXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSAob3B0aW9ucyB8fCBbXSkubWFwKG9wdGlvbiA9PlxuICAgICAgICAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgID8ge2lkOiBvcHRpb24sIHRpdGxlOiBTdHJpbmcob3B0aW9uKX1cbiAgICAgICAgICAgIDogb3B0aW9uKTtcblxuICAgIGlmICh0aGlzLnBhcmFtc18uYnV0dG9ucykge1xuICAgICAgdGhpcy5lbF8uZW1wdHkoKTtcbiAgICAgIChvcHRpb25zIHx8IFtdKS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICQoJzxpbnB1dD4nKVxuICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgICAgICAgICBuYW1lOiB0aGlzLmdldEh0bWxJZCgpLFxuICAgICAgICAgICAgICBpZDogYCR7dGhpcy5nZXRIdG1sSWQoKX0tJHtvcHRpb24uaWR9YCxcbiAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi5pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2hhbmdlJywgZXYgPT4gdGhpcy5zZXRWYWx1ZUludGVybmFsXygkKGV2LmN1cnJlbnRUYXJnZXQpLnZhbCgpLCBmYWxzZSkpXG4gICAgICAgICAgICAuYXBwZW5kVG8odGhpcy5lbF8pO1xuICAgICAgICAkKCc8bGFiZWw+JylcbiAgICAgICAgICAgIC5hdHRyKCdmb3InLCBgJHt0aGlzLmdldEh0bWxJZCgpfS0ke29wdGlvbi5pZH1gKVxuICAgICAgICAgICAgLmF0dHIoJ3RhYmluZGV4JywgMClcbiAgICAgICAgICAgIC5odG1sKG9wdGlvbi50aXRsZSlcbiAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsXyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RFbF8uZW1wdHkoKTtcbiAgICAgIChvcHRpb25zIHx8IFtdKS5mb3JFYWNoKG9wdGlvbiA9PlxuICAgICAgICAgICQoJzxvcHRpb24+JylcbiAgICAgICAgICAgICAgLmF0dHIoJ3ZhbHVlJywgb3B0aW9uLmlkKVxuICAgICAgICAgICAgICAudGV4dChvcHRpb24udGl0bGUpXG4gICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLnNlbGVjdEVsXykpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VmFsdWVJbnRlcm5hbF8odGhpcy5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWU7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhcmFtc18ub3B0aW9ucyAmJiB0aGlzLnBhcmFtc18ub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGZpcnN0T3B0aW9uID0gdGhpcy5wYXJhbXNfLm9wdGlvbnNbMF07XG4gICAgICAgIHZhbHVlID0gKCdpZCcgaW4gZmlyc3RPcHRpb24pID8gZmlyc3RPcHRpb24uaWQgOiBTdHJpbmcoZmlyc3RPcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBzZXRWYWx1ZSh2YWwsIHBhdXNlVWkpIHtcbiAgICB0aGlzLnNldFZhbHVlSW50ZXJuYWxfKHZhbCwgcGF1c2VVaSk7XG4gIH1cblxuICBzZXRWYWx1ZUludGVybmFsXyh2YWwsIHBhdXNlVWkpIHtcbiAgICBsZXQgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICAvLyBOb3RlLCB0aGlzIG5lZWRzIHRvIGJlIGl0cyBvd24gZnVuY3Rpb24gYmVjYXVzZSBzZXRWYWx1ZSBnZXRzXG4gICAgLy8gb3ZlcnJpZGRlbiBpbiBCb29sZWFuRmllbGQgYW5kIHdlIG5lZWQgYWNjZXNzIHRvIHRoaXMgbWV0aG9kXG4gICAgLy8gZnJvbSBjcmVhdGVVaS5cbiAgICB0aGlzLnZhbHVlXyA9IHZhbDtcbiAgICBpZiAoIXBhdXNlVWkpIHtcbiAgICAgIGlmICh0aGlzLnBhcmFtc18uYnV0dG9ucykge1xuICAgICAgICB0aGlzLmVsXy5maW5kKCdpbnB1dCcpLmVhY2goKGksIGVsKSA9PlxuICAgICAgICAgICAgJChlbCkucHJvcCgnY2hlY2tlZCcsICQoZWwpLnZhbCgpID09IHZhbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RFbF8udmFsKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubm90aWZ5Q2hhbmdlZF8odmFsLCBvbGRWYWx1ZSk7XG4gIH1cblxuICBzZXJpYWxpemVWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgZGVzZXJpYWxpemVWYWx1ZShzKSB7XG4gICAgdGhpcy5zZXRWYWx1ZShzKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZvcm0gZmllbGQgYW5kIGl0cyBhc3NvY2lhdGVkIFVJIGVsZW1lbnRzLiBUaGlzIHNob3VsZCBiZVxuICogYnJva2VuIG91dCBpbnRvIGEgbW9yZSBNVkMtbGlrZSBhcmNoaXRlY3R1cmUgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpZWxkIHtcbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhIG5ldyBmaWVsZCB3aXRoIHRoZSBnaXZlbiBJRCBhbmQgcGFyYW1ldGVycy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpZCwgcGFyYW1zKSB7XG4gICAgdGhpcy5pZF8gPSBpZDtcbiAgICB0aGlzLnBhcmFtc18gPSBwYXJhbXM7XG4gICAgaWYgKHRoaXMucGFyYW1zXy5vbkNoYW5nZSkge1xuICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnBhcmFtc18ub25DaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmb3JtIG93bmVyIG9mIHRoZSBmaWVsZC4gSW50ZXJuYWxseSBjYWxsZWQgYnlcbiAgICoge0BsaW5rIHN0dWRpby5mb3Jtcy5Gb3JtfS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHVkaW8uZm9ybXMuRm9ybX0gZm9ybSBUaGUgb3duZXIgZm9ybS5cbiAgICovXG4gIHNldEZvcm1fKGZvcm0pIHtcbiAgICB0aGlzLmZvcm1fID0gZm9ybTtcbiAgICB0aGlzLm9uQ2hhbmdlKChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgIHRoaXMuZm9ybV8ubm90aWZ5Q2hhbmdlZF8odGhpcywgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29tcGxldGUgSUQuXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKi9cbiAgZ2V0TG9uZ0lkKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1fLmlkXyArICctJyArIHRoaXMuaWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIElEIGZvciB0aGUgZm9ybSdzIFVJIGVsZW1lbnQgKG9yIGNvbnRhaW5lcikuXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKi9cbiAgZ2V0SHRtbElkKCkge1xuICAgIHJldHVybiAnX2ZybS0nICsgdGhpcy5nZXRMb25nSWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFVJIGVsZW1lbnRzIGZvciBhIGZvcm0gZmllbGQgY29udGFpbmVyLiBOb3QgdmVyeSBwb3J0YWJsZVxuICAgKiBvdXRzaWRlIHRoZSBBc3NldCBTdHVkaW8gVUkuIEludGVuZGVkIHRvIGJlIG92ZXJyaWRlbiBieSBkZXNjZW5kZW50cy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBkZXN0aW5hdGlvbiBlbGVtZW50IHRvIGNvbnRhaW4gdGhlXG4gICAqIGZpZWxkLlxuICAgKi9cbiAgY3JlYXRlVWkoY29udGFpbmVyLCBmb3JtRmllbGRDbGFzcyA9ICdmb3JtLWZpZWxkLWNvbnRhaW5lcicpIHtcbiAgICBjb250YWluZXIgPSAkKGNvbnRhaW5lcik7XG4gICAgdGhpcy5iYXNlRWxfID0gJCgnPGRpdj4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0tZmllbGQtb3V0ZXInKVxuICAgICAgICAuYWRkQ2xhc3ModGhpcy5wYXJhbXNfLm5ld0dyb3VwID8gJ2lzLW5ldy1ncm91cCcgOiAnJylcbiAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAkKCc8bGFiZWw+JylcbiAgICAgICAgICAgIC5hdHRyKCdmb3InLCB0aGlzLmdldEh0bWxJZCgpKVxuICAgICAgICAgICAgLnRleHQodGhpcy5wYXJhbXNfLnRpdGxlKVxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8ZGl2PicpXG4gICAgICAgICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1oZWxwLXRleHQnKVxuICAgICAgICAgICAgICAuY3NzKCdkaXNwbGF5JywgdGhpcy5wYXJhbXNfLmhlbHBUZXh0ID8gJycgOiAnbm9uZScpXG4gICAgICAgICAgICAgIC5odG1sKHRoaXMucGFyYW1zXy5oZWxwVGV4dCkpXG4gICAgICAgIClcbiAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAkKCc8ZGl2PicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoZm9ybUZpZWxkQ2xhc3MpXG4gICAgICAgIClcbiAgICAgICAgLmFwcGVuZFRvKGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUVsXztcbiAgfVxuXG4gIGdldEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZF87XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZm9ybSBmaWVsZC5cbiAgICovXG4gIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSBlbmFibGVkO1xuICAgIGlmICh0aGlzLmJhc2VFbF8pIHtcbiAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuYmFzZUVsXy5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXNlRWxfLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25DaGFuZ2UobGlzdGVuZXIpIHtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSAodGhpcy5jaGFuZ2VMaXN0ZW5lcnNfIHx8IFtdKS5jb25jYXQoW2xpc3RlbmVyXSk7XG4gIH1cblxuICBub3RpZnlDaGFuZ2VkXyhuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAodGhpcy5jaGFuZ2VMaXN0ZW5lcnNfIHx8IFtdKS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBkZWZpbmluZyBhIGRhdGEgZW50cnkgZm9ybSBmb3IgdXNlIGluIHRoZSBBc3NldCBTdHVkaW8uXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JtIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZm9ybSB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtcy5pbnB1dHNdIEEgbGlzdCBvZiBpbnB1dHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHRoaXMuaWRfID0gcGFyYW1zLmlkO1xuICAgIHRoaXMucGFyYW1zXyA9IHBhcmFtcztcbiAgICB0aGlzLmZpZWxkc18gPSBwYXJhbXMuZmllbGRzO1xuICAgIHRoaXMuZmllbGRzXy5mb3JFYWNoKGZpZWxkID0+IGZpZWxkLnNldEZvcm1fKHRoaXMpKTtcbiAgICB0aGlzLmZpZWxkc18uZm9yRWFjaChmaWVsZCA9PiBmaWVsZC5jcmVhdGVVaShwYXJhbXMuY29udGFpbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBvbmNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIG9uQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gKHRoaXMuY2hhbmdlTGlzdGVuZXJzXyB8fCBbXSkuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoYXQgdGhlIGZvcm0gY29udGVudHMgaGF2ZSBjaGFuZ2VkO1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm90aWZ5Q2hhbmdlZF8oZmllbGQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmICh0aGlzLnBhdXNlTm90aWZ5Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAodGhpcy5jaGFuZ2VMaXN0ZW5lcnNfIHx8IFtdKS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGZpZWxkLCBuZXdWYWx1ZSwgb2xkVmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlcyBvZiB0aGUgZm9ybSBmaWVsZHMsIGFzIGFuIG9iamVjdC5cbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuICBnZXRWYWx1ZXMoKSB7XG4gICAgbGV0IHZhbHVlcyA9IHt9O1xuICAgIHRoaXMuZmllbGRzXy5mb3JFYWNoKGZpZWxkID0+IHZhbHVlc1tmaWVsZC5pZF9dID0gZmllbGQuZ2V0VmFsdWUoKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgc2VyaWFsaXplZCB2YWx1ZXMgb2YgdGhlIGZvcm0gZmllbGRzLCBhcyBhbiBvYmplY3QuXG4gICAqIEFsbCB2YWx1ZXMgaW4gdGhlIHJldHVybmVkIG9iamVjdCBhcmUgZWl0aGVyIHN0cmluZ3Mgb3Igb2JqZWN0cy5cbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuICBnZXRWYWx1ZXNTZXJpYWxpemVkKCkge1xuICAgIGxldCB2YWx1ZXMgPSB7fTtcbiAgICB0aGlzLmZpZWxkc18uZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBmaWVsZC5zZXJpYWxpemVWYWx1ZSA/IGZpZWxkLnNlcmlhbGl6ZVZhbHVlKCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZXNbZmllbGQuaWRfXSA9IGZpZWxkLnNlcmlhbGl6ZVZhbHVlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZvcm0gZmllbGQgdmFsdWVzIGZvciB0aGUga2V5L3ZhbHVlIHBhaXJzIGluIHRoZSBnaXZlbiBvYmplY3QuXG4gICAqIFZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6ZWQgZm9ybXMgb2YgdGhlIGZvcm0gdmFsdWVzLiBUaGUgZm9ybSBtdXN0IGJlXG4gICAqIGluaXRpYWxpemVkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgc2V0VmFsdWVzU2VyaWFsaXplZChzZXJpYWxpemVkVmFsdWVzKSB7XG4gICAgdGhpcy5wYXVzZU5vdGlmeV8gPSB0cnVlO1xuICAgIHRoaXMuZmllbGRzX1xuICAgICAgICAuZmlsdGVyKGZpZWxkID0+IGZpZWxkLmlkXyBpbiBzZXJpYWxpemVkVmFsdWVzICYmIGZpZWxkLmRlc2VyaWFsaXplVmFsdWUpXG4gICAgICAgIC5mb3JFYWNoKGZpZWxkID0+IGZpZWxkLmRlc2VyaWFsaXplVmFsdWUoc2VyaWFsaXplZFZhbHVlc1tmaWVsZC5pZF9dKSk7XG4gICAgdGhpcy5wYXVzZU5vdGlmeV8gPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeUNoYW5nZWRfKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyB0aW55Y29sb3J9IGZyb20gJ3Rpbnljb2xvcjInO1xuXG5pbXBvcnQge0ZpZWxkfSBmcm9tICcuL0ZpZWxkJztcblxuZXhwb3J0IGNsYXNzIEdyYWRpZW50RmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gIGNyZWF0ZVVpKGNvbnRhaW5lcikge1xuICAgIHZhciBmaWVsZENvbnRhaW5lciA9ICQoJy5mb3JtLWZpZWxkLWNvbnRhaW5lci1yb3cnLCBzdXBlci5jcmVhdGVVaShjb250YWluZXIsICdmb3JtLWZpZWxkLWNvbnRhaW5lci1yb3cnKSk7XG5cbiAgICB0aGlzLmZyb21fZWxfID0gJCgnPGlucHV0PicpXG4gICAgICAuYXR0cigndHlwZScsICd0ZXh0JylcbiAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkrXCItZnJvbVwiKVxuICAgICAgLmFwcGVuZFRvKGZpZWxkQ29udGFpbmVyKTtcblxuICAgIHRoaXMudG9fZWxfID0gJCgnPGlucHV0PicpXG4gICAgICAuYXR0cigndHlwZScsICd0ZXh0JylcbiAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkrXCItdG9cIilcbiAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICBsZXQgZnJvbV91cGRhdGVfID0gY29sb3IgPT4gdGhpcy5zZXRGcm9tVmFsdWUoY29sb3IsIHRydWUpO1xuICAgIGxldCB0b191cGRhdGVfID0gY29sb3IgPT4gdGhpcy5zZXRUb1ZhbHVlKGNvbG9yLCB0cnVlKTtcblxuICAgIGxldCBwYWxldHRlID0gW1xuICAgICAgWycjZmZmZmZmJywgJyMwMDAwMDAnXSxcbiAgICAgIFsnI2Y0NDMzNicsICcjZTkxZTYzJ10sXG4gICAgICBbJyM5YzI3YjAnLCAnIzY3M2FiNyddLFxuICAgICAgWycjM2Y1MWI1JywgJyMyMTk2ZjMnXSxcbiAgICAgIFsnIzAzYTlmNCcsICcjMDBiY2Q0J10sXG4gICAgICBbJyMwMDk2ODgnLCAnIzRjYWY1MCddLFxuICAgICAgWycjOGJjMzRhJywgJyNjZGRjMzknXSxcbiAgICAgIFsnI2ZmZWIzYicsICcjZmZjMTA3J10sXG4gICAgICBbJyNmZjk4MDAnLCAnI2ZmNTcyMiddLFxuICAgICAgWycjOWU5ZTllJywgJyM2MDdkOGInXVxuICAgIF07XG5cbiAgICB0aGlzLmZyb21fZWxfLnNwZWN0cnVtKHtcbiAgICAgIGNvbG9yOiB0aGlzLmdldFZhbHVlKCkuZnJvbS50b1JnYlN0cmluZygpLFxuICAgICAgc2hvd0lucHV0OiB0cnVlLFxuICAgICAgc2hvd1BhbGV0dGU6IHRydWUsXG4gICAgICBzaG93QWxwaGE6IHRoaXMucGFyYW1zXy5hbHBoYSxcbiAgICAgIHByZWZlcnJlZEZvcm1hdDogJ2hleCcsXG4gICAgICBwYWxldHRlOiBwYWxldHRlLFxuICAgICAgbG9jYWxTdG9yYWdlS2V5OiAncmVjZW50Y29sb3JzJyxcbiAgICAgIHNob3dJbml0aWFsOiB0cnVlLFxuICAgICAgc2hvd0J1dHRvbnM6IGZhbHNlLFxuICAgICAgY2hhbmdlOiBmcm9tX3VwZGF0ZV8sXG4gICAgICBtb3ZlOiBmcm9tX3VwZGF0ZV9cbiAgICB9KTtcblxuICAgIHRoaXMudG9fZWxfLnNwZWN0cnVtKHtcbiAgICAgIGNvbG9yOiB0aGlzLmdldFZhbHVlKCkudG8udG9SZ2JTdHJpbmcoKSxcbiAgICAgIHNob3dJbnB1dDogdHJ1ZSxcbiAgICAgIHNob3dQYWxldHRlOiB0cnVlLFxuICAgICAgc2hvd0FscGhhOiB0aGlzLnBhcmFtc18uYWxwaGEsXG4gICAgICBwcmVmZXJyZWRGb3JtYXQ6ICdoZXgnLFxuICAgICAgcGFsZXR0ZTogcGFsZXR0ZSxcbiAgICAgIGxvY2FsU3RvcmFnZUtleTogJ3JlY2VudGNvbG9ycycsXG4gICAgICBzaG93SW5pdGlhbDogdHJ1ZSxcbiAgICAgIHNob3dCdXR0b25zOiBmYWxzZSxcbiAgICAgIGNoYW5nZTogdG9fdXBkYXRlXyxcbiAgICAgIG1vdmU6IHRvX3VwZGF0ZV9cbiAgICB9KTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnZnJvbSc6IHRoaXMuZnJvbV92YWx1ZV8gfHwgdGlueWNvbG9yKHRoaXMucGFyYW1zXy5kZWZhdWx0RnJvbSB8fCAnIzAwMCcpLFxuICAgICAgJ3RvJzogIHRoaXMudG9fdmFsdWVfIHx8IHRpbnljb2xvcih0aGlzLnBhcmFtc18uZGVmYXVsdFRvIHx8ICcjMDAwJylcbiAgICB9O1xuICB9XG5cbiAgc2V0RnJvbVZhbHVlKHZhbCwgcGF1c2VVaSkge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRoaXMuZnJvbV92YWx1ZV87XG4gICAgdGhpcy5mcm9tX3ZhbHVlXyA9ICh2YWwuaGFzT3duUHJvcGVydHkoJ19yJykpXG4gICAgICA/IHZhbFxuICAgICAgOiB0aW55Y29sb3IodmFsIHx8IHRoaXMucGFyYW1zXy5kZWZhdWx0RnJvbSB8fCAnIzAwMCcpO1xuICAgIGlmICghcGF1c2VVaSkge1xuICAgICAgdGhpcy5mcm9tX2VsXy5zcGVjdHJ1bSgnc2V0JywgdGhpcy5mcm9tX3ZhbHVlXy50b1JnYlN0cmluZygpKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlDaGFuZ2VkXyh2YWwsIG9sZFZhbHVlKTtcbiAgfVxuXG4gIHNldFRvVmFsdWUodmFsLCBwYXVzZVVpKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGhpcy50b192YWx1ZV87XG4gICAgdGhpcy50b192YWx1ZV8gPSAodmFsLmhhc093blByb3BlcnR5KCdfcicpKVxuICAgICAgPyB2YWxcbiAgICAgIDogdGlueWNvbG9yKHZhbCB8fCB0aGlzLnBhcmFtc18uZGVmYXVsdFRvIHx8ICcjMDAwJyk7XG4gICAgaWYgKCFwYXVzZVVpKSB7XG4gICAgICB0aGlzLnRvX2VsXy5zcGVjdHJ1bSgnc2V0JywgdGhpcy50b192YWx1ZV8udG9SZ2JTdHJpbmcoKSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5Q2hhbmdlZF8odmFsLCBvbGRWYWx1ZSk7XG4gIH1cblxuICBzZXJpYWxpemVWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpLmZyb20udG9SZ2JTdHJpbmcoKStcIiBcIit0aGlzLmdldFZhbHVlKCkudG8udG9SZ2JTdHJpbmcoKVxuICB9XG5cbiAgZGVzZXJpYWxpemVWYWx1ZShzKSB7XG4gICAgbGV0IHNwbGl0ID0gcy5zcGxpdCgpO1xuICAgIGlmIChzcGxpdFswXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldEZyb21WYWx1ZShzcGxpdFswXSk7XG4gICAgfVxuICAgIGlmIChzcGxpdFsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFRvVmFsdWUoc3BsaXRbMV0pO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBDTElQQVJUX05BTUVTID0gW1xuICAnM2Rfcm90YXRpb24nLFxuICAnYWNfdW5pdCcsXG4gICdhY2Nlc3NfYWxhcm0nLFxuICAnYWNjZXNzX2FsYXJtcycsXG4gICdhY2Nlc3NfdGltZScsXG4gICdhY2Nlc3NpYmlsaXR5JyxcbiAgJ2FjY2Vzc2libGUnLFxuICAnYWNjb3VudF9iYWxhbmNlJyxcbiAgJ2FjY291bnRfYmFsYW5jZV93YWxsZXQnLFxuICAnYWNjb3VudF9ib3gnLFxuICAnYWNjb3VudF9jaXJjbGUnLFxuICAnYWRiJyxcbiAgJ2FkZCcsXG4gICdhZGRfYV9waG90bycsXG4gICdhZGRfYWxhcm0nLFxuICAnYWRkX2FsZXJ0JyxcbiAgJ2FkZF9ib3gnLFxuICAnYWRkX2NpcmNsZScsXG4gICdhZGRfY2lyY2xlX291dGxpbmUnLFxuICAnYWRkX2xvY2F0aW9uJyxcbiAgJ2FkZF9zaG9wcGluZ19jYXJ0JyxcbiAgJ2FkZF90b19waG90b3MnLFxuICAnYWRkX3RvX3F1ZXVlJyxcbiAgJ2FkanVzdCcsXG4gICdhaXJsaW5lX3NlYXRfZmxhdCcsXG4gICdhaXJsaW5lX3NlYXRfZmxhdF9hbmdsZWQnLFxuICAnYWlybGluZV9zZWF0X2luZGl2aWR1YWxfc3VpdGUnLFxuICAnYWlybGluZV9zZWF0X2xlZ3Jvb21fZXh0cmEnLFxuICAnYWlybGluZV9zZWF0X2xlZ3Jvb21fbm9ybWFsJyxcbiAgJ2FpcmxpbmVfc2VhdF9sZWdyb29tX3JlZHVjZWQnLFxuICAnYWlybGluZV9zZWF0X3JlY2xpbmVfZXh0cmEnLFxuICAnYWlybGluZV9zZWF0X3JlY2xpbmVfbm9ybWFsJyxcbiAgJ2FpcnBsYW5lbW9kZV9hY3RpdmUnLFxuICAnYWlycGxhbmVtb2RlX2luYWN0aXZlJyxcbiAgJ2FpcnBsYXknLFxuICAnYWlycG9ydF9zaHV0dGxlJyxcbiAgJ2FsYXJtJyxcbiAgJ2FsYXJtX2FkZCcsXG4gICdhbGFybV9vZmYnLFxuICAnYWxhcm1fb24nLFxuICAnYWxidW0nLFxuICAnYWxsX2luY2x1c2l2ZScsXG4gICdhbGxfb3V0JyxcbiAgJ2FuZHJvaWQnLFxuICAnYW5ub3VuY2VtZW50JyxcbiAgJ2FwcHMnLFxuICAnYXJjaGl2ZScsXG4gICdhcnJvd19iYWNrJyxcbiAgJ2Fycm93X2Rvd253YXJkJyxcbiAgJ2Fycm93X2Ryb3BfZG93bicsXG4gICdhcnJvd19kcm9wX2Rvd25fY2lyY2xlJyxcbiAgJ2Fycm93X2Ryb3BfdXAnLFxuICAnYXJyb3dfZm9yd2FyZCcsXG4gICdhcnJvd191cHdhcmQnLFxuICAnYXJ0X3RyYWNrJyxcbiAgJ2FzcGVjdF9yYXRpbycsXG4gICdhc3Nlc3NtZW50JyxcbiAgJ2Fzc2lnbm1lbnQnLFxuICAnYXNzaWdubWVudF9pbmQnLFxuICAnYXNzaWdubWVudF9sYXRlJyxcbiAgJ2Fzc2lnbm1lbnRfcmV0dXJuJyxcbiAgJ2Fzc2lnbm1lbnRfcmV0dXJuZWQnLFxuICAnYXNzaWdubWVudF90dXJuZWRfaW4nLFxuICAnYXNzaXN0YW50JyxcbiAgJ2Fzc2lzdGFudF9waG90bycsXG4gICdhdHRhY2hfZmlsZScsXG4gICdhdHRhY2hfbW9uZXknLFxuICAnYXR0YWNobWVudCcsXG4gICdhdWRpb3RyYWNrJyxcbiAgJ2F1dG9yZW5ldycsXG4gICdhdl90aW1lcicsXG4gICdiYWNrc3BhY2UnLFxuICAnYmFja3VwJyxcbiAgJ2JhdHRlcnlfYWxlcnQnLFxuICAnYmF0dGVyeV9jaGFyZ2luZ19mdWxsJyxcbiAgJ2JhdHRlcnlfZnVsbCcsXG4gICdiYXR0ZXJ5X3N0ZCcsXG4gICdiYXR0ZXJ5X3Vua25vd24nLFxuICAnYmVhY2hfYWNjZXNzJyxcbiAgJ2JlZW5oZXJlJyxcbiAgJ2Jsb2NrJyxcbiAgJ2JsdWV0b290aCcsXG4gICdibHVldG9vdGhfYXVkaW8nLFxuICAnYmx1ZXRvb3RoX2Nvbm5lY3RlZCcsXG4gICdibHVldG9vdGhfZGlzYWJsZWQnLFxuICAnYmx1ZXRvb3RoX3NlYXJjaGluZycsXG4gICdibHVyX2NpcmN1bGFyJyxcbiAgJ2JsdXJfbGluZWFyJyxcbiAgJ2JsdXJfb2ZmJyxcbiAgJ2JsdXJfb24nLFxuICAnYm9vaycsXG4gICdib29rbWFyaycsXG4gICdib29rbWFya19ib3JkZXInLFxuICAnYm9yZGVyX2FsbCcsXG4gICdib3JkZXJfYm90dG9tJyxcbiAgJ2JvcmRlcl9jbGVhcicsXG4gICdib3JkZXJfY29sb3InLFxuICAnYm9yZGVyX2hvcml6b250YWwnLFxuICAnYm9yZGVyX2lubmVyJyxcbiAgJ2JvcmRlcl9sZWZ0JyxcbiAgJ2JvcmRlcl9vdXRlcicsXG4gICdib3JkZXJfcmlnaHQnLFxuICAnYm9yZGVyX3N0eWxlJyxcbiAgJ2JvcmRlcl90b3AnLFxuICAnYm9yZGVyX3ZlcnRpY2FsJyxcbiAgJ2JyYW5kaW5nX3dhdGVybWFyaycsXG4gICdicmlnaHRuZXNzXzEnLFxuICAnYnJpZ2h0bmVzc18yJyxcbiAgJ2JyaWdodG5lc3NfMycsXG4gICdicmlnaHRuZXNzXzQnLFxuICAnYnJpZ2h0bmVzc181JyxcbiAgJ2JyaWdodG5lc3NfNicsXG4gICdicmlnaHRuZXNzXzcnLFxuICAnYnJpZ2h0bmVzc19hdXRvJyxcbiAgJ2JyaWdodG5lc3NfaGlnaCcsXG4gICdicmlnaHRuZXNzX2xvdycsXG4gICdicmlnaHRuZXNzX21lZGl1bScsXG4gICdicm9rZW5faW1hZ2UnLFxuICAnYnJ1c2gnLFxuICAnYnViYmxlX2NoYXJ0JyxcbiAgJ2J1Z19yZXBvcnQnLFxuICAnYnVpbGQnLFxuICAnYnVyc3RfbW9kZScsXG4gICdidXNpbmVzcycsXG4gICdidXNpbmVzc19jZW50ZXInLFxuICAnY2FjaGVkJyxcbiAgJ2Nha2UnLFxuICAnY2FsbCcsXG4gICdjYWxsX2VuZCcsXG4gICdjYWxsX21hZGUnLFxuICAnY2FsbF9tZXJnZScsXG4gICdjYWxsX21pc3NlZCcsXG4gICdjYWxsX21pc3NlZF9vdXRnb2luZycsXG4gICdjYWxsX3JlY2VpdmVkJyxcbiAgJ2NhbGxfc3BsaXQnLFxuICAnY2FsbF90b19hY3Rpb24nLFxuICAnY2FtZXJhJyxcbiAgJ2NhbWVyYV9hbHQnLFxuICAnY2FtZXJhX2VuaGFuY2UnLFxuICAnY2FtZXJhX2Zyb250JyxcbiAgJ2NhbWVyYV9yZWFyJyxcbiAgJ2NhbWVyYV9yb2xsJyxcbiAgJ2NhbmNlbCcsXG4gICdjYXJkX2dpZnRjYXJkJyxcbiAgJ2NhcmRfbWVtYmVyc2hpcCcsXG4gICdjYXJkX3RyYXZlbCcsXG4gICdjYXNpbm8nLFxuICAnY2FzdCcsXG4gICdjYXN0X2Nvbm5lY3RlZCcsXG4gICdjZW50ZXJfZm9jdXNfc3Ryb25nJyxcbiAgJ2NlbnRlcl9mb2N1c193ZWFrJyxcbiAgJ2NoYW5nZV9oaXN0b3J5JyxcbiAgJ2NoYXQnLFxuICAnY2hhdF9idWJibGUnLFxuICAnY2hhdF9idWJibGVfb3V0bGluZScsXG4gICdjaGVjaycsXG4gICdjaGVja19ib3gnLFxuICAnY2hlY2tfYm94X291dGxpbmVfYmxhbmsnLFxuICAnY2hlY2tfY2lyY2xlJyxcbiAgJ2NoZXZyb25fbGVmdCcsXG4gICdjaGV2cm9uX3JpZ2h0JyxcbiAgJ2NoaWxkX2NhcmUnLFxuICAnY2hpbGRfZnJpZW5kbHknLFxuICAnY2hyb21lX3JlYWRlcl9tb2RlJyxcbiAgJ2NsYXNzJyxcbiAgJ2NsZWFyJyxcbiAgJ2NsZWFyX2FsbCcsXG4gICdjbG9zZScsXG4gICdjbG9zZWRfY2FwdGlvbicsXG4gICdjbG91ZCcsXG4gICdjbG91ZF9jaXJjbGUnLFxuICAnY2xvdWRfZG9uZScsXG4gICdjbG91ZF9kb3dubG9hZCcsXG4gICdjbG91ZF9vZmYnLFxuICAnY2xvdWRfcXVldWUnLFxuICAnY2xvdWRfdXBsb2FkJyxcbiAgJ2NvZGUnLFxuICAnY29sbGVjdGlvbnMnLFxuICAnY29sbGVjdGlvbnNfYm9va21hcmsnLFxuICAnY29sb3JfbGVucycsXG4gICdjb2xvcml6ZScsXG4gICdjb21tZW50JyxcbiAgJ2NvbXBhcmUnLFxuICAnY29tcGFyZV9hcnJvd3MnLFxuICAnY29tcHV0ZXInLFxuICAnY29uZmlybWF0aW9uX251bWJlcicsXG4gICdjb250YWN0X21haWwnLFxuICAnY29udGFjdF9waG9uZScsXG4gICdjb250YWN0cycsXG4gICdjb250ZW50X2NvcHknLFxuICAnY29udGVudF9jdXQnLFxuICAnY29udGVudF9wYXN0ZScsXG4gICdjb250cm9sX3BvaW50JyxcbiAgJ2NvbnRyb2xfcG9pbnRfZHVwbGljYXRlJyxcbiAgJ2NvcHlyaWdodCcsXG4gICdjcmVhdGUnLFxuICAnY3JlYXRlX25ld19mb2xkZXInLFxuICAnY3JlZGl0X2NhcmQnLFxuICAnY3JvcCcsXG4gICdjcm9wXzE2XzknLFxuICAnY3JvcF8zXzInLFxuICAnY3JvcF81XzQnLFxuICAnY3JvcF83XzUnLFxuICAnY3JvcF9kaW4nLFxuICAnY3JvcF9mcmVlJyxcbiAgJ2Nyb3BfbGFuZHNjYXBlJyxcbiAgJ2Nyb3Bfb3JpZ2luYWwnLFxuICAnY3JvcF9wb3J0cmFpdCcsXG4gICdjcm9wX3JvdGF0ZScsXG4gICdjcm9wX3NxdWFyZScsXG4gICdkYXNoYm9hcmQnLFxuICAnZGF0YV91c2FnZScsXG4gICdkYXRlX3JhbmdlJyxcbiAgJ2RlaGF6ZScsXG4gICdkZWxldGUnLFxuICAnZGVsZXRlX2ZvcmV2ZXInLFxuICAnZGVsZXRlX3N3ZWVwJyxcbiAgJ2Rlc2NyaXB0aW9uJyxcbiAgJ2Rlc2t0b3BfbWFjJyxcbiAgJ2Rlc2t0b3Bfd2luZG93cycsXG4gICdkZXRhaWxzJyxcbiAgJ2RldmVsb3Blcl9ib2FyZCcsXG4gICdkZXZlbG9wZXJfbW9kZScsXG4gICdkZXZpY2VfaHViJyxcbiAgJ2RldmljZXMnLFxuICAnZGV2aWNlc19vdGhlcicsXG4gICdkaWFsZXJfc2lwJyxcbiAgJ2RpYWxwYWQnLFxuICAnZGlyZWN0aW9ucycsXG4gICdkaXJlY3Rpb25zX2Jpa2UnLFxuICAnZGlyZWN0aW9uc19ib2F0JyxcbiAgJ2RpcmVjdGlvbnNfYnVzJyxcbiAgJ2RpcmVjdGlvbnNfY2FyJyxcbiAgJ2RpcmVjdGlvbnNfcmFpbHdheScsXG4gICdkaXJlY3Rpb25zX3J1bicsXG4gICdkaXJlY3Rpb25zX3N1YndheScsXG4gICdkaXJlY3Rpb25zX3RyYW5zaXQnLFxuICAnZGlyZWN0aW9uc193YWxrJyxcbiAgJ2Rpc2NfZnVsbCcsXG4gICdkbnMnLFxuICAnZG9fbm90X2Rpc3R1cmInLFxuICAnZG9fbm90X2Rpc3R1cmJfYWx0JyxcbiAgJ2RvX25vdF9kaXN0dXJiX29mZicsXG4gICdkb19ub3RfZGlzdHVyYl9vbicsXG4gICdkb2NrJyxcbiAgJ2RvbWFpbicsXG4gICdkb25lJyxcbiAgJ2RvbmVfYWxsJyxcbiAgJ2RvbnV0X2xhcmdlJyxcbiAgJ2RvbnV0X3NtYWxsJyxcbiAgJ2RyYWZ0cycsXG4gICdkcmFnX2hhbmRsZScsXG4gICdkcml2ZV9ldGEnLFxuICAnZHZyJyxcbiAgJ2VkaXQnLFxuICAnZWRpdF9sb2NhdGlvbicsXG4gICdlamVjdCcsXG4gICdlbWFpbCcsXG4gICdlbmhhbmNlZF9lbmNyeXB0aW9uJyxcbiAgJ2VxdWFsaXplcicsXG4gICdlcnJvcicsXG4gICdlcnJvcl9vdXRsaW5lJyxcbiAgJ2V1cm9fc3ltYm9sJyxcbiAgJ2V2X3N0YXRpb24nLFxuICAnZXZlbnQnLFxuICAnZXZlbnRfYXZhaWxhYmxlJyxcbiAgJ2V2ZW50X2J1c3knLFxuICAnZXZlbnRfbm90ZScsXG4gICdldmVudF9zZWF0JyxcbiAgJ2V4aXRfdG9fYXBwJyxcbiAgJ2V4cGFuZF9sZXNzJyxcbiAgJ2V4cGFuZF9tb3JlJyxcbiAgJ2V4cGxpY2l0JyxcbiAgJ2V4cGxvcmUnLFxuICAnZXhwb3N1cmUnLFxuICAnZXhwb3N1cmVfbmVnXzEnLFxuICAnZXhwb3N1cmVfbmVnXzInLFxuICAnZXhwb3N1cmVfcGx1c18xJyxcbiAgJ2V4cG9zdXJlX3BsdXNfMicsXG4gICdleHBvc3VyZV96ZXJvJyxcbiAgJ2V4dGVuc2lvbicsXG4gICdmYWNlJyxcbiAgJ2Zhc3RfZm9yd2FyZCcsXG4gICdmYXN0X3Jld2luZCcsXG4gICdmYXZvcml0ZScsXG4gICdmYXZvcml0ZV9ib3JkZXInLFxuICAnZmVhdHVyZWRfcGxheV9saXN0JyxcbiAgJ2ZlYXR1cmVkX3ZpZGVvJyxcbiAgJ2ZlZWRiYWNrJyxcbiAgJ2ZpYmVyX2R2cicsXG4gICdmaWJlcl9tYW51YWxfcmVjb3JkJyxcbiAgJ2ZpYmVyX25ldycsXG4gICdmaWJlcl9waW4nLFxuICAnZmliZXJfc21hcnRfcmVjb3JkJyxcbiAgJ2ZpbGVfZG93bmxvYWQnLFxuICAnZmlsZV91cGxvYWQnLFxuICAnZmlsdGVyJyxcbiAgJ2ZpbHRlcl8xJyxcbiAgJ2ZpbHRlcl8yJyxcbiAgJ2ZpbHRlcl8zJyxcbiAgJ2ZpbHRlcl80JyxcbiAgJ2ZpbHRlcl81JyxcbiAgJ2ZpbHRlcl82JyxcbiAgJ2ZpbHRlcl83JyxcbiAgJ2ZpbHRlcl84JyxcbiAgJ2ZpbHRlcl85JyxcbiAgJ2ZpbHRlcl85X3BsdXMnLFxuICAnZmlsdGVyX2JfYW5kX3cnLFxuICAnZmlsdGVyX2NlbnRlcl9mb2N1cycsXG4gICdmaWx0ZXJfZHJhbWEnLFxuICAnZmlsdGVyX2ZyYW1lcycsXG4gICdmaWx0ZXJfaGRyJyxcbiAgJ2ZpbHRlcl9saXN0JyxcbiAgJ2ZpbHRlcl9ub25lJyxcbiAgJ2ZpbHRlcl90aWx0X3NoaWZ0JyxcbiAgJ2ZpbHRlcl92aW50YWdlJyxcbiAgJ2ZpbmRfaW5fcGFnZScsXG4gICdmaW5kX3JlcGxhY2UnLFxuICAnZmluZ2VycHJpbnQnLFxuICAnZmlyc3RfcGFnZScsXG4gICdmaXRuZXNzX2NlbnRlcicsXG4gICdmbGFnJyxcbiAgJ2ZsYXJlJyxcbiAgJ2ZsYXNoX2F1dG8nLFxuICAnZmxhc2hfb2ZmJyxcbiAgJ2ZsYXNoX29uJyxcbiAgJ2ZsaWdodCcsXG4gICdmbGlnaHRfbGFuZCcsXG4gICdmbGlnaHRfdGFrZW9mZicsXG4gICdmbGlwJyxcbiAgJ2ZsaXBfdG9fYmFjaycsXG4gICdmbGlwX3RvX2Zyb250JyxcbiAgJ2ZvbGRlcicsXG4gICdmb2xkZXJfb3BlbicsXG4gICdmb2xkZXJfc2hhcmVkJyxcbiAgJ2ZvbGRlcl9zcGVjaWFsJyxcbiAgJ2ZvbnRfZG93bmxvYWQnLFxuICAnZm9ybWF0X2FsaWduX2NlbnRlcicsXG4gICdmb3JtYXRfYWxpZ25fanVzdGlmeScsXG4gICdmb3JtYXRfYWxpZ25fbGVmdCcsXG4gICdmb3JtYXRfYWxpZ25fcmlnaHQnLFxuICAnZm9ybWF0X2JvbGQnLFxuICAnZm9ybWF0X2NsZWFyJyxcbiAgJ2Zvcm1hdF9jb2xvcl9maWxsJyxcbiAgJ2Zvcm1hdF9jb2xvcl9yZXNldCcsXG4gICdmb3JtYXRfY29sb3JfdGV4dCcsXG4gICdmb3JtYXRfaW5kZW50X2RlY3JlYXNlJyxcbiAgJ2Zvcm1hdF9pbmRlbnRfaW5jcmVhc2UnLFxuICAnZm9ybWF0X2xpbmVfc3BhY2luZycsXG4gICdmb3JtYXRfbGlzdF9idWxsZXRlZCcsXG4gICdmb3JtYXRfbGlzdF9udW1iZXJlZCcsXG4gICdmb3JtYXRfcGFpbnQnLFxuICAnZm9ybWF0X3F1b3RlJyxcbiAgJ2Zvcm1hdF9zaGFwZXMnLFxuICAnZm9ybWF0X3NpemUnLFxuICAnZm9ybWF0X3N0cmlrZXRocm91Z2gnLFxuICAnZm9ybWF0X3RleHRkaXJlY3Rpb25fbF90b19yJyxcbiAgJ2Zvcm1hdF90ZXh0ZGlyZWN0aW9uX3JfdG9fbCcsXG4gICdmb3JtYXRfdW5kZXJsaW5lZCcsXG4gICdmb3J1bScsXG4gICdmb3J3YXJkJyxcbiAgJ2ZvcndhcmRfMTAnLFxuICAnZm9yd2FyZF8zMCcsXG4gICdmb3J3YXJkXzUnLFxuICAnZnJlZV9icmVha2Zhc3QnLFxuICAnZnVsbHNjcmVlbicsXG4gICdmdWxsc2NyZWVuX2V4aXQnLFxuICAnZnVuY3Rpb25zJyxcbiAgJ2dfdHJhbnNsYXRlJyxcbiAgJ2dhbWVwYWQnLFxuICAnZ2FtZXMnLFxuICAnZ2F2ZWwnLFxuICAnZ2VzdHVyZScsXG4gICdnZXRfYXBwJyxcbiAgJ2dpZicsXG4gICdnb2xmX2NvdXJzZScsXG4gICdncHNfZml4ZWQnLFxuICAnZ3BzX25vdF9maXhlZCcsXG4gICdncHNfb2ZmJyxcbiAgJ2dyYWRlJyxcbiAgJ2dyYWRpZW50JyxcbiAgJ2dyYWluJyxcbiAgJ2dyaWRfb2ZmJyxcbiAgJ2dyaWRfb24nLFxuICAnZ3JvdXAnLFxuICAnZ3JvdXBfYWRkJyxcbiAgJ2dyb3VwX3dvcmsnLFxuICAnaGQnLFxuICAnaGRyX29mZicsXG4gICdoZHJfb24nLFxuICAnaGRyX3N0cm9uZycsXG4gICdoZHJfd2VhaycsXG4gICdoZWFkc2V0JyxcbiAgJ2hlYWxpbmcnLFxuICAnaGVhcmluZycsXG4gICdoZWxwJyxcbiAgJ2hlbHBfb3V0bGluZScsXG4gICdoaWdoX3F1YWxpdHknLFxuICAnaGlnaGxpZ2h0JyxcbiAgJ2hpZ2hsaWdodF9vZmYnLFxuICAnaGlzdG9yeScsXG4gICdob21lJyxcbiAgJ2hvdF90dWInLFxuICAnaG90ZWwnLFxuICAnaG91cmdsYXNzX2VtcHR5JyxcbiAgJ2hvdXJnbGFzc19mdWxsJyxcbiAgJ2h0dHAnLFxuICAnaHR0cHMnLFxuICAnaW1hZ2UnLFxuICAnaW1hZ2VfYXNwZWN0X3JhdGlvJyxcbiAgJ2ltcG9ydF9jb250YWN0cycsXG4gICdpbXBvcnRfZXhwb3J0JyxcbiAgJ2ltcG9ydGFudF9kZXZpY2VzJyxcbiAgJ2luYm94JyxcbiAgJ2luZGV0ZXJtaW5hdGVfY2hlY2tfYm94JyxcbiAgJ2luZm8nLFxuICAnaW5mb19vdXRsaW5lJyxcbiAgJ2lucHV0JyxcbiAgJ2luc2VydF9jaGFydCcsXG4gICdpbnNlcnRfY29tbWVudCcsXG4gICdpbnNlcnRfZHJpdmVfZmlsZScsXG4gICdpbnNlcnRfZW1vdGljb24nLFxuICAnaW5zZXJ0X2ludml0YXRpb24nLFxuICAnaW5zZXJ0X2xpbmsnLFxuICAnaW5zZXJ0X3Bob3RvJyxcbiAgJ2ludmVydF9jb2xvcnMnLFxuICAnaW52ZXJ0X2NvbG9yc19vZmYnLFxuICAnaXNvJyxcbiAgJ2tleWJvYXJkJyxcbiAgJ2tleWJvYXJkX2Fycm93X2Rvd24nLFxuICAna2V5Ym9hcmRfYXJyb3dfbGVmdCcsXG4gICdrZXlib2FyZF9hcnJvd19yaWdodCcsXG4gICdrZXlib2FyZF9hcnJvd191cCcsXG4gICdrZXlib2FyZF9iYWNrc3BhY2UnLFxuICAna2V5Ym9hcmRfY2Fwc2xvY2snLFxuICAna2V5Ym9hcmRfaGlkZScsXG4gICdrZXlib2FyZF9yZXR1cm4nLFxuICAna2V5Ym9hcmRfdGFiJyxcbiAgJ2tleWJvYXJkX3ZvaWNlJyxcbiAgJ2tpdGNoZW4nLFxuICAnbGFiZWwnLFxuICAnbGFiZWxfb3V0bGluZScsXG4gICdsYW5kc2NhcGUnLFxuICAnbGFuZ3VhZ2UnLFxuICAnbGFwdG9wJyxcbiAgJ2xhcHRvcF9jaHJvbWVib29rJyxcbiAgJ2xhcHRvcF9tYWMnLFxuICAnbGFwdG9wX3dpbmRvd3MnLFxuICAnbGFzdF9wYWdlJyxcbiAgJ2xhdW5jaCcsXG4gICdsYXllcnMnLFxuICAnbGF5ZXJzX2NsZWFyJyxcbiAgJ2xlYWtfYWRkJyxcbiAgJ2xlYWtfcmVtb3ZlJyxcbiAgJ2xlbnMnLFxuICAnbGlicmFyeV9hZGQnLFxuICAnbGlicmFyeV9ib29rcycsXG4gICdsaWdodGJ1bGJfb3V0bGluZScsXG4gICdsaW5lX3N0eWxlJyxcbiAgJ2xpbmVfd2VpZ2h0JyxcbiAgJ2xpbmVhcl9zY2FsZScsXG4gICdsaW5rJyxcbiAgJ2xpbmtlZF9jYW1lcmEnLFxuICAnbGlzdCcsXG4gICdsaXZlX2hlbHAnLFxuICAnbGl2ZV90dicsXG4gICdsb2NhbF9hY3Rpdml0eScsXG4gICdsb2NhbF9haXJwb3J0JyxcbiAgJ2xvY2FsX2F0bScsXG4gICdsb2NhbF9iYXInLFxuICAnbG9jYWxfY2FmZScsXG4gICdsb2NhbF9jYXJfd2FzaCcsXG4gICdsb2NhbF9jb252ZW5pZW5jZV9zdG9yZScsXG4gICdsb2NhbF9kaW5pbmcnLFxuICAnbG9jYWxfZHJpbmsnLFxuICAnbG9jYWxfZmxvcmlzdCcsXG4gICdsb2NhbF9nYXNfc3RhdGlvbicsXG4gICdsb2NhbF9ncm9jZXJ5X3N0b3JlJyxcbiAgJ2xvY2FsX2hvc3BpdGFsJyxcbiAgJ2xvY2FsX2hvdGVsJyxcbiAgJ2xvY2FsX2xhdW5kcnlfc2VydmljZScsXG4gICdsb2NhbF9saWJyYXJ5JyxcbiAgJ2xvY2FsX21hbGwnLFxuICAnbG9jYWxfbW92aWVzJyxcbiAgJ2xvY2FsX29mZmVyJyxcbiAgJ2xvY2FsX3BhcmtpbmcnLFxuICAnbG9jYWxfcGhhcm1hY3knLFxuICAnbG9jYWxfcGhvbmUnLFxuICAnbG9jYWxfcGl6emEnLFxuICAnbG9jYWxfcGxheScsXG4gICdsb2NhbF9wb3N0X29mZmljZScsXG4gICdsb2NhbF9wcmludHNob3AnLFxuICAnbG9jYWxfc2VlJyxcbiAgJ2xvY2FsX3NoaXBwaW5nJyxcbiAgJ2xvY2FsX3RheGknLFxuICAnbG9jYXRpb25fY2l0eScsXG4gICdsb2NhdGlvbl9kaXNhYmxlZCcsXG4gICdsb2NhdGlvbl9vZmYnLFxuICAnbG9jYXRpb25fb24nLFxuICAnbG9jYXRpb25fc2VhcmNoaW5nJyxcbiAgJ2xvY2snLFxuICAnbG9ja19vcGVuJyxcbiAgJ2xvY2tfb3V0bGluZScsXG4gICdsb29rcycsXG4gICdsb29rc18zJyxcbiAgJ2xvb2tzXzQnLFxuICAnbG9va3NfNScsXG4gICdsb29rc182JyxcbiAgJ2xvb2tzX29uZScsXG4gICdsb29rc190d28nLFxuICAnbG9vcCcsXG4gICdsb3VwZScsXG4gICdsb3dfcHJpb3JpdHknLFxuICAnbG95YWx0eScsXG4gICdtYWlsJyxcbiAgJ21haWxfb3V0bGluZScsXG4gICdtYXAnLFxuICAnbWFya3VucmVhZCcsXG4gICdtYXJrdW5yZWFkX21haWxib3gnLFxuICAnbWVtb3J5JyxcbiAgJ21lbnUnLFxuICAnbWVyZ2VfdHlwZScsXG4gICdtZXNzYWdlJyxcbiAgJ21tcycsXG4gICdtb2RlX2NvbW1lbnQnLFxuICAnbW9kZV9lZGl0JyxcbiAgJ21vbmV0aXphdGlvbl9vbicsXG4gICdtb25leV9vZmYnLFxuICAnbW9ub2Nocm9tZV9waG90b3MnLFxuICAnbW9vZCcsXG4gICdtb29kX2JhZCcsXG4gICdtb3JlJyxcbiAgJ21vcmVfaG9yaXonLFxuICAnbW9yZV92ZXJ0JyxcbiAgJ21vdG9yY3ljbGUnLFxuICAnbW91c2UnLFxuICAnbW92ZV90b19pbmJveCcsXG4gICdtb3ZpZScsXG4gICdtb3ZpZV9jcmVhdGlvbicsXG4gICdtb3ZpZV9maWx0ZXInLFxuICAnbXVsdGlsaW5lX2NoYXJ0JyxcbiAgJ215X2xvY2F0aW9uJyxcbiAgJ25hdHVyZScsXG4gICduYXR1cmVfcGVvcGxlJyxcbiAgJ25hdmlnYXRlX2JlZm9yZScsXG4gICduYXZpZ2F0ZV9uZXh0JyxcbiAgJ25hdmlnYXRpb24nLFxuICAnbmVhcl9tZScsXG4gICduZXR3b3JrX2NlbGwnLFxuICAnbmV0d29ya19jaGVjaycsXG4gICduZXR3b3JrX2xvY2tlZCcsXG4gICduZXR3b3JrX3dpZmknLFxuICAnbmV3X3JlbGVhc2VzJyxcbiAgJ25leHRfd2VlaycsXG4gICduZmMnLFxuICAnbm9fZW5jcnlwdGlvbicsXG4gICdub19zaW0nLFxuICAnbm90X2ludGVyZXN0ZWQnLFxuICAnbm90ZScsXG4gICdub3RlJyxcbiAgJ25vdGVfYWRkJyxcbiAgJ25vdGlmaWNhdGlvbnMnLFxuICAnbm90aWZpY2F0aW9uc19hY3RpdmUnLFxuICAnbm90aWZpY2F0aW9uc19ub25lJyxcbiAgJ25vdGlmaWNhdGlvbnNfb2ZmJyxcbiAgJ25vdGlmaWNhdGlvbnNfcGF1c2VkJyxcbiAgJ29mZmxpbmVfcGluJyxcbiAgJ29uZGVtYW5kX3ZpZGVvJyxcbiAgJ29wYWNpdHknLFxuICAnb3Blbl9pbl9icm93c2VyJyxcbiAgJ29wZW5faW5fbmV3JyxcbiAgJ29wZW5fd2l0aCcsXG4gICdwYWdlcycsXG4gICdwYWdldmlldycsXG4gICdwYWxldHRlJyxcbiAgJ3Bhbl90b29sJyxcbiAgJ3Bhbm9yYW1hJyxcbiAgJ3Bhbm9yYW1hX2Zpc2hfZXllJyxcbiAgJ3Bhbm9yYW1hX2hvcml6b250YWwnLFxuICAncGFub3JhbWFfdmVydGljYWwnLFxuICAncGFub3JhbWFfd2lkZV9hbmdsZScsXG4gICdwYXJ0eV9tb2RlJyxcbiAgJ3BhdXNlJyxcbiAgJ3BhdXNlX2NpcmNsZV9maWxsZWQnLFxuICAncGF1c2VfY2lyY2xlX291dGxpbmUnLFxuICAncGF5bWVudCcsXG4gICdwZW9wbGUnLFxuICAncGVvcGxlX291dGxpbmUnLFxuICAncGVybV9jb250YWN0X2NhbGVuZGFyJyxcbiAgJ3Blcm1fZGF0YV9zZXR0aW5nJyxcbiAgJ3Blcm1fZGV2aWNlX2luZm9ybWF0aW9uJyxcbiAgJ3Blcm1faWRlbnRpdHknLFxuICAncGVybV9tZWRpYScsXG4gICdwZXJtX3Bob25lX21zZycsXG4gICdwZXJtX3NjYW5fd2lmaScsXG4gICdwZXJzb24nLFxuICAncGVyc29uX2FkZCcsXG4gICdwZXJzb25fb3V0bGluZScsXG4gICdwZXJzb25fcGluJyxcbiAgJ3BlcnNvbl9waW5fY2lyY2xlJyxcbiAgJ3BlcnNvbmFsX3ZpZGVvJyxcbiAgJ3BldHMnLFxuICAncGhvbmUnLFxuICAncGhvbmVfYW5kcm9pZCcsXG4gICdwaG9uZV9ibHVldG9vdGhfc3BlYWtlcicsXG4gICdwaG9uZV9mb3J3YXJkZWQnLFxuICAncGhvbmVfaW5fdGFsaycsXG4gICdwaG9uZV9pcGhvbmUnLFxuICAncGhvbmVfbG9ja2VkJyxcbiAgJ3Bob25lX21pc3NlZCcsXG4gICdwaG9uZV9wYXVzZWQnLFxuICAncGhvbmVsaW5rJyxcbiAgJ3Bob25lbGlua19lcmFzZScsXG4gICdwaG9uZWxpbmtfbG9jaycsXG4gICdwaG9uZWxpbmtfb2ZmJyxcbiAgJ3Bob25lbGlua19yaW5nJyxcbiAgJ3Bob25lbGlua19zZXR1cCcsXG4gICdwaG90bycsXG4gICdwaG90b19hbGJ1bScsXG4gICdwaG90b19jYW1lcmEnLFxuICAncGhvdG9fZmlsdGVyJyxcbiAgJ3Bob3RvX2xpYnJhcnknLFxuICAncGhvdG9fc2l6ZV9zZWxlY3RfYWN0dWFsJyxcbiAgJ3Bob3RvX3NpemVfc2VsZWN0X2xhcmdlJyxcbiAgJ3Bob3RvX3NpemVfc2VsZWN0X3NtYWxsJyxcbiAgJ3BpY3R1cmVfYXNfcGRmJyxcbiAgJ3BpY3R1cmVfaW5fcGljdHVyZScsXG4gICdwaWN0dXJlX2luX3BpY3R1cmVfYWx0JyxcbiAgJ3BpZV9jaGFydCcsXG4gICdwaWVfY2hhcnRfb3V0bGluZWQnLFxuICAncGluX2Ryb3AnLFxuICAncGxhY2UnLFxuICAncGxheV9hcnJvdycsXG4gICdwbGF5X2NpcmNsZV9maWxsZWQnLFxuICAncGxheV9jaXJjbGVfb3V0bGluZScsXG4gICdwbGF5X2Zvcl93b3JrJyxcbiAgJ3BsYXlsaXN0X2FkZCcsXG4gICdwbGF5bGlzdF9hZGRfY2hlY2snLFxuICAncGxheWxpc3RfcGxheScsXG4gICdwbHVzX29uZScsXG4gICdwb2xsJyxcbiAgJ3BvbHltZXInLFxuICAncG9vbCcsXG4gICdwb3J0YWJsZV93aWZpX29mZicsXG4gICdwb3J0cmFpdCcsXG4gICdwb3dlcicsXG4gICdwb3dlcl9pbnB1dCcsXG4gICdwb3dlcl9zZXR0aW5nc19uZXcnLFxuICAncHJlZ25hbnRfd29tYW4nLFxuICAncHJlc2VudF90b19hbGwnLFxuICAncHJpbnQnLFxuICAncHJpb3JpdHlfaGlnaCcsXG4gICdwdWJsaXNoJyxcbiAgJ3F1ZXJ5X2J1aWxkZXInLFxuICAncXVlc3Rpb25fYW5zd2VyJyxcbiAgJ3F1ZXVlJyxcbiAgJ3F1ZXVlX3BsYXlfbmV4dCcsXG4gICdyYWRpbycsXG4gICdyYWRpb19idXR0b25fY2hlY2tlZCcsXG4gICdyYWRpb19idXR0b25fdW5jaGVja2VkJyxcbiAgJ3JhdGVfcmV2aWV3JyxcbiAgJ3JlY2VpcHQnLFxuICAncmVjZW50X2FjdG9ycycsXG4gICdyZWNvcmRfdm9pY2Vfb3ZlcicsXG4gICdyZWRlZW0nLFxuICAncmVkbycsXG4gICdyZWZyZXNoJyxcbiAgJ3JlbW92ZScsXG4gICdyZW1vdmVfY2lyY2xlJyxcbiAgJ3JlbW92ZV9jaXJjbGVfb3V0bGluZScsXG4gICdyZW1vdmVfZnJvbV9xdWV1ZScsXG4gICdyZW1vdmVfcmVkX2V5ZScsXG4gICdyZW1vdmVfc2hvcHBpbmdfY2FydCcsXG4gICdyZW9yZGVyJyxcbiAgJ3JlcGVhdCcsXG4gICdyZXBlYXRfb25lJyxcbiAgJ3JlcGxheScsXG4gICdyZXBsYXlfMTAnLFxuICAncmVwbGF5XzMwJyxcbiAgJ3JlcGxheV81JyxcbiAgJ3JlcGx5JyxcbiAgJ3JlcGx5X2FsbCcsXG4gICdyZXBvcnQnLFxuICAncmVwb3J0X3Byb2JsZW0nLFxuICAncmVzdGF1cmFudCcsXG4gICdyZXN0YXVyYW50X21lbnUnLFxuICAncmVzdG9yZScsXG4gICdyZXN0b3JlX3BhZ2UnLFxuICAncmluZ192b2x1bWUnLFxuICAncm9vbScsXG4gICdyb29tX3NlcnZpY2UnLFxuICAncm90YXRlXzkwX2RlZ3JlZXNfY2N3JyxcbiAgJ3JvdGF0ZV9sZWZ0JyxcbiAgJ3JvdGF0ZV9yaWdodCcsXG4gICdyb3VuZGVkX2Nvcm5lcicsXG4gICdyb3V0ZXInLFxuICAncm93aW5nJyxcbiAgJ3Jzc19mZWVkJyxcbiAgJ3J2X2hvb2t1cCcsXG4gICdydl9ob29rdXAnLFxuICAnc2F0ZWxsaXRlJyxcbiAgJ3NhdmUnLFxuICAnc2Nhbm5lcicsXG4gICdzY2hlZHVsZScsXG4gICdzY2hvb2wnLFxuICAnc2NyZWVuX2xvY2tfbGFuZHNjYXBlJyxcbiAgJ3NjcmVlbl9sb2NrX3BvcnRyYWl0JyxcbiAgJ3NjcmVlbl9sb2NrX3JvdGF0aW9uJyxcbiAgJ3NjcmVlbl9yb3RhdGlvbicsXG4gICdzY3JlZW5fc2hhcmUnLFxuICAnc2RfY2FyZCcsXG4gICdzZF9zdG9yYWdlJyxcbiAgJ3NlYXJjaCcsXG4gICdzZWN1cml0eScsXG4gICdzZWxlY3RfYWxsJyxcbiAgJ3NlbmQnLFxuICAnc2VudGltZW50X2Rpc3NhdGlzZmllZCcsXG4gICdzZW50aW1lbnRfbmV1dHJhbCcsXG4gICdzZW50aW1lbnRfc2F0aXNmaWVkJyxcbiAgJ3NlbnRpbWVudF92ZXJ5X2Rpc3NhdGlzZmllZCcsXG4gICdzZW50aW1lbnRfdmVyeV9zYXRpc2ZpZWQnLFxuICAnc2V0dGluZ3MnLFxuICAnc2V0dGluZ3NfYXBwbGljYXRpb25zJyxcbiAgJ3NldHRpbmdzX2JhY2t1cF9yZXN0b3JlJyxcbiAgJ3NldHRpbmdzX2JsdWV0b290aCcsXG4gICdzZXR0aW5nc19icmlnaHRuZXNzJyxcbiAgJ3NldHRpbmdzX2NlbGwnLFxuICAnc2V0dGluZ3NfZXRoZXJuZXQnLFxuICAnc2V0dGluZ3NfaW5wdXRfYW50ZW5uYScsXG4gICdzZXR0aW5nc19pbnB1dF9jb21wb25lbnQnLFxuICAnc2V0dGluZ3NfaW5wdXRfY29tcG9zaXRlJyxcbiAgJ3NldHRpbmdzX2lucHV0X2hkbWknLFxuICAnc2V0dGluZ3NfaW5wdXRfc3ZpZGVvJyxcbiAgJ3NldHRpbmdzX292ZXJzY2FuJyxcbiAgJ3NldHRpbmdzX3Bob25lJyxcbiAgJ3NldHRpbmdzX3Bvd2VyJyxcbiAgJ3NldHRpbmdzX3JlbW90ZScsXG4gICdzZXR0aW5nc19zeXN0ZW1fZGF5ZHJlYW0nLFxuICAnc2V0dGluZ3Nfdm9pY2UnLFxuICAnc2hhcmUnLFxuICAnc2hvcCcsXG4gICdzaG9wX3R3bycsXG4gICdzaG9wcGluZ19iYXNrZXQnLFxuICAnc2hvcHBpbmdfY2FydCcsXG4gICdzaG9ydF90ZXh0JyxcbiAgJ3Nob3dfY2hhcnQnLFxuICAnc2h1ZmZsZScsXG4gICdzaWduYWxfY2VsbHVsYXJfNF9iYXInLFxuICAnc2lnbmFsX2NlbGx1bGFyX2Nvbm5lY3RlZF9ub19pbnRlcm5ldF80X2JhcicsXG4gICdzaWduYWxfY2VsbHVsYXJfbm9fc2ltJyxcbiAgJ3NpZ25hbF9jZWxsdWxhcl9udWxsJyxcbiAgJ3NpZ25hbF9jZWxsdWxhcl9vZmYnLFxuICAnc2lnbmFsX3dpZmlfNF9iYXInLFxuICAnc2lnbmFsX3dpZmlfNF9iYXJfbG9jaycsXG4gICdzaWduYWxfd2lmaV9vZmYnLFxuICAnc2ltX2NhcmQnLFxuICAnc2ltX2NhcmRfYWxlcnQnLFxuICAnc2tpcF9uZXh0JyxcbiAgJ3NraXBfcHJldmlvdXMnLFxuICAnc2xpZGVzaG93JyxcbiAgJ3Nsb3dfbW90aW9uX3ZpZGVvJyxcbiAgJ3NtYXJ0cGhvbmUnLFxuICAnc21va2VfZnJlZScsXG4gICdzbW9raW5nX3Jvb21zJyxcbiAgJ3NtcycsXG4gICdzbXNfZmFpbGVkJyxcbiAgJ3Nub296ZScsXG4gICdzb3J0JyxcbiAgJ3NvcnRfYnlfYWxwaGEnLFxuICAnc3BhJyxcbiAgJ3NwYWNlX2JhcicsXG4gICdzcGVha2VyJyxcbiAgJ3NwZWFrZXJfZ3JvdXAnLFxuICAnc3BlYWtlcl9ub3RlcycsXG4gICdzcGVha2VyX25vdGVzX29mZicsXG4gICdzcGVha2VyX3Bob25lJyxcbiAgJ3NwZWxsY2hlY2snLFxuICAnc3RhcicsXG4gICdzdGFyX2JvcmRlcicsXG4gICdzdGFyX2hhbGYnLFxuICAnc3RhcnMnLFxuICAnc3RheV9jdXJyZW50X2xhbmRzY2FwZScsXG4gICdzdGF5X2N1cnJlbnRfcG9ydHJhaXQnLFxuICAnc3RheV9wcmltYXJ5X2xhbmRzY2FwZScsXG4gICdzdGF5X3ByaW1hcnlfcG9ydHJhaXQnLFxuICAnc3RvcCcsXG4gICdzdG9wX3NjcmVlbl9zaGFyZScsXG4gICdzdG9yYWdlJyxcbiAgJ3N0b3JlJyxcbiAgJ3N0b3JlX21hbGxfZGlyZWN0b3J5JyxcbiAgJ3N0cmFpZ2h0ZW4nLFxuICAnc3RyZWV0dmlldycsXG4gICdzdHJpa2V0aHJvdWdoX3MnLFxuICAnc3R5bGUnLFxuICAnc3ViZGlyZWN0b3J5X2Fycm93X2xlZnQnLFxuICAnc3ViZGlyZWN0b3J5X2Fycm93X3JpZ2h0JyxcbiAgJ3N1YmplY3QnLFxuICAnc3Vic2NyaXB0aW9ucycsXG4gICdzdWJ0aXRsZXMnLFxuICAnc3Vid2F5JyxcbiAgJ3N1cGVydmlzb3JfYWNjb3VudCcsXG4gICdzdXJyb3VuZF9zb3VuZCcsXG4gICdzd2FwX2NhbGxzJyxcbiAgJ3N3YXBfaG9yaXonLFxuICAnc3dhcF92ZXJ0JyxcbiAgJ3N3YXBfdmVydGljYWxfY2lyY2xlJyxcbiAgJ3N3aXRjaF9jYW1lcmEnLFxuICAnc3dpdGNoX3ZpZGVvJyxcbiAgJ3N5bmMnLFxuICAnc3luY19kaXNhYmxlZCcsXG4gICdzeW5jX3Byb2JsZW0nLFxuICAnc3lzdGVtX3VwZGF0ZScsXG4gICdzeXN0ZW1fdXBkYXRlX2FsdCcsXG4gICd0YWInLFxuICAndGFiX3Vuc2VsZWN0ZWQnLFxuICAndGFibGV0JyxcbiAgJ3RhYmxldF9hbmRyb2lkJyxcbiAgJ3RhYmxldF9tYWMnLFxuICAndGFnX2ZhY2VzJyxcbiAgJ3RhcF9hbmRfcGxheScsXG4gICd0ZXJyYWluJyxcbiAgJ3RleHRfZmllbGRzJyxcbiAgJ3RleHRfZm9ybWF0JyxcbiAgJ3RleHRzbXMnLFxuICAndGV4dHVyZScsXG4gICd0aGVhdGVycycsXG4gICd0aHVtYl9kb3duJyxcbiAgJ3RodW1iX3VwJyxcbiAgJ3RodW1ic191cF9kb3duJyxcbiAgJ3RpbWVfdG9fbGVhdmUnLFxuICAndGltZWxhcHNlJyxcbiAgJ3RpbWVsaW5lJyxcbiAgJ3RpbWVyJyxcbiAgJ3RpbWVyXzEwJyxcbiAgJ3RpbWVyXzMnLFxuICAndGltZXJfb2ZmJyxcbiAgJ3RpdGxlJyxcbiAgJ3RvYycsXG4gICd0b2RheScsXG4gICd0b2xsJyxcbiAgJ3RvbmFsaXR5JyxcbiAgJ3RvdWNoX2FwcCcsXG4gICd0b3lzJyxcbiAgJ3RyYWNrX2NoYW5nZXMnLFxuICAndHJhaW4nLFxuICAndHJhbScsXG4gICd0cmFuc2Zlcl93aXRoaW5fYV9zdGF0aW9uJyxcbiAgJ3RyYW5zZm9ybScsXG4gICd0cmFuc2xhdGUnLFxuICAndHJlbmRpbmdfZG93bicsXG4gICd0cmVuZGluZ19mbGF0JyxcbiAgJ3RyZW5kaW5nX3VwJyxcbiAgJ3R1bmUnLFxuICAndHVybmVkX2luJyxcbiAgJ3R1cm5lZF9pbl9ub3QnLFxuICAndHYnLFxuICAndW5hcmNoaXZlJyxcbiAgJ3VuZG8nLFxuICAndW5mb2xkX2xlc3MnLFxuICAndW5mb2xkX21vcmUnLFxuICAndXBkYXRlJyxcbiAgJ3VzYicsXG4gICd2ZXJpZmllZF91c2VyJyxcbiAgJ3ZlcnRpY2FsX2FsaWduX2JvdHRvbScsXG4gICd2ZXJ0aWNhbF9hbGlnbl9jZW50ZXInLFxuICAndmVydGljYWxfYWxpZ25fdG9wJyxcbiAgJ3ZpYnJhdGlvbicsXG4gICd2aWRlb19jYWxsJyxcbiAgJ3ZpZGVvX2xhYmVsJyxcbiAgJ3ZpZGVvX2xpYnJhcnknLFxuICAndmlkZW9jYW0nLFxuICAndmlkZW9jYW1fb2ZmJyxcbiAgJ3ZpZGVvZ2FtZV9hc3NldCcsXG4gICd2aWV3X2FnZW5kYScsXG4gICd2aWV3X2FycmF5JyxcbiAgJ3ZpZXdfY2Fyb3VzZWwnLFxuICAndmlld19jb2x1bW4nLFxuICAndmlld19jb21meScsXG4gICd2aWV3X2NvbXBhY3QnLFxuICAndmlld19kYXknLFxuICAndmlld19oZWFkbGluZScsXG4gICd2aWV3X2xpc3QnLFxuICAndmlld19tb2R1bGUnLFxuICAndmlld19xdWlsdCcsXG4gICd2aWV3X3N0cmVhbScsXG4gICd2aWV3X3dlZWsnLFxuICAndmlnbmV0dGUnLFxuICAndmlzaWJpbGl0eScsXG4gICd2aXNpYmlsaXR5X29mZicsXG4gICd2b2ljZV9jaGF0JyxcbiAgJ3ZvaWNlbWFpbCcsXG4gICd2b2x1bWVfZG93bicsXG4gICd2b2x1bWVfbXV0ZScsXG4gICd2b2x1bWVfb2ZmJyxcbiAgJ3ZvbHVtZV91cCcsXG4gICd2cG5fa2V5JyxcbiAgJ3Zwbl9sb2NrJyxcbiAgJ3dhbGxwYXBlcicsXG4gICd3YXJuaW5nJyxcbiAgJ3dhdGNoJyxcbiAgJ3dhdGNoX2xhdGVyJyxcbiAgJ3diX2F1dG8nLFxuICAnd2JfY2xvdWR5JyxcbiAgJ3diX2luY2FuZGVzY2VudCcsXG4gICd3Yl9pcmlkZXNjZW50JyxcbiAgJ3diX3N1bm55JyxcbiAgJ3djJyxcbiAgJ3dlYicsXG4gICd3ZWJfYXNzZXQnLFxuICAnd2Vla2VuZCcsXG4gICd3aGF0c2hvdCcsXG4gICd3aWRnZXRzJyxcbiAgJ3dpZmknLFxuICAnd2lmaV9sb2NrJyxcbiAgJ3dpZmlfdGV0aGVyaW5nJyxcbiAgJ3dvcmsnLFxuICAnd3JhcF90ZXh0JyxcbiAgJ3lvdXR1YmVfc2VhcmNoZWRfZm9yJyxcbiAgJ3pvb21faW4nLFxuICAnem9vbV9vdXQnLFxuICAnem9vbV9vdXRfbWFwJyxcbl07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtkZWZhdWx0IGFzIFdlYkZvbnR9IGZyb20gJ3dlYmZvbnRsb2FkZXInO1xuXG5pbXBvcnQge0Zvcm19IGZyb20gJy4vRm9ybSc7XG5pbXBvcnQge0ZpZWxkfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7VGV4dEZpZWxkfSBmcm9tICcuL1RleHRGaWVsZCc7XG5pbXBvcnQge1JhbmdlRmllbGR9IGZyb20gJy4vUmFuZ2VGaWVsZCc7XG5pbXBvcnQge0Jvb2xlYW5GaWVsZH0gZnJvbSAnLi9Cb29sZWFuRmllbGQnO1xuaW1wb3J0IHtFbnVtRmllbGR9IGZyb20gJy4vRW51bUZpZWxkJztcblxuaW1wb3J0IHtVdGlsfSBmcm9tICcuLi9VdGlsJztcblxuaW1wb3J0IHtpbWFnZWxpYn0gZnJvbSAnLi4vLi4vaW1hZ2VsaWInO1xuXG5pbXBvcnQge0NMSVBBUlRfTkFNRVN9IGZyb20gJy4vSW1hZ2VGaWVsZC1jbGlwYXJ0JztcblxuXG5jb25zdCBXRUJfRk9OVFNfQVBJX0tFWSA9ICdBSXphU3lBdFNlOHdsWFBDVWFMUTRMVHlQS3BiekJCUEpBekVYbVUnO1xuY29uc3QgV0VCX0ZPTlRTX0FQSV9VUkwgPSBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vd2ViZm9udHMvdjEvd2ViZm9udHM/a2V5PSR7V0VCX0ZPTlRTX0FQSV9LRVl9JmZpZWxkcz1pdGVtcyhmYW1pbHkpYDtcbmNvbnN0IFdFQl9GT05UU19DQUNIRV9USU1FID0gNjAgKiA2MCAqIDEwMDA7IC8vIDEgaG91clxuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZvcm0gZmllbGQgZm9yIGltYWdlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEltYWdlRmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gIGNvbnN0cnVjdG9yKGlkLCBwYXJhbXMpIHtcbiAgICBzdXBlcihpZCwgcGFyYW1zKTtcbiAgICB0aGlzLnZhbHVlVHlwZV8gPSBudWxsO1xuICAgIHRoaXMudGV4dFBhcmFtc18gPSB7fTtcbiAgICB0aGlzLmltYWdlUGFyYW1zXyA9IHt9O1xuICAgIHRoaXMuY2xpcGFydFNyY18gPSBudWxsO1xuICAgIHRoaXMubGFzdE5vdGlmaWVkVmFsdWVfID0ge307XG4gICAgdGhpcy5zcGFjZUZvcm1WYWx1ZXNfID0ge307IC8vIGNhY2hlXG4gIH1cblxuICBjcmVhdGVVaShjb250YWluZXIpIHtcbiAgICB2YXIgZmllbGRVSSA9IHN1cGVyLmNyZWF0ZVVpKGNvbnRhaW5lcik7XG4gICAgdmFyIGZpZWxkQ29udGFpbmVyID0gJCgnLmZvcm0tZmllbGQtY29udGFpbmVyJywgZmllbGRVSSk7XG5cbiAgICAvLyBTZXQgdXAgZHJhZytkcm9wIG9uIHRoZSBlbnRpcmUgZmllbGQgY29udGFpbmVyXG4gICAgZmllbGRVSS5hZGRDbGFzcygnZm9ybS1maWVsZC1pbWFnZScpO1xuICAgIHRoaXMuc2V0dXBEcm9wVGFyZ2V0XyhmaWVsZFVJKTtcblxuICAgIC8vIENyZWF0ZSByYWRpbyBidXR0b25zXG4gICAgdGhpcy5lbF8gPSAkKCc8ZGl2PicpXG4gICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1idXR0b25zZXQnKVxuICAgICAgICAuYXBwZW5kVG8oZmllbGRDb250YWluZXIpO1xuXG4gICAgdmFyIHR5cGVzO1xuICAgIGlmICh0aGlzLnBhcmFtc18uaW1hZ2VPbmx5KSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgWydpbWFnZScsICdTZWxlY3QgaW1hZ2UnXVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgIFsnaW1hZ2UnLCAnSW1hZ2UnXSxcbiAgICAgICAgWydjbGlwYXJ0JywgJ0NsaXBhcnQnXSxcbiAgICAgICAgWyd0ZXh0JywgJ1RleHQnXVxuICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZUVscyA9IHt9O1xuXG4gICAgdHlwZXMuZm9yRWFjaCgoW2lkLCBsYWJlbF0pID0+IHtcbiAgICAgICQoJzxpbnB1dD4nKVxuICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmdldEh0bWxJZCgpLFxuICAgICAgICAgICAgaWQ6IGAke3RoaXMuZ2V0SHRtbElkKCl9LSR7aWR9YCxcbiAgICAgICAgICAgIHZhbHVlOiBpZFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcbiAgICAgIHR5cGVFbHNbaWRdID0gJCgnPGxhYmVsPicpXG4gICAgICAgICAgLmF0dHIoJ2ZvcicsIGAke3RoaXMuZ2V0SHRtbElkKCl9LSR7aWR9YClcbiAgICAgICAgICAuYXR0cigndGFiaW5kZXgnLCAwKVxuICAgICAgICAgIC50ZXh0KGxhYmVsKVxuICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsXyk7XG4gICAgfSk7XG5cbiAgICAvLyBQcmVwYXJlIFVJIGZvciB0aGUgJ2ltYWdlJyB0eXBlXG4gICAgdGhpcy5maWxlRWxfID0gJCgnPGlucHV0PicpXG4gICAgICAgIC5hZGRDbGFzcygnZm9ybS1pbWFnZS1oaWRkZW4tZmlsZS1maWVsZCcpXG4gICAgICAgIC5hdHRyKHtcbiAgICAgICAgICBpZDogdGhpcy5nZXRIdG1sSWQoKSxcbiAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgYWNjZXB0OiAnaW1hZ2UvKidcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdjaGFuZ2UnLCAoKSA9PiB0aGlzLmxvYWRJbWFnZV8odGhpcy5maWxlRWxfLmdldCgwKS5maWxlcykpXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsXyk7XG5cbiAgICB0eXBlRWxzLmltYWdlLmNsaWNrKGV2dCA9PiB7XG4gICAgICB0aGlzLmZpbGVFbF8udHJpZ2dlcignY2xpY2snKTtcbiAgICAgIHRoaXMuc2V0VmFsdWVUeXBlXyhudWxsKTtcbiAgICAgIHRoaXMucmVuZGVyVmFsdWVBbmROb3RpZnlDaGFuZ2VkXygpO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBQcmVwYXJlIFVJIGZvciB0aGUgJ2NsaXBhcnQnIHR5cGVcbiAgICBpZiAoIXRoaXMucGFyYW1zXy5pbWFnZU9ubHkpIHtcbiAgICAgIGxldCBjbGlwYXJ0UGFyYW1zRWwgPSAkKCc8ZGl2PicpXG4gICAgICAgICAgLmFkZENsYXNzKCdmb3JtLWltYWdlLXR5cGUtcGFyYW1zIGZvcm0taW1hZ2UtdHlwZS1wYXJhbXMtY2xpcGFydCBpcy1oaWRkZW4nKVxuICAgICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICAgIGxldCBjbGlwYXJ0TGlzdEVsID0gJCgnPGRpdj4nKVxuICAgICAgICAgIC5hZGRDbGFzcygnZm9ybS1pbWFnZS1jbGlwYXJ0LWxpc3QnKVxuICAgICAgICAgIC5hZGRDbGFzcygnY2FuY2VsLXBhcmVudC1zY3JvbGwnKVxuICAgICAgICAgIC5hcHBlbmRUbyhjbGlwYXJ0UGFyYW1zRWwpO1xuXG4gICAgICBDTElQQVJUX05BTUVTLmZvckVhY2goY2xpcGFydFNyYyA9PiB7XG4gICAgICAgICQoJzxkaXY+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnZm9ybS1pbWFnZS1jbGlwYXJ0LWl0ZW0nKVxuICAgICAgICAgICAgLmF0dHIoJ2RhdGEtbmFtZScsIGNsaXBhcnRTcmMpXG4gICAgICAgICAgICAuYXR0cigndGl0bGUnLCBjbGlwYXJ0U3JjKVxuICAgICAgICAgICAgLnRleHQoY2xpcGFydFNyYylcbiAgICAgICAgICAgIC5jbGljaygoKSA9PiB0aGlzLmxvYWRDbGlwYXJ0XyhjbGlwYXJ0U3JjKSlcbiAgICAgICAgICAgIC5hcHBlbmRUbyhjbGlwYXJ0TGlzdEVsKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRjbGlwYXJ0SXRlbXMgPSBjbGlwYXJ0TGlzdEVsLmZpbmQoJy5mb3JtLWltYWdlLWNsaXBhcnQtaXRlbScpO1xuXG4gICAgICBsZXQgY2xpcGFydEZpbHRlckVsID0gJCgnPGlucHV0PicpXG4gICAgICAgIC5hZGRDbGFzcygnZm9ybS1pbWFnZS1jbGlwYXJ0LWZpbHRlcicpXG4gICAgICAgIC5hdHRyKCdwbGFjZWhvbGRlcicsICdGaW5kIGNsaXBhcnQnKVxuICAgICAgICAub24oJ2lucHV0JywgZXYgPT4ge1xuICAgICAgICAgIGxldCAkZmlsdGVyID0gJChldi5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICBsZXQgdmFsID0gJGZpbHRlci52YWwoKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teXFx3XSsvZywgJycpO1xuICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICB0aGlzLiRjbGlwYXJ0SXRlbXMuc2hvdygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjbGlwYXJ0SXRlbXMuZWFjaCgoXywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAkKGl0ZW0pLnRvZ2dsZSgkKGl0ZW0pLmF0dHIoJ3RpdGxlJykuaW5kZXhPZih2YWwpID49IDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucHJlcGVuZFRvKGNsaXBhcnRQYXJhbXNFbCk7XG5cbiAgICAgIHZhciBjbGlwYXJ0QXR0cmlidXRpb25FbCA9ICQoJzxkaXY+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0taW1hZ2UtY2xpcGFydC1hdHRyaWJ1dGlvbicpXG4gICAgICAgICAgLmh0bWwoYFxuICAgICAgICAgICAgICBGb3IgY2xpcGFydCBzb3VyY2VzLCB2aXNpdFxuICAgICAgICAgICAgICA8YSB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICBjbGFzcz1cImV4dGVybmFsLWxpbmtcIlxuICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9tYXRlcmlhbC1kZXNpZ24taWNvbnNcIj5cbiAgICAgICAgICAgICAgTWF0ZXJpYWwgRGVzaWduIEljb25zIG9uIEdpdEh1YjwvYT5cbiAgICAgICAgICAgICAgYClcbiAgICAgICAgICAuYXBwZW5kVG8oY2xpcGFydFBhcmFtc0VsKTtcblxuICAgICAgdHlwZUVscy5jbGlwYXJ0LmNsaWNrKGV2dCA9PiB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWVUeXBlXygnY2xpcGFydCcpO1xuICAgICAgICB0aGlzLnJlbmRlclZhbHVlQW5kTm90aWZ5Q2hhbmdlZF8oKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcmVwYXJlIFVJIGZvciB0aGUgJ3RleHQnIHR5cGVcbiAgICAgIHZhciB0ZXh0UGFyYW1zRWwgPSAkKCc8ZGl2PicpXG4gICAgICAgICAgLmFkZENsYXNzKCdmb3JtLXN1YmZvcm0gZm9ybS1pbWFnZS10eXBlLXBhcmFtcyBmb3JtLWltYWdlLXR5cGUtcGFyYW1zLXRleHQgaXMtaGlkZGVuJylcbiAgICAgICAgICAuYXBwZW5kVG8oZmllbGRDb250YWluZXIpO1xuXG4gICAgICBsZXQgZm9udEZhbWlseUZpZWxkO1xuICAgICAgdGhpcy50ZXh0Rm9ybV8gPSBuZXcgRm9ybSh7XG4gICAgICAgIGlkOiBgJHt0aGlzLmZvcm1fLmlkX30tJHt0aGlzLmlkX30tdGV4dGZvcm1gLFxuICAgICAgICBjb250YWluZXI6IHRleHRQYXJhbXNFbCxcbiAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgbmV3IFRleHRGaWVsZCgndGV4dCcsIHtcbiAgICAgICAgICAgIHRpdGxlOiAnVGV4dCcsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKGZvbnRGYW1pbHlGaWVsZCA9IG5ldyBFbnVtRmllbGQoJ2ZvbnQnLCB7XG4gICAgICAgICAgICB0aXRsZTogJ0ZvbnQnLFxuICAgICAgICAgICAgaGVscFRleHQ6ICdGcm9tIGZvbnRzLmdvb2dsZS5jb20nXG4gICAgICAgICAgfSkpXG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2FkR29vZ2xlV2ViRm9udHNMaXN0XygpLnRoZW4oZm9udHMgPT4gZm9udEZhbWlseUZpZWxkLnNldE9wdGlvbnMoWycnXS5jb25jYXQoZm9udHMpKSk7XG5cbiAgICAgIGxldCB0cnlMb2FkV2ViRm9udERlYm91bmNlZF8gPSBVdGlsLmRlYm91bmNlKDUwMCwgKCkgPT4gdGhpcy50cnlMb2FkV2ViRm9udF8oKSk7XG4gICAgICB0aGlzLnRleHRGb3JtXy5vbkNoYW5nZSgoKSA9PiB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnRleHRGb3JtXy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy50ZXh0UGFyYW1zXy50ZXh0ID0gdmFsdWVzLnRleHQ7XG4gICAgICAgIHRoaXMudGV4dFBhcmFtc18uZm9udFN0YWNrID0gdmFsdWVzLmZvbnQgfHwgJ1JvYm90bywgc2Fucy1zZXJpZic7XG4gICAgICAgIHRyeUxvYWRXZWJGb250RGVib3VuY2VkXygpO1xuICAgICAgICB0aGlzLnJlbmRlclZhbHVlQW5kTm90aWZ5Q2hhbmdlZF8oKTtcbiAgICAgIH0pO1xuXG4gICAgICB0eXBlRWxzLnRleHQuY2xpY2soZXZ0ID0+IHtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZVR5cGVfKCd0ZXh0Jyk7XG4gICAgICAgIHRoaXMucmVuZGVyVmFsdWVBbmROb3RpZnlDaGFuZ2VkXygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHNwYWNpbmcgc3ViZm9ybVxuICAgIGlmICghdGhpcy5wYXJhbXNfLm5vVHJpbUZvcm0pIHtcbiAgICAgIGxldCBzcGFjZUZvcm1Db250YWluZXIgPSAkKCc8ZGl2PicpXG4gICAgICAgICAgLmFkZENsYXNzKCdmb3JtLXN1YmZvcm0nKVxuICAgICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG4gICAgICB0aGlzLnNwYWNlRm9ybVZhbHVlc18gPSB7fTtcbiAgICAgIHRoaXMuc3BhY2VGb3JtXyA9IG5ldyBGb3JtKHtcbiAgICAgICAgaWQ6IGAke3RoaXMuZm9ybV8uaWRffS0ke3RoaXMuaWRffS1zcGFjZWZvcm1gLFxuICAgICAgICBjb250YWluZXI6IHNwYWNlRm9ybUNvbnRhaW5lcixcbiAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgKHRoaXMuc3BhY2VGb3JtVHJpbUZpZWxkXyA9IG5ldyBCb29sZWFuRmllbGQoJ3RyaW0nLCB7XG4gICAgICAgICAgICB0aXRsZTogJ1RyaW0gd2hpdGVzcGFjZScsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICBvZmZUZXh0OiBgRG9uJ3QgdHJpbWAsXG4gICAgICAgICAgICBvblRleHQ6ICdUcmltJ1xuICAgICAgICAgIH0pKSxcbiAgICAgICAgICAodGhpcy5zcGFjZUZvcm1QYWRkaW5nRmllbGRfID0gbmV3IFJhbmdlRmllbGQoJ3BhZCcsIHtcbiAgICAgICAgICAgIHRpdGxlOiAnUGFkZGluZycsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWVQYWRkaW5nIHx8IDAsXG4gICAgICAgICAgICBtaW46IC0wLjEsXG4gICAgICAgICAgICBtYXg6IDAuNSwgLy8gMS8yIG9mIG1pbih3aWR0aCwgaGVpZ2h0KVxuICAgICAgICAgICAgc3RlcDogMC4wMSxcbiAgICAgICAgICAgIHRleHRGbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiAodiAqIDEwMCkudG9GaXhlZCgwKSArICclJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSksXG4gICAgICAgICAgKHRoaXMuc3BhY2VGb3JtVG9wRmllbGRfID0gbmV3IFJhbmdlRmllbGQoJ3RvcCcsIHtcbiAgICAgICAgICAgIHRpdGxlOiAnVG9wIGFkanVzdG1lbnQgKDAgPSB2ZXJ0aWNhbGx5IGFsaWduZWQpJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGhpcy5wYXJhbXNfLmRlZmF1bHRWYWx1ZVRvcCB8fCAwLFxuICAgICAgICAgICAgbWluOiAtMC41LFxuICAgICAgICAgICAgbWF4OiAwLjUsIC8vIDEvMiBvZiBtaW4od2lkdGgsIGhlaWdodClcbiAgICAgICAgICAgIHN0ZXA6IDAuMDEsXG4gICAgICAgICAgICB0ZXh0Rm4odikge1xuICAgICAgICAgICAgICByZXR1cm4gKHYgKiAxMDApLnRvRml4ZWQoMCkgKyAnJSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpLFxuICAgICAgICAgICh0aGlzLnNwYWNlRm9ybUxlZnRGaWVsZF8gPSBuZXcgUmFuZ2VGaWVsZCgnbGVmdCcsIHtcbiAgICAgICAgICAgIHRpdGxlOiAnTGVmdCBhZGp1c3RtZW50ICgwID0gaG9yaXpvbnRhbGx5IGFsaWduZWQpJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGhpcy5wYXJhbXNfLmRlZmF1bHRWYWx1ZUxlZnQgfHwgMCxcbiAgICAgICAgICAgIG1pbjogLTAuNSxcbiAgICAgICAgICAgIG1heDogMC41LCAvLyAxLzIgb2YgbWluKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgICAgICBzdGVwOiAwLjAxLFxuICAgICAgICAgICAgdGV4dEZuKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh2ICogMTAwKS50b0ZpeGVkKDApICsgJyUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSxcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNwYWNlRm9ybV8ub25DaGFuZ2UoKCkgPT4ge1xuICAgICAgICB0aGlzLnNwYWNlRm9ybVZhbHVlc18gPSB0aGlzLnNwYWNlRm9ybV8uZ2V0VmFsdWVzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyVmFsdWVBbmROb3RpZnlDaGFuZ2VkXygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNwYWNlRm9ybVZhbHVlc18gPSB0aGlzLnNwYWNlRm9ybV8uZ2V0VmFsdWVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3BhY2VGb3JtVmFsdWVzXyA9IHt9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBpbWFnZSBwcmV2aWV3IGVsZW1lbnRcbiAgICBpZiAoIXRoaXMucGFyYW1zXy5ub1ByZXZpZXcpIHtcbiAgICAgIHRoaXMuaW1hZ2VQcmV2aWV3XyA9ICQoJzxjYW52YXM+JylcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0taW1hZ2UtcHJldmlldycpXG4gICAgICAgICAgLmhpZGUoKVxuICAgICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lci5wYXJlbnQoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWVDbGlwYXJ0KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlVHlwZV8pIHtcbiAgICAgICAgICB0aGlzLmxvYWRDbGlwYXJ0Xyh0aGlzLnBhcmFtc18uZGVmYXVsdFZhbHVlQ2xpcGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwRHJvcFRhcmdldF8oZWwpIHtcbiAgICBsZXQgJGVsID0gdGhpcy5wYXJhbXNfLmRyb3BUYXJnZXRcbiAgICAgICAgPyAkKHRoaXMucGFyYW1zXy5kcm9wVGFyZ2V0KVxuICAgICAgICA6ICQoZWwpO1xuICAgIGxldCBlbnRlckxlYXZlVGltZW91dDtcblxuICAgICRlbFxuICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0tZmllbGQtZHJvcC10YXJnZXQnKVxuICAgICAgICAub24oJ2RyYWdlbnRlcicsIGV2ID0+IHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmIChlbnRlckxlYXZlVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVudGVyTGVhdmVUaW1lb3V0KTtcbiAgICAgICAgICAgIGVudGVyTGVhdmVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgJGVsLmFkZENsYXNzKCdkcmFnLWhvdmVyJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2xlYXZlJywgZXYgPT4ge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKGVudGVyTGVhdmVUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZW50ZXJMZWF2ZVRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnRlckxlYXZlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gJGVsLnJlbW92ZUNsYXNzKCdkcmFnLWhvdmVyJyksIDEwMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ292ZXInLCBldiA9PiB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoZW50ZXJMZWF2ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlbnRlckxlYXZlVGltZW91dCk7XG4gICAgICAgICAgICBlbnRlckxlYXZlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJvcCcsIGV2ID0+IHtcbiAgICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoJ2RyYWctaG92ZXInKTtcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMubG9hZEltYWdlXyhldi5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgIH0pO1xuICB9XG5cbiAgbG9hZEltYWdlXyhmaWxlTGlzdCkge1xuICAgIEltYWdlRmllbGQubG9hZEltYWdlRnJvbUZpbGVMaXN0KGZpbGVMaXN0KS50aGVuKHJldCA9PiB7XG4gICAgICBpZiAoIXJldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0VmFsdWVUeXBlXygnaW1hZ2UnKTtcbiAgICAgIHRoaXMuaW1hZ2VQYXJhbXNfID0gcmV0O1xuICAgICAgdGhpcy5pbWFnZUZpbGVuYW1lXyA9IHJldC5uYW1lLnJlcGxhY2UoL1xcLlteLl0rPyQvLCAnJyk7IC8vIGJhc2VuYW1lXG4gICAgICB0aGlzLnJlbmRlclZhbHVlQW5kTm90aWZ5Q2hhbmdlZF8oKTtcbiAgICB9KTtcbiAgfVxuXG4gIGxvYWRHb29nbGVXZWJGb250c0xpc3RfKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoJ2Fzc2V0U3R1ZGlvV2ViRm9udHNDYWNoZScgaW4gbG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIGxldCB7ZmV0Y2hUaW1lLCBmb250c30gPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5hc3NldFN0dWRpb1dlYkZvbnRzQ2FjaGUpO1xuICAgICAgICBpZiAoTnVtYmVyKG5ldyBEYXRlKCkpIC0gZmV0Y2hUaW1lIDwgV0VCX0ZPTlRTX0NBQ0hFX1RJTUUpIHtcbiAgICAgICAgICAvLyB1c2UgY2FjaGVcbiAgICAgICAgICByZXNvbHZlKGZvbnRzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJC5hamF4KHtcbiAgICAgICAgdXJsOiBXRUJfRk9OVFNfQVBJX1VSTCxcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgbGV0IGZvbnRzID0gZGF0YS5pdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmZhbWlseSk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5hc3NldFN0dWRpb1dlYkZvbnRzQ2FjaGUgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZmV0Y2hUaW1lOiBOdW1iZXIobmV3IERhdGUoKSksXG4gICAgICAgICAgZm9udHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc29sdmUoZm9udHMpO1xuICAgICAgfSwgZSA9PiByZWplY3QoZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5TG9hZFdlYkZvbnRfKCkge1xuICAgIGxldCBkZXNpcmVkRm9udCA9IHRoaXMudGV4dEZvcm1fLmdldFZhbHVlcygpLmZvbnQ7XG4gICAgaWYgKHRoaXMubG9hZGVkV2ViRm9udF8gPT0gZGVzaXJlZEZvbnQgfHwgIWRlc2lyZWRGb250KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgV2ViRm9udC5sb2FkKHtcbiAgICAgIGdvb2dsZToge1xuICAgICAgICBmYW1pbGllczogW2Rlc2lyZWRGb250XVxuICAgICAgfSxcbiAgICAgIGFjdGl2ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmxvYWRlZFdlYkZvbnRfID0gZGVzaXJlZEZvbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyVmFsdWVBbmROb3RpZnlDaGFuZ2VkXygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VmFsdWVUeXBlXyh0eXBlKSB7XG4gICAgdGhpcy52YWx1ZVR5cGVfID0gdHlwZTtcbiAgICAkKCdpbnB1dCcsIHRoaXMuZWxfKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuICAgICQoJy5mb3JtLWltYWdlLXR5cGUtcGFyYW1zJywgdGhpcy5lbF8ucGFyZW50KCkpLmFkZENsYXNzKCdpcy1oaWRkZW4nKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgJChgIyR7dGhpcy5nZXRIdG1sSWQoKX0tJHt0eXBlfWApLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICAgICQoJy5mb3JtLWltYWdlLXR5cGUtcGFyYW1zLScgKyB0eXBlLCB0aGlzLmVsXy5wYXJlbnQoKSkucmVtb3ZlQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNwYWNlRm9ybV8pIHtcbiAgICAgIHRoaXMuc3BhY2VGb3JtVHJpbUZpZWxkXy5zZXRFbmFibGVkKHRydWUpO1xuICAgICAgdGhpcy5zcGFjZUZvcm1QYWRkaW5nRmllbGRfLnNldEVuYWJsZWQodHJ1ZSk7XG4gICAgICB0aGlzLnNwYWNlRm9ybVRvcEZpZWxkXy5zZXRFbmFibGVkKHRydWUpO1xuICAgICAgdGhpcy5zcGFjZUZvcm1MZWZ0RmllbGRfLnNldEVuYWJsZWQodHJ1ZSk7XG4gICAgICBpZiAodHlwZSA9PSAnY2xpcGFydCcpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zXy5jbGlwYXJ0Tm9UcmltUGFkZGluZykge1xuICAgICAgICAgIHRoaXMuc3BhY2VGb3JtVHJpbUZpZWxkXy5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLnNwYWNlRm9ybVRyaW1GaWVsZF8uc2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIHRoaXMuc3BhY2VGb3JtUGFkZGluZ0ZpZWxkXy5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLnNwYWNlRm9ybVBhZGRpbmdGaWVsZF8uc2V0VmFsdWUoMCk7XG4gICAgICAgICAgdGhpcy5zcGFjZUZvcm1Ub3BGaWVsZF8uc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgdGhpcy5zcGFjZUZvcm1Ub3BGaWVsZF8uc2V0VmFsdWUoMCk7XG4gICAgICAgICAgdGhpcy5zcGFjZUZvcm1MZWZ0RmllbGRfLnNldEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICAgIHRoaXMuc3BhY2VGb3JtTGVmdEZpZWxkXy5zZXRWYWx1ZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09ICd0ZXh0Jykge1xuICAgICAgICB0aGlzLnNwYWNlRm9ybVRyaW1GaWVsZF8uc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgICAgIHRoaXMuc3BhY2VGb3JtVHJpbUZpZWxkXy5zZXRWYWx1ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkQ2xpcGFydF8oY2xpcGFydFNyYykge1xuICAgIHRoaXMuJGNsaXBhcnRJdGVtcy5yZW1vdmVDbGFzcygnaXMtc2VsZWN0ZWQnKTtcbiAgICB0aGlzLiRjbGlwYXJ0SXRlbXMuZmlsdGVyKGBbZGF0YS1uYW1lPVwiJHtjbGlwYXJ0U3JjfVwiXWApLmFkZENsYXNzKCdpcy1zZWxlY3RlZCcpO1xuXG4gICAgdGhpcy5zZXRWYWx1ZVR5cGVfKCdjbGlwYXJ0Jyk7XG4gICAgdGhpcy5jbGlwYXJ0U3JjXyA9IGNsaXBhcnRTcmM7XG4gICAgdGhpcy5yZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCk7XG4gIH1cblxuICBjbGVhclZhbHVlKCkge1xuICAgIHRoaXMudmFsdWVUeXBlXyA9IG51bGw7XG4gICAgdGhpcy52YWx1ZUN0eF8gPSBudWxsO1xuICAgIHRoaXMudmFsdWVPcmlnSW1nXyA9IG51bGw7XG4gICAgdGhpcy5maWxlRWxfLnZhbCgnJyk7XG4gICAgaWYgKHRoaXMuaW1hZ2VQcmV2aWV3Xykge1xuICAgICAgdGhpcy5pbWFnZVByZXZpZXdfLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgc3dpdGNoICh0aGlzLnZhbHVlVHlwZV8pIHtcbiAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgbmFtZSA9IHRoaXMuaW1hZ2VGaWxlbmFtZV87XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjbGlwYXJ0JzpcbiAgICAgICAgbmFtZSA9IHRoaXMuY2xpcGFydFNyY187XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgbmFtZSA9IHRoaXMudGV4dFBhcmFtc18udGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN0eDogdGhpcy52YWx1ZUN0eF8sXG4gICAgICBvcmlnSW1nOiB0aGlzLnZhbHVlT3JpZ0ltZ18sXG4gICAgICB0eXBlOiB0aGlzLnZhbHVlVHlwZV8sXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxuXG4gIG5vdGlmeUNoYW5nZWRfKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHN1cGVyLm5vdGlmeUNoYW5nZWRfKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgdGhpcy5sYXN0Tm90aWZpZWRWYWx1ZV8gPSBPYmplY3QuYXNzaWduKHt9LCBuZXdWYWx1ZSk7XG4gIH1cblxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGFzeW5jaHJvbm91c1xuICByZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCkge1xuICAgIGlmICghdGhpcy52YWx1ZVR5cGVfKSB7XG4gICAgICB0aGlzLnZhbHVlQ3R4XyA9IG51bGw7XG4gICAgICB0aGlzLnZhbHVlT3JpZ0ltZ18gPSBudWxsO1xuICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VkXyh0aGlzLmdldFZhbHVlKCksIHRoaXMubGFzdE5vdGlmaWVkVmFsdWVfKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJUaW1lb3V0Xykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVuZGVyVGltZW91dF8pO1xuICAgICAgdGhpcy5yZW5kZXJUaW1lb3V0XyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyaW5nXykge1xuICAgICAgdGhpcy5yZW5kZXJUaW1lb3V0XyA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdGhpcy5yZW5kZXJWYWx1ZUFuZE5vdGlmeUNoYW5nZWRfKCksXG4gICAgICAgICAgMTAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmluZ18gPSB0cnVlO1xuXG4gICAgdGhpcy5yZW5kZXJTb3VyY2VfKClcbiAgICAgICAgLnRoZW4oKHtjdHgsIHNpemV9KSA9PiB7XG4gICAgICAgICAgdGhpcy5jb21wdXRlVHJpbVJlY3RfKGN0eCwgc2l6ZSlcbiAgICAgICAgICAgICAgLnRoZW4odHJpbVJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwYWQgPSB0aGlzLnNwYWNlRm9ybVZhbHVlc18ucGFkIHx8IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhZFB4ID0gTWF0aC5yb3VuZChwYWQgKiBNYXRoLm1pbih0cmltUmVjdC53LCB0cmltUmVjdC5oKSk7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnNwYWNlRm9ybVZhbHVlc18ubGVmdCB8fCAwO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0UHggPSBNYXRoLnJvdW5kKGxlZnQgKiBNYXRoLm1pbih0cmltUmVjdC53LCB0cmltUmVjdC5oKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuc3BhY2VGb3JtVmFsdWVzXy50b3AgfHwgMDtcbiAgICAgICAgICAgICAgICBsZXQgdG9wUHggPSBNYXRoLnJvdW5kKHRvcCAqIE1hdGgubWluKHRyaW1SZWN0LncsIHRyaW1SZWN0LmgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQ3R4XyA9IGltYWdlbGliLkRyYXdpbmcuY29udGV4dCh7XG4gICAgICAgICAgICAgICAgICB3OiB0cmltUmVjdC53ICsgcGFkUHggKiAyLFxuICAgICAgICAgICAgICAgICAgaDogdHJpbVJlY3QuaCArIHBhZFB4ICogMlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVDdHhfLmRyYXdJbWFnZShjdHguY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICB0cmltUmVjdC54LCB0cmltUmVjdC55LCB0cmltUmVjdC53LCB0cmltUmVjdC5oLFxuICAgICAgICAgICAgICAgICAgICBwYWRQeCArIGxlZnRQeCwgcGFkUHggKyB0b3BQeCwgdHJpbVJlY3QudywgdHJpbVJlY3QuaCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbWFnZVByZXZpZXdfKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmltYWdlUHJldmlld18uYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnZhbHVlQ3R4Xy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy52YWx1ZUN0eF8uY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGxldCBwcmV2aWV3Q3R4ID0gdGhpcy5pbWFnZVByZXZpZXdfLmdldCgwKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgcHJldmlld0N0eC5kcmF3SW1hZ2UodGhpcy52YWx1ZUN0eF8uY2FudmFzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VQcmV2aWV3Xy5zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdfID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VkXyh0aGlzLmdldFZhbHVlKCksIHRoaXMubGFzdE5vdGlmaWVkVmFsdWVfKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiAnICsgZSk7XG4gICAgICAgICAgdGhpcy5yZW5kZXJpbmdfID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VkXyh0aGlzLmdldFZhbHVlKCksIHRoaXMubGFzdE5vdGlmaWVkVmFsdWVfKTtcbiAgICAgICAgfSk7XG4gIH1cblxuICByZW5kZXJTb3VyY2VfKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGJhc2UgaW1hZ2UgKHRleHQsIGNsaXBhcnQsIG9yIGltYWdlKVxuICAgICAgc3dpdGNoICh0aGlzLnZhbHVlVHlwZV8pIHtcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgIGlmICh0aGlzLmltYWdlUGFyYW1zXy51cmkpIHtcbiAgICAgICAgICAgIFV0aWwubG9hZEltYWdlRnJvbVVyaSh0aGlzLmltYWdlUGFyYW1zXy51cmkpXG4gICAgICAgICAgICAgICAgLnRoZW4oaW1nID0+IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVPcmlnSW1nXyA9IGltZztcbiAgICAgICAgICAgICAgICAgIGxldCBvcmlnU2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdzogaW1nLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaDogaW1nLm5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdTaXplKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmltYWdlUGFyYW1zXy5pc1N2ZyAmJiB0aGlzLnBhcmFtc18ubWF4RmluYWxTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplLncgLyBzaXplLmggPiB0aGlzLnBhcmFtc18ubWF4RmluYWxTaXplLncgLyB0aGlzLnBhcmFtc18ubWF4RmluYWxTaXplLmgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzaXplLncgPSB0aGlzLnBhcmFtc18ubWF4RmluYWxTaXplLnc7XG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZS5oID0gc2l6ZS53ICogb3JpZ1NpemUuaCAvIG9yaWdTaXplLnc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZS5oID0gdGhpcy5wYXJhbXNfLm1heEZpbmFsU2l6ZS5oO1xuICAgICAgICAgICAgICAgICAgICAgIHNpemUudyA9IHNpemUuaCAqIG9yaWdTaXplLncgLyBvcmlnU2l6ZS5oO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgY3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsXG4gICAgICAgICAgICAgICAgICAgICAgMCwgMCwgb3JpZ1NpemUudywgb3JpZ1NpemUuaCxcbiAgICAgICAgICAgICAgICAgICAgICAwLCAwLCBzaXplLncsIHNpemUuaCk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHtjdHgsIHNpemV9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KCdubyB1cmknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2xpcGFydCc6XG4gICAgICAgICAgdmFyIHNpemUgPSB7IHc6IDE1MzYsIGg6IDE1MzYgfTtcbiAgICAgICAgICB2YXIgY3R4ID0gaW1hZ2VsaWIuRHJhd2luZy5jb250ZXh0KHNpemUpO1xuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5jbGlwYXJ0U3JjXztcblxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gICAgICAgICAgY3R4LmZvbnQgPSBgJHtzaXplLmh9cHgvJHtzaXplLmh9cHggJ01hdGVyaWFsIEljb25zJ2A7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgMCwgc2l6ZS5oKTtcblxuICAgICAgICAgIHJlc29sdmUoe2N0eCwgc2l6ZX0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIHZhciBzaXplID0geyB3OiA2MTQ0LCBoOiAxNTM2IH07XG4gICAgICAgICAgdmFyIHRleHRIZWlnaHQgPSBzaXplLmggKiAwLjc1O1xuICAgICAgICAgIHZhciBjdHggPSBpbWFnZWxpYi5EcmF3aW5nLmNvbnRleHQoc2l6ZSk7XG4gICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHRQYXJhbXNfLnRleHQgfHwgJyc7XG4gICAgICAgICAgdGV4dCA9ICcgJyArIHRleHQgKyAnICc7XG5cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuICAgICAgICAgIGN0eC5mb250ID0gYGJvbGQgJHt0ZXh0SGVpZ2h0fXB4LyR7c2l6ZS5ofXB4ICR7dGhpcy50ZXh0UGFyYW1zXy5mb250U3RhY2t9YDtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCB0ZXh0SGVpZ2h0KTtcbiAgICAgICAgICBzaXplLncgPSBNYXRoLmNlaWwoTWF0aC5taW4oY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoLCBzaXplLncpIHx8IHNpemUudyk7XG5cbiAgICAgICAgICByZXNvbHZlKHtjdHgsIHNpemV9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlamVjdCgnTm8gdmFsdWUgdHlwZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29tcHV0ZVRyaW1SZWN0XyhjdHgsIHNpemUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3BhY2VGb3JtVmFsdWVzXy50cmltKSB7XG4gICAgICAgIGlmICh0aGlzLnRyaW1Qcm9taXNlXyAmJiB0aGlzLnRyaW1Qcm9taXNlXy53b3JrZXIpIHtcbiAgICAgICAgICB0aGlzLnRyaW1Qcm9taXNlXy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaW1Qcm9taXNlXyA9IGltYWdlbGliLkFuYWx5c2lzLmdldFRyaW1SZWN0KGN0eCwgc2l6ZSwgMSlcbiAgICAgICAgICAgIC50aGVuKHRyaW1SZWN0ID0+IHtcbiAgICAgICAgICAgICAgbGV0IHBhZCA9IE1hdGgubWluKHNpemUudywgc2l6ZS5oKSAqIC4wMTtcbiAgICAgICAgICAgICAgLy8gcGFkIGEgbGl0dGxlIGJpdCB0byBhdm9pZCBlZGdlIGFydGlmYWN0c1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRyaW1SZWN0LCB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5mbG9vcih0cmltUmVjdC54IC0gcGFkKSwgMCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5tYXgoTWF0aC5mbG9vcih0cmltUmVjdC55IC0gcGFkKSwgMCksXG4gICAgICAgICAgICAgICAgdzogTWF0aC5jZWlsKHRyaW1SZWN0LncgKyBwYWQgKiAyKSxcbiAgICAgICAgICAgICAgICBoOiBNYXRoLmNlaWwodHJpbVJlY3QuaCArIHBhZCAqIDIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0cmltUmVjdC53ID0gTWF0aC5taW4odHJpbVJlY3Qudywgc2l6ZS53IC0gdHJpbVJlY3QueCk7XG4gICAgICAgICAgICAgIHRyaW1SZWN0LmggPSBNYXRoLm1pbih0cmltUmVjdC5oLCBzaXplLmggLSB0cmltUmVjdC55KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0cmltUmVjdCk7XG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh7IHg6IDAsIHk6IDAsIHc6IHNpemUudywgaDogc2l6ZS5oIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2VyaWFsaXplVmFsdWUoKSB7XG4gICAgbGV0IHZhbHMgPSB7XG4gICAgICB0eXBlOiB0aGlzLnZhbHVlVHlwZV8sXG4gICAgICBjbGlwYXJ0OiAodGhpcy52YWx1ZVR5cGVfID09ICdjbGlwYXJ0JykgPyB0aGlzLmNsaXBhcnRTcmNfIDogbnVsbCxcbiAgICAgIHRleHQ6ICh0aGlzLnZhbHVlVHlwZV8gPT0gJ3RleHQnKSA/IHRoaXMudGV4dEZvcm1fLmdldFZhbHVlc1NlcmlhbGl6ZWQoKSA6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc3BhY2VGb3JtXykge1xuICAgICAgdmFscy5zcGFjZSA9IHRoaXMuc3BhY2VGb3JtXy5nZXRWYWx1ZXNTZXJpYWxpemVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHM7XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKG8pIHtcbiAgICBpZiAoby50eXBlKSB7XG4gICAgICB0aGlzLnNldFZhbHVlVHlwZV8oby50eXBlKTtcbiAgICB9XG4gICAgaWYgKG8uc3BhY2UpIHtcbiAgICAgIHRoaXMuc3BhY2VGb3JtXy5zZXRWYWx1ZXNTZXJpYWxpemVkKG8uc3BhY2UpO1xuICAgICAgdGhpcy5zcGFjZUZvcm1WYWx1ZXNfID0gdGhpcy5zcGFjZUZvcm1fLmdldFZhbHVlcygpO1xuICAgIH1cbiAgICBpZiAoby5jbGlwYXJ0ICYmIHRoaXMudmFsdWVUeXBlXyA9PSAnY2xpcGFydCcpIHtcbiAgICAgIHRoaXMubG9hZENsaXBhcnRfKG8uY2xpcGFydCk7XG4gICAgfVxuICAgIGlmIChvLnRleHQgJiYgdGhpcy52YWx1ZVR5cGVfID09ICd0ZXh0Jykge1xuICAgICAgdGhpcy50ZXh0Rm9ybV8uc2V0VmFsdWVzU2VyaWFsaXplZChvLnRleHQpO1xuICAgICAgdGhpcy50cnlMb2FkV2ViRm9udF8oKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkcyB0aGUgZmlyc3QgdmFsaWQgaW1hZ2UgZnJvbSBhIEZpbGVMaXN0IChlLmcuIGRyYWcgKyBkcm9wIHNvdXJjZSksIGFzIGEgZGF0YSBVUkkuIFRoaXMgbWV0aG9kXG4gKiB3aWxsIHRocm93IGFuIGFsZXJ0KCkgaW4gY2FzZSBvZiBlcnJvcnMgYW5kIGNhbGwgYmFjayB3aXRoIG51bGwuXG4gKiBAcGFyYW0ge0ZpbGVMaXN0fSBmaWxlTGlzdCBUaGUgRmlsZUxpc3QgdG8gbG9hZC5cbiAqIEByZXR1cm4gUmV0dXJucyBhIHByb21pc2UsIHdpdGggb2JqZWN0IGNvbnRhaW5pbmcgJ3VyaScgZmllbGQgcmVwcmVzZW50aW5nXG4gKiAgICAgIHRoZSBsb2FkZWQgaW1hZ2UuIFRoZXJlIHdpbGwgYWxzbyBiZSBhICduYW1lJyBmaWVsZCBpbmRpY2F0aW5nIHRoZSBmaWxlIG5hbWUsIGlmIG9uZVxuICogICAgICBpcyBhdmFpbGFibGUuXG4gKi9cbkltYWdlRmllbGQubG9hZEltYWdlRnJvbUZpbGVMaXN0ID0gZnVuY3Rpb24oZmlsZUxpc3QpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmaWxlTGlzdCA9IGZpbGVMaXN0IHx8IFtdO1xuXG4gICAgbGV0IGZpbGUgPSBBcnJheS5mcm9tKGZpbGVMaXN0KS5maW5kKGZpbGUgPT4gSW1hZ2VGaWVsZC5pc1ZhbGlkRmlsZV8oZmlsZSkpO1xuXG4gICAgaWYgKCFmaWxlKSB7XG4gICAgICBhbGVydCgnUGxlYXNlIGNob29zZSBhIHZhbGlkIGltYWdlIGZpbGUgKFBORywgSlBHLCBHSUYsIFNWRywgZXRjLiknKTtcbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGlzU3ZnID0gZmlsZS50eXBlID09ICdpbWFnZS9zdmcreG1sJztcblxuICAgIGxldCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgIC8vIENsb3N1cmUgdG8gY2FwdHVyZSB0aGUgZmlsZSBpbmZvcm1hdGlvbi5cbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGUgPT4gcmVzb2x2ZSh7XG4gICAgICBpc1N2ZyxcbiAgICAgIHVyaTogZS50YXJnZXQucmVzdWx0LFxuICAgICAgbmFtZTogZmlsZS5uYW1lXG4gICAgfSk7XG5cbiAgICBmaWxlUmVhZGVyLm9uZXJyb3IgPSBlID0+IHtcbiAgICAgIHN3aXRjaCAoZS50YXJnZXQuZXJyb3IuY29kZSkge1xuICAgICAgICBjYXNlIGUudGFyZ2V0LmVycm9yLk5PVF9GT1VORF9FUlI6XG4gICAgICAgICAgYWxlcnQoJ0ZpbGUgbm90IGZvdW5kIScpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZS50YXJnZXQuZXJyb3IuTk9UX1JFQURBQkxFX0VSUjpcbiAgICAgICAgICBhbGVydCgnRmlsZSBpcyBub3QgcmVhZGFibGUnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGUudGFyZ2V0LmVycm9yLkFCT1JUX0VSUjpcbiAgICAgICAgICBicmVhazsgLy8gbm9vcFxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYWxlcnQoJ0FuIGVycm9yIG9jY3VycmVkIHJlYWRpbmcgdGhpcyBmaWxlLicpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgIH07XG5cbiAgICBmaWxlUmVhZGVyLm9uYWJvcnQgPSBlID0+IHtcbiAgICAgIGFsZXJ0KCdGaWxlIHJlYWQgY2FuY2VsbGVkJyk7XG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgIH07XG5cbiAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gIH0pO1xufTtcblxuSW1hZ2VGaWVsZC5pc1ZhbGlkRmlsZV8gPSBmaWxlID0+ICEhZmlsZS50eXBlLnRvTG93ZXJDYXNlKCkubWF0Y2goL15pbWFnZVxcLy8pO1xuXG4vLyBQcmV2ZW50IHNjcm9sbGluZyBmb3IgY2xpcGFydCBwZXIgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NjAwNDU0XG4kKGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XG4gICQoJy5jYW5jZWwtcGFyZW50LXNjcm9sbCcpLm9uKCdtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsJywgZSA9PiB7XG4gICAgbGV0IGRlbHRhID0gZS5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEgfHwgLWUub3JpZ2luYWxFdmVudC5kZXRhaWw7XG4gICAgZS5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvcCAtPSBkZWx0YTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufSk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtGaWVsZH0gZnJvbSAnLi9GaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBSYW5nZUZpZWxkIGV4dGVuZHMgRmllbGQge1xuICBjcmVhdGVVaShjb250YWluZXIpIHtcbiAgICB2YXIgZmllbGRDb250YWluZXIgPSAkKCcuZm9ybS1maWVsZC1jb250YWluZXInLCBzdXBlci5jcmVhdGVVaShjb250YWluZXIpKTtcbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgdGhpcy5lbF8gPSAkKCc8ZGl2PicpXG4gICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1yYW5nZScpXG4gICAgICAgIC5hdHRyKCdpZCcsIHRoaXMuZ2V0SHRtbElkKCkpXG4gICAgICAgIC5hcHBlbmRUbyhmaWVsZENvbnRhaW5lcik7XG5cbiAgICB0aGlzLnJhbmdlRWxfID0gJCgnPGlucHV0PicpXG4gICAgICAgIC5hdHRyKCd0eXBlJywgJ3JhbmdlJylcbiAgICAgICAgLmF0dHIoJ21pbicsIHRoaXMucGFyYW1zXy5taW4gfHwgMClcbiAgICAgICAgLmF0dHIoJ21heCcsIHRoaXMucGFyYW1zXy5tYXggfHwgMTAwKVxuICAgICAgICAuYXR0cignc3RlcCcsIHRoaXMucGFyYW1zXy5zdGVwIHx8IDEpXG4gICAgICAgIC5vbignaW5wdXQnLCAoKSA9PiB0aGlzLnNldFZhbHVlKE51bWJlcih0aGlzLnJhbmdlRWxfLnZhbCgpKSB8fCAwLCB0cnVlKSlcbiAgICAgICAgLnZhbCh0aGlzLmdldFZhbHVlKCkpXG4gICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsXyk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXNfLnRleHRGbiB8fCB0aGlzLnBhcmFtc18uc2hvd1RleHQpIHtcbiAgICAgIHRoaXMucGFyYW1zXy50ZXh0Rm4gPSB0aGlzLnBhcmFtc18udGV4dEZuIHx8IChkID0+IGQpO1xuICAgICAgdGhpcy50ZXh0RWxfID0gJCgnPGRpdj4nKVxuICAgICAgICAgIC5hZGRDbGFzcygnZm9ybS1maWVsZC1yYW5nZS10ZXh0JylcbiAgICAgICAgICAudGV4dCh0aGlzLnBhcmFtc18udGV4dEZuKHRoaXMuZ2V0VmFsdWUoKSkpXG4gICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxfKTtcbiAgICB9XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyYW1zXy5kZWZhdWx0VmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInKVxuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbCwgcGF1c2VVaSkge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIHRoaXMudmFsdWVfID0gdmFsO1xuICAgIGlmICghcGF1c2VVaSkge1xuICAgICAgdGhpcy5yYW5nZUVsXy52YWwodmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dEVsXykge1xuICAgICAgdGhpcy50ZXh0RWxfLnRleHQodGhpcy5wYXJhbXNfLnRleHRGbih2YWwpKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlDaGFuZ2VkXyh2YWwsIG9sZFZhbHVlKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZVZhbHVlKHMpIHtcbiAgICB0aGlzLnNldFZhbHVlKE51bWJlcihzKSk7IC8vIGRvbid0IHVzZSBwYXJzZUludCBub3IgcGFyc2VGbG9hdFxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtGaWVsZH0gZnJvbSAnLi9GaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBUZXh0RmllbGQgZXh0ZW5kcyBGaWVsZCB7XG4gIGNyZWF0ZVVpKGNvbnRhaW5lcikge1xuICAgIHZhciBmaWVsZENvbnRhaW5lciA9ICQoJy5mb3JtLWZpZWxkLWNvbnRhaW5lcicsIHN1cGVyLmNyZWF0ZVVpKGNvbnRhaW5lcikpO1xuXG4gICAgdGhpcy5lbF8gPSAkKCc8aW5wdXQ+JylcbiAgICAgICAgLmF0dHIoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIC5hdHRyKCdwbGFjZWhvbGRlcicsIHRoaXMucGFyYW1zXy5wbGFjZWhvbGRlcilcbiAgICAgICAgLmFkZENsYXNzKCdmb3JtLWZpZWxkLXRleHQnKVxuICAgICAgICAudmFsKHRoaXMuZ2V0VmFsdWUoKSlcbiAgICAgICAgLm9uKCdpbnB1dCcsIGV2ID0+IHtcbiAgICAgICAgICB2YXIgb2xkVmFsID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHZhciBuZXdWYWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpLnZhbCgpO1xuICAgICAgICAgIGlmIChvbGRWYWwgIT0gbmV3VmFsKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKG5ld1ZhbCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuYXBwZW5kVG8oZmllbGRDb250YWluZXIpO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcmFtc18uZGVmYXVsdFZhbHVlIHx8ICcnO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBzZXRWYWx1ZSh2YWwsIHBhdXNlVWkpIHtcbiAgICBsZXQgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICB0aGlzLnZhbHVlXyA9IHZhbDtcbiAgICBpZiAoIXBhdXNlVWkpIHtcbiAgICAgIHRoaXMuZWxfLnZhbCh2YWwpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeUNoYW5nZWRfKHZhbCwgb2xkVmFsdWUpO1xuICB9XG5cbiAgc2VyaWFsaXplVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIGRlc2VyaWFsaXplVmFsdWUocykge1xuICAgIHRoaXMuc2V0VmFsdWUocyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0Jvb2xlYW5GaWVsZH0gZnJvbSAnLi9Cb29sZWFuRmllbGQnO1xuaW1wb3J0IHtDb2xvckZpZWxkfSBmcm9tICcuL0NvbG9yRmllbGQnO1xuaW1wb3J0IHtHcmFkaWVudEZpZWxkfSBmcm9tIFwiLi9HcmFkaWVudEZpZWxkXCI7XG5pbXBvcnQge0VudW1GaWVsZH0gZnJvbSAnLi9FbnVtRmllbGQnO1xuaW1wb3J0IHtGaWVsZH0gZnJvbSAnLi9GaWVsZCc7XG5pbXBvcnQge0Zvcm19IGZyb20gJy4vRm9ybSc7XG5pbXBvcnQge0ltYWdlRmllbGR9IGZyb20gJy4vSW1hZ2VGaWVsZCc7XG5pbXBvcnQge1JhbmdlRmllbGR9IGZyb20gJy4vUmFuZ2VGaWVsZCc7XG5pbXBvcnQge1RleHRGaWVsZH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuXG5leHBvcnQgY29uc3QgZm9ybXMgPSB7XG4gIEJvb2xlYW5GaWVsZCxcbiAgQ29sb3JGaWVsZCxcbiAgR3JhZGllbnRGaWVsZCxcbiAgRW51bUZpZWxkLFxuICBGaWVsZCxcbiAgRm9ybSxcbiAgSW1hZ2VGaWVsZCxcbiAgUmFuZ2VGaWVsZCxcbiAgVGV4dEZpZWxkLFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0hhc2h9IGZyb20gJy4vSGFzaCc7XG5pbXBvcnQge1V0aWx9IGZyb20gJy4vVXRpbCc7XG5pbXBvcnQge1ppcH0gZnJvbSAnLi9aaXAnO1xuXG5leHBvcnQgY29uc3Qgc3R1ZGlvID0ge1xuICBIYXNoLFxuICBVdGlsLFxuICBaaXAsXG59O1xuXG5pbXBvcnQge2Zvcm1zfSBmcm9tICcuL2Zvcm1zJztcblxuT2JqZWN0LmFzc2lnbihzdHVkaW8sIGZvcm1zKTtcbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgNC4xLjFcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHVuZGVmaW5lZDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHVuZGVmaW5lZDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAoe30pLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHIgPSByZXF1aXJlO1xuICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHVuZGVmaW5lZDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICBpZiAoX3N0YXRlKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IF9hcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxudmFyIEdFVF9USEVOX0VSUk9SID0gbmV3IEVycm9yT2JqZWN0KCk7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ocHJvbWlzZSkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gR0VUX1RIRU5fRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgICAgR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB1bmRlZmluZWQsXG4gICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIEVycm9yT2JqZWN0KCkge1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgZXJyb3IgPSB1bmRlZmluZWQsXG4gICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG4gICAgICBmYWlsZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlLmVycm9yID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gRW51bWVyYXRvciQxKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gIH1cblxuICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG4gIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQyKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgfSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGksIHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgfVxufTtcblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gKHByb21pc2UsIGkpIHtcbiAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICB9KTtcbn07XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbCQxKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yJDEodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UkMShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuZnVuY3Rpb24gUHJvbWlzZSQyKHJlc29sdmVyKSB7XG4gIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSQyID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgfVxufVxuXG5Qcm9taXNlJDIuYWxsID0gYWxsJDE7XG5Qcm9taXNlJDIucmFjZSA9IHJhY2UkMTtcblByb21pc2UkMi5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQyLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQyLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDIuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQyLl9hc2FwID0gYXNhcDtcblxuUHJvbWlzZSQyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFByb21pc2UkMixcblxuICAvKipcbiAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBDaGFpbmluZ1xuICAgIC0tLS0tLS0tXG4gIFxuICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgIH0pO1xuICBcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICB9KTtcbiAgICBgYGBcbiAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQXNzaW1pbGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tXG4gIFxuICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IHJlc3VsdDtcbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgbGV0IGF1dGhvciwgYm9va3M7XG4gIFxuICAgIHRyeSB7XG4gICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBFcnJiYWNrIEV4YW1wbGVcbiAgXG4gICAgYGBganNcbiAgXG4gICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICBcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gIFxuICAgIH1cbiAgXG4gICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBQcm9taXNlIEV4YW1wbGU7XG4gIFxuICAgIGBgYGphdmFzY3JpcHRcbiAgICBmaW5kQXV0aG9yKCkuXG4gICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIHRoZW5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgdGhlbjogdGhlbixcblxuICAvKipcbiAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgXG4gICAgYGBganNcbiAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICB9XG4gIFxuICAgIC8vIHN5bmNocm9ub3VzXG4gICAgdHJ5IHtcbiAgICAgIGZpbmRBdXRob3IoKTtcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9XG4gIFxuICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgY2F0Y2hcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICAnY2F0Y2gnOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfVxufTtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCQxKCkge1xuICAgIHZhciBsb2NhbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgIGlmIChQKSB7XG4gICAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDI7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMi5wb2x5ZmlsbCA9IHBvbHlmaWxsJDE7XG5Qcm9taXNlJDIuUHJvbWlzZSA9IFByb21pc2UkMjtcblxucmV0dXJuIFByb21pc2UkMjtcblxufSkpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gVGlueUNvbG9yIHYxLjQuMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9UaW55Q29sb3Jcbi8vIEJyaWFuIEdyaW5zdGVhZCwgTUlUIExpY2Vuc2VcblxuKGZ1bmN0aW9uKE1hdGgpIHtcblxudmFyIHRyaW1MZWZ0ID0gL15cXHMrLyxcbiAgICB0cmltUmlnaHQgPSAvXFxzKyQvLFxuICAgIHRpbnlDb3VudGVyID0gMCxcbiAgICBtYXRoUm91bmQgPSBNYXRoLnJvdW5kLFxuICAgIG1hdGhNaW4gPSBNYXRoLm1pbixcbiAgICBtYXRoTWF4ID0gTWF0aC5tYXgsXG4gICAgbWF0aFJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG5mdW5jdGlvbiB0aW55Y29sb3IgKGNvbG9yLCBvcHRzKSB7XG5cbiAgICBjb2xvciA9IChjb2xvcikgPyBjb2xvciA6ICcnO1xuICAgIG9wdHMgPSBvcHRzIHx8IHsgfTtcblxuICAgIC8vIElmIGlucHV0IGlzIGFscmVhZHkgYSB0aW55Y29sb3IsIHJldHVybiBpdHNlbGZcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiB0aW55Y29sb3IpIHtcbiAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgY2FsbCB1c2luZyBuZXcgaW5zdGVhZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aW55Y29sb3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGlueWNvbG9yKGNvbG9yLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgcmdiID0gaW5wdXRUb1JHQihjb2xvcik7XG4gICAgdGhpcy5fb3JpZ2luYWxJbnB1dCA9IGNvbG9yLFxuICAgIHRoaXMuX3IgPSByZ2IucixcbiAgICB0aGlzLl9nID0gcmdiLmcsXG4gICAgdGhpcy5fYiA9IHJnYi5iLFxuICAgIHRoaXMuX2EgPSByZ2IuYSxcbiAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwLFxuICAgIHRoaXMuX2Zvcm1hdCA9IG9wdHMuZm9ybWF0IHx8IHJnYi5mb3JtYXQ7XG4gICAgdGhpcy5fZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XG5cbiAgICAvLyBEb24ndCBsZXQgdGhlIHJhbmdlIG9mIFswLDI1NV0gY29tZSBiYWNrIGluIFswLDFdLlxuICAgIC8vIFBvdGVudGlhbGx5IGxvc2UgYSBsaXR0bGUgYml0IG9mIHByZWNpc2lvbiBoZXJlLCBidXQgd2lsbCBmaXggaXNzdWVzIHdoZXJlXG4gICAgLy8gLjUgZ2V0cyBpbnRlcnByZXRlZCBhcyBoYWxmIG9mIHRoZSB0b3RhbCwgaW5zdGVhZCBvZiBoYWxmIG9mIDFcbiAgICAvLyBJZiBpdCB3YXMgc3VwcG9zZWQgdG8gYmUgMTI4LCB0aGlzIHdhcyBhbHJlYWR5IHRha2VuIGNhcmUgb2YgYnkgYGlucHV0VG9SZ2JgXG4gICAgaWYgKHRoaXMuX3IgPCAxKSB7IHRoaXMuX3IgPSBtYXRoUm91bmQodGhpcy5fcik7IH1cbiAgICBpZiAodGhpcy5fZyA8IDEpIHsgdGhpcy5fZyA9IG1hdGhSb3VuZCh0aGlzLl9nKTsgfVxuICAgIGlmICh0aGlzLl9iIDwgMSkgeyB0aGlzLl9iID0gbWF0aFJvdW5kKHRoaXMuX2IpOyB9XG5cbiAgICB0aGlzLl9vayA9IHJnYi5vaztcbiAgICB0aGlzLl90Y19pZCA9IHRpbnlDb3VudGVyKys7XG59XG5cbnRpbnljb2xvci5wcm90b3R5cGUgPSB7XG4gICAgaXNEYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnJpZ2h0bmVzcygpIDwgMTI4O1xuICAgIH0sXG4gICAgaXNMaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0RhcmsoKTtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2s7XG4gICAgfSxcbiAgICBnZXRPcmlnaW5hbElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbElucHV0O1xuICAgIH0sXG4gICAgZ2V0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcbiAgICB9LFxuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfSxcbiAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9BRVJUI2NvbG9yLWNvbnRyYXN0XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHJldHVybiAocmdiLnIgKiAyOTkgKyByZ2IuZyAqIDU4NyArIHJnYi5iICogMTE0KSAvIDEwMDA7XG4gICAgfSxcbiAgICBnZXRMdW1pbmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMudG9SZ2IoKTtcbiAgICAgICAgdmFyIFJzUkdCLCBHc1JHQiwgQnNSR0IsIFIsIEcsIEI7XG4gICAgICAgIFJzUkdCID0gcmdiLnIvMjU1O1xuICAgICAgICBHc1JHQiA9IHJnYi5nLzI1NTtcbiAgICAgICAgQnNSR0IgPSByZ2IuYi8yNTU7XG5cbiAgICAgICAgaWYgKFJzUkdCIDw9IDAuMDM5MjgpIHtSID0gUnNSR0IgLyAxMi45Mjt9IGVsc2Uge1IgPSBNYXRoLnBvdygoKFJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEdzUkdCIDw9IDAuMDM5MjgpIHtHID0gR3NSR0IgLyAxMi45Mjt9IGVsc2Uge0cgPSBNYXRoLnBvdygoKEdzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEJzUkdCIDw9IDAuMDM5MjgpIHtCID0gQnNSR0IgLyAxMi45Mjt9IGVsc2Uge0IgPSBNYXRoLnBvdygoKEJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgcmV0dXJuICgwLjIxMjYgKiBSKSArICgwLjcxNTIgKiBHKSArICgwLjA3MjIgKiBCKTtcbiAgICB9LFxuICAgIHNldEFscGhhOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hID0gYm91bmRBbHBoYSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9Ic3Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzdi5oICogMzYwLCBzOiBoc3YucywgdjogaHN2LnYsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHN2U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc3YuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHN2LnMgKiAxMDApLCB2ID0gbWF0aFJvdW5kKGhzdi52ICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzdihcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzdmEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgcmV0dXJuIHsgaDogaHNsLmggKiAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9Ic2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHZhciBoID0gbWF0aFJvdW5kKGhzbC5oICogMzYwKSwgcyA9IG1hdGhSb3VuZChoc2wucyAqIDEwMCksIGwgPSBtYXRoUm91bmQoaHNsLmwgKiAxMDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwiaHNsKFwiICArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUpXCIgOlxuICAgICAgICAgIFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUsIFwiKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvSGV4OiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCBhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4KGFsbG93M0NoYXIpO1xuICAgIH0sXG4gICAgdG9IZXg4OiBmdW5jdGlvbihhbGxvdzRDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JhVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSwgYWxsb3c0Q2hhcik7XG4gICAgfSxcbiAgICB0b0hleDhTdHJpbmc6IGZ1bmN0aW9uKGFsbG93NENoYXIpIHtcbiAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXg4KGFsbG93NENoYXIpO1xuICAgIH0sXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRoUm91bmQodGhpcy5fciksIGc6IG1hdGhSb3VuZCh0aGlzLl9nKSwgYjogbWF0aFJvdW5kKHRoaXMuX2IpLCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b1JnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKHRoaXMuX3IpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2cpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXCIpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgZzogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcInJnYihcIiAgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9iLCAyNTUpICogMTAwKSArIFwiJSlcIiA6XG4gICAgICAgICAgXCJyZ2JhKFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleE5hbWVzW3JnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRydWUpXSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHRvRmlsdGVyOiBmdW5jdGlvbihzZWNvbmRDb2xvcikge1xuICAgICAgICB2YXIgaGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XG4gICAgICAgIHZhciBzZWNvbmRIZXg4U3RyaW5nID0gaGV4OFN0cmluZztcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZSA9IHRoaXMuX2dyYWRpZW50VHlwZSA/IFwiR3JhZGllbnRUeXBlID0gMSwgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChzZWNvbmRDb2xvcikge1xuICAgICAgICAgICAgdmFyIHMgPSB0aW55Y29sb3Ioc2Vjb25kQ29sb3IpO1xuICAgICAgICAgICAgc2Vjb25kSGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgocy5fciwgcy5fZywgcy5fYiwgcy5fYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoXCIrZ3JhZGllbnRUeXBlK1wic3RhcnRDb2xvcnN0cj1cIitoZXg4U3RyaW5nK1wiLGVuZENvbG9yc3RyPVwiK3NlY29uZEhleDhTdHJpbmcrXCIpXCI7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBmb3JtYXRTZXQgPSAhIWZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuX2Zvcm1hdDtcblxuICAgICAgICB2YXIgZm9ybWF0dGVkU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNBbHBoYSA9IHRoaXMuX2EgPCAxICYmIHRoaXMuX2EgPj0gMDtcbiAgICAgICAgdmFyIG5lZWRzQWxwaGFGb3JtYXQgPSAhZm9ybWF0U2V0ICYmIGhhc0FscGhhICYmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIiB8fCBmb3JtYXQgPT09IFwiaGV4M1wiIHx8IGZvcm1hdCA9PT0gXCJoZXg0XCIgfHwgZm9ybWF0ID09PSBcImhleDhcIiB8fCBmb3JtYXQgPT09IFwibmFtZVwiKTtcblxuICAgICAgICBpZiAobmVlZHNBbHBoYUZvcm1hdCkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBcInRyYW5zcGFyZW50XCIsIGFsbCBvdGhlciBub24tYWxwaGEgZm9ybWF0c1xuICAgICAgICAgICAgLy8gd2lsbCByZXR1cm4gcmdiYSB3aGVuIHRoZXJlIGlzIHRyYW5zcGFyZW5jeS5cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwibmFtZVwiICYmIHRoaXMuX2EgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b05hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyZ2JcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicHJnYlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvUGVyY2VudGFnZVJnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4M1wiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4NFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4OFN0cmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDhcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhzbFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHNsU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc3ZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzdlN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZyB8fCB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aW55Y29sb3IodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5TW9kaWZpY2F0aW9uOiBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICB2YXIgY29sb3IgPSBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICAgICAgdGhpcy5fciA9IGNvbG9yLl9yO1xuICAgICAgICB0aGlzLl9nID0gY29sb3IuX2c7XG4gICAgICAgIHRoaXMuX2IgPSBjb2xvci5fYjtcbiAgICAgICAgdGhpcy5zZXRBbHBoYShjb2xvci5fYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbGlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihsaWdodGVuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgYnJpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oYnJpZ2h0ZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBkYXJrZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGFya2VuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihkZXNhdHVyYXRlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc2F0dXJhdGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBncmV5c2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZ3JleXNjYWxlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc3BpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihzcGluLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlDb21iaW5hdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgIH0sXG4gICAgYW5hbG9nb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oYW5hbG9nb3VzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKGNvbXBsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtb25vY2hyb21hdGljOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24obW9ub2Nocm9tYXRpYywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNwbGl0Y29tcGxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHNwbGl0Y29tcGxlbWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRyaWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24odHJpYWQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0ZXRyYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0ZXRyYWQsIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcblxuLy8gSWYgaW5wdXQgaXMgYW4gb2JqZWN0LCBmb3JjZSAxIGludG8gXCIxLjBcIiB0byBoYW5kbGUgcmF0aW9zIHByb3Blcmx5XG4vLyBTdHJpbmcgaW5wdXQgcmVxdWlyZXMgXCIxLjBcIiBhcyBpbnB1dCwgc28gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgMVxudGlueWNvbG9yLmZyb21SYXRpbyA9IGZ1bmN0aW9uKGNvbG9yLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBuZXdDb2xvciA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb2xvcltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbG9yID0gbmV3Q29sb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG59O1xuXG4vLyBHaXZlbiBhIHN0cmluZyBvciBvYmplY3QsIGNvbnZlcnQgdGhhdCBpbnB1dCB0byBSR0Jcbi8vIFBvc3NpYmxlIHN0cmluZyBpbnB1dHM6XG4vL1xuLy8gICAgIFwicmVkXCJcbi8vICAgICBcIiNmMDBcIiBvciBcImYwMFwiXG4vLyAgICAgXCIjZmYwMDAwXCIgb3IgXCJmZjAwMDBcIlxuLy8gICAgIFwiI2ZmMDAwMDAwXCIgb3IgXCJmZjAwMDAwMFwiXG4vLyAgICAgXCJyZ2IgMjU1IDAgMFwiIG9yIFwicmdiICgyNTUsIDAsIDApXCJcbi8vICAgICBcInJnYiAxLjAgMCAwXCIgb3IgXCJyZ2IgKDEsIDAsIDApXCJcbi8vICAgICBcInJnYmEgKDI1NSwgMCwgMCwgMSlcIiBvciBcInJnYmEgMjU1LCAwLCAwLCAxXCJcbi8vICAgICBcInJnYmEgKDEuMCwgMCwgMCwgMSlcIiBvciBcInJnYmEgMS4wLCAwLCAwLCAxXCJcbi8vICAgICBcImhzbCgwLCAxMDAlLCA1MCUpXCIgb3IgXCJoc2wgMCAxMDAlIDUwJVwiXG4vLyAgICAgXCJoc2xhKDAsIDEwMCUsIDUwJSwgMSlcIiBvciBcImhzbGEgMCAxMDAlIDUwJSwgMVwiXG4vLyAgICAgXCJoc3YoMCwgMTAwJSwgMTAwJSlcIiBvciBcImhzdiAwIDEwMCUgMTAwJVwiXG4vL1xuZnVuY3Rpb24gaW5wdXRUb1JHQihjb2xvcikge1xuXG4gICAgdmFyIHJnYiA9IHsgcjogMCwgZzogMCwgYjogMCB9O1xuICAgIHZhciBhID0gMTtcbiAgICB2YXIgcyA9IG51bGw7XG4gICAgdmFyIHYgPSBudWxsO1xuICAgIHZhciBsID0gbnVsbDtcbiAgICB2YXIgb2sgPSBmYWxzZTtcbiAgICB2YXIgZm9ybWF0ID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29sb3IgPSBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLnIpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmcpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmIpKSB7XG4gICAgICAgICAgICByZ2IgPSByZ2JUb1JnYihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFN0cmluZyhjb2xvci5yKS5zdWJzdHIoLTEpID09PSBcIiVcIiA/IFwicHJnYlwiIDogXCJyZ2JcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci52KSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICB2ID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci52KTtcbiAgICAgICAgICAgIHJnYiA9IGhzdlRvUmdiKGNvbG9yLmgsIHMsIHYpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc3ZcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkQ1NTVW5pdChjb2xvci5oKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5zKSAmJiBpc1ZhbGlkQ1NTVW5pdChjb2xvci5sKSkge1xuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICBsID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5sKTtcbiAgICAgICAgICAgIHJnYiA9IGhzbFRvUmdiKGNvbG9yLmgsIHMsIGwpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJoc2xcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShcImFcIikpIHtcbiAgICAgICAgICAgIGEgPSBjb2xvci5hO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYSA9IGJvdW5kQWxwaGEoYSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvazogb2ssXG4gICAgICAgIGZvcm1hdDogY29sb3IuZm9ybWF0IHx8IGZvcm1hdCxcbiAgICAgICAgcjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLnIsIDApKSxcbiAgICAgICAgZzogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmcsIDApKSxcbiAgICAgICAgYjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLmIsIDApKSxcbiAgICAgICAgYTogYVxuICAgIH07XG59XG5cblxuLy8gQ29udmVyc2lvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGByZ2JUb0hzbGAsIGByZ2JUb0hzdmAsIGBoc2xUb1JnYmAsIGBoc3ZUb1JnYmAgbW9kaWZpZWQgZnJvbTpcbi8vIDxodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0PlxuXG4vLyBgcmdiVG9SZ2JgXG4vLyBIYW5kbGUgYm91bmRzIC8gcGVyY2VudGFnZSBjaGVja2luZyB0byBjb25mb3JtIHRvIENTUyBjb2xvciBzcGVjXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8+XG4vLyAqQXNzdW1lczoqIHIsIGcsIGIgaW4gWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIFswLCAyNTVdXG5mdW5jdGlvbiByZ2JUb1JnYihyLCBnLCBiKXtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBib3VuZDAxKHIsIDI1NSkgKiAyNTUsXG4gICAgICAgIGc6IGJvdW5kMDEoZywgMjU1KSAqIDI1NSxcbiAgICAgICAgYjogYm91bmQwMShiLCAyNTUpICogMjU1XG4gICAgfTtcbn1cblxuLy8gYHJnYlRvSHNsYFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC5cbi8vICpBc3N1bWVzOiogciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCBsIH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHNsKHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBoIC89IDY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaDogaCwgczogcywgbDogbCB9O1xufVxuXG4vLyBgaHNsVG9SZ2JgXG4vLyBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLlxuLy8gKkFzc3VtZXM6KiBoIGlzIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDM2MF0gYW5kIHMgYW5kIGwgYXJlIGNvbnRhaW5lZCBbMCwgMV0gb3IgWzAsIDEwMF1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICAgIHZhciByLCBnLCBiO1xuXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKTtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIGwgPSBib3VuZDAxKGwsIDEwMCk7XG5cbiAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICAgICAgaWYodCA8IDApIHQgKz0gMTtcbiAgICAgICAgaWYodCA+IDEpIHQgLT0gMTtcbiAgICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xuICAgICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBpZihzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYiAqIDI1NSB9O1xufVxuXG4vLyBgcmdiVG9Ic3ZgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNWXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyBoLCBzLCB2IH0gaW4gWzAsMV1cbmZ1bmN0aW9uIHJnYlRvSHN2KHIsIGcsIGIpIHtcblxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgZyA9IGJvdW5kMDEoZywgMjU1KTtcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xuXG4gICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgdmFyIGgsIHMsIHYgPSBtYXg7XG5cbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XG5cbiAgICBpZihtYXggPT0gbWluKSB7XG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgfVxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIHY6IHYgfTtcbn1cblxuLy8gYGhzdlRvUmdiYFxuLy8gQ29udmVydHMgYW4gSFNWIGNvbG9yIHZhbHVlIHRvIFJHQi5cbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCB2IGFyZSBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAxMDBdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIHRoZSBzZXQgWzAsIDI1NV1cbiBmdW5jdGlvbiBoc3ZUb1JnYihoLCBzLCB2KSB7XG5cbiAgICBoID0gYm91bmQwMShoLCAzNjApICogNjtcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgIHYgPSBib3VuZDAxKHYsIDEwMCk7XG5cbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCksXG4gICAgICAgIGYgPSBoIC0gaSxcbiAgICAgICAgcCA9IHYgKiAoMSAtIHMpLFxuICAgICAgICBxID0gdiAqICgxIC0gZiAqIHMpLFxuICAgICAgICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpLFxuICAgICAgICBtb2QgPSBpICUgNixcbiAgICAgICAgciA9IFt2LCBxLCBwLCBwLCB0LCB2XVttb2RdLFxuICAgICAgICBnID0gW3QsIHYsIHYsIHEsIHAsIHBdW21vZF0sXG4gICAgICAgIGIgPSBbcCwgcCwgdCwgdiwgdiwgcV1bbW9kXTtcblxuICAgIHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfTtcbn1cblxuLy8gYHJnYlRvSGV4YFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIGhleFxuLy8gQXNzdW1lcyByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV1cbi8vIFJldHVybnMgYSAzIG9yIDYgY2hhcmFjdGVyIGhleFxuZnVuY3Rpb24gcmdiVG9IZXgociwgZywgYiwgYWxsb3czQ2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSAzIGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3czQ2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSkge1xuICAgICAgICByZXR1cm4gaGV4WzBdLmNoYXJBdCgwKSArIGhleFsxXS5jaGFyQXQoMCkgKyBoZXhbMl0uY2hhckF0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYHJnYmFUb0hleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgcGx1cyBhbHBoYSB0cmFuc3BhcmVuY3kgdG8gaGV4XG4vLyBBc3N1bWVzIHIsIGcsIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZFxuLy8gYSBpbiBbMCwgMV0uIFJldHVybnMgYSA0IG9yIDggY2hhcmFjdGVyIHJnYmEgaGV4XG5mdW5jdGlvbiByZ2JhVG9IZXgociwgZywgYiwgYSwgYWxsb3c0Q2hhcikge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKVxuICAgIF07XG5cbiAgICAvLyBSZXR1cm4gYSA0IGNoYXJhY3RlciBoZXggaWYgcG9zc2libGVcbiAgICBpZiAoYWxsb3c0Q2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSAmJiBoZXhbM10uY2hhckF0KDApID09IGhleFszXS5jaGFyQXQoMSkpIHtcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKSArIGhleFszXS5jaGFyQXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgcmdiYVRvQXJnYkhleGBcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgdG8gYW4gQVJHQiBIZXg4IHN0cmluZ1xuLy8gUmFyZWx5IHVzZWQsIGJ1dCByZXF1aXJlZCBmb3IgXCJ0b0ZpbHRlcigpXCJcbmZ1bmN0aW9uIHJnYmFUb0FyZ2JIZXgociwgZywgYiwgYSkge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGBlcXVhbHNgXG4vLyBDYW4gYmUgY2FsbGVkIHdpdGggYW55IHRpbnljb2xvciBpbnB1dFxudGlueWNvbG9yLmVxdWFscyA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMikge1xuICAgIGlmICghY29sb3IxIHx8ICFjb2xvcjIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcjEpLnRvUmdiU3RyaW5nKCkgPT0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2JTdHJpbmcoKTtcbn07XG5cbnRpbnljb2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yLmZyb21SYXRpbyh7XG4gICAgICAgIHI6IG1hdGhSYW5kb20oKSxcbiAgICAgICAgZzogbWF0aFJhbmRvbSgpLFxuICAgICAgICBiOiBtYXRoUmFuZG9tKClcbiAgICB9KTtcbn07XG5cblxuLy8gTW9kaWZpY2F0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGxlc3MuanMgZm9yIHNvbWUgb2YgdGhlIGJhc2ljcyBoZXJlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaGVhZC9sZXNzLmpzL2Jsb2IvbWFzdGVyL2xpYi9sZXNzL2Z1bmN0aW9ucy5qcz5cblxuZnVuY3Rpb24gZGVzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wucyAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5zICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IGNsYW1wMDEoaHNsLnMpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gZ3JleXNjYWxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZGVzYXR1cmF0ZSgxMDApO1xufVxuXG5mdW5jdGlvbiBsaWdodGVuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIGJyaWdodGVuKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgcmdiID0gdGlueWNvbG9yKGNvbG9yKS50b1JnYigpO1xuICAgIHJnYi5yID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLnIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuZyA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5nIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmdiLmIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuYiAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJldHVybiB0aW55Y29sb3IocmdiKTtcbn1cblxuZnVuY3Rpb24gZGFya2VuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIFNwaW4gdGFrZXMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBhbW91bnQgd2l0aGluIFstMzYwLCAzNjBdIGluZGljYXRpbmcgdGhlIGNoYW5nZSBvZiBodWUuXG4vLyBWYWx1ZXMgb3V0c2lkZSBvZiB0aGlzIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbnRvIHRoaXMgcmFuZ2UuXG5mdW5jdGlvbiBzcGluKGNvbG9yLCBhbW91bnQpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQpICUgMzYwO1xuICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIENvbWJpbmF0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGFua3MgdG8galF1ZXJ5IHhDb2xvciBmb3Igc29tZSBvZiB0aGUgaWRlYXMgYmVoaW5kIHRoZXNlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2luZnVzaW9uL2pRdWVyeS14Y29sb3IvYmxvYi9tYXN0ZXIvanF1ZXJ5Lnhjb2xvci5qcz5cblxuZnVuY3Rpb24gY29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLmggPSAoaHNsLmggKyAxODApICUgMzYwO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gdHJpYWQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxMjApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjQwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gdGV0cmFkKGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgOTApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTgwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI3MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHNwbGl0Y29tcGxlbWVudChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDcyKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjE2KSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBhbmFsb2dvdXMoY29sb3IsIHJlc3VsdHMsIHNsaWNlcykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XG4gICAgc2xpY2VzID0gc2xpY2VzIHx8IDMwO1xuXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgcGFydCA9IDM2MCAvIHNsaWNlcztcbiAgICB2YXIgcmV0ID0gW3Rpbnljb2xvcihjb2xvcildO1xuXG4gICAgZm9yIChoc2wuaCA9ICgoaHNsLmggLSAocGFydCAqIHJlc3VsdHMgPj4gMSkpICsgNzIwKSAlIDM2MDsgLS1yZXN1bHRzOyApIHtcbiAgICAgICAgaHNsLmggPSAoaHNsLmggKyBwYXJ0KSAlIDM2MDtcbiAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKGhzbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBtb25vY2hyb21hdGljKGNvbG9yLCByZXN1bHRzKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcbiAgICB2YXIgaHN2ID0gdGlueWNvbG9yKGNvbG9yKS50b0hzdigpO1xuICAgIHZhciBoID0gaHN2LmgsIHMgPSBoc3YucywgdiA9IGhzdi52O1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgbW9kaWZpY2F0aW9uID0gMSAvIHJlc3VsdHM7XG5cbiAgICB3aGlsZSAocmVzdWx0cy0tKSB7XG4gICAgICAgIHJldC5wdXNoKHRpbnljb2xvcih7IGg6IGgsIHM6IHMsIHY6IHZ9KSk7XG4gICAgICAgIHYgPSAodiArIG1vZGlmaWNhdGlvbikgJSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIFV0aWxpdHkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudGlueWNvbG9yLm1peCA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDUwKTtcblxuICAgIHZhciByZ2IxID0gdGlueWNvbG9yKGNvbG9yMSkudG9SZ2IoKTtcbiAgICB2YXIgcmdiMiA9IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiKCk7XG5cbiAgICB2YXIgcCA9IGFtb3VudCAvIDEwMDtcblxuICAgIHZhciByZ2JhID0ge1xuICAgICAgICByOiAoKHJnYjIuciAtIHJnYjEucikgKiBwKSArIHJnYjEucixcbiAgICAgICAgZzogKChyZ2IyLmcgLSByZ2IxLmcpICogcCkgKyByZ2IxLmcsXG4gICAgICAgIGI6ICgocmdiMi5iIC0gcmdiMS5iKSAqIHApICsgcmdiMS5iLFxuICAgICAgICBhOiAoKHJnYjIuYSAtIHJnYjEuYSkgKiBwKSArIHJnYjEuYVxuICAgIH07XG5cbiAgICByZXR1cm4gdGlueWNvbG9yKHJnYmEpO1xufTtcblxuXG4vLyBSZWFkYWJpbGl0eSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWYgKFdDQUcgVmVyc2lvbiAyKVxuXG4vLyBgY29udHJhc3RgXG4vLyBBbmFseXplIHRoZSAyIGNvbG9ycyBhbmQgcmV0dXJucyB0aGUgY29sb3IgY29udHJhc3QgZGVmaW5lZCBieSAoV0NBRyBWZXJzaW9uIDIpXG50aW55Y29sb3IucmVhZGFiaWxpdHkgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuICAgIHZhciBjMSA9IHRpbnljb2xvcihjb2xvcjEpO1xuICAgIHZhciBjMiA9IHRpbnljb2xvcihjb2xvcjIpO1xuICAgIHJldHVybiAoTWF0aC5tYXgoYzEuZ2V0THVtaW5hbmNlKCksYzIuZ2V0THVtaW5hbmNlKCkpKzAuMDUpIC8gKE1hdGgubWluKGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KTtcbn07XG5cbi8vIGBpc1JlYWRhYmxlYFxuLy8gRW5zdXJlIHRoYXQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciBjb21iaW5hdGlvbnMgbWVldCBXQ0FHMiBndWlkZWxpbmVzLlxuLy8gVGhlIHRoaXJkIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIE9iamVjdC5cbi8vICAgICAgdGhlICdsZXZlbCcgcHJvcGVydHkgc3RhdGVzICdBQScgb3IgJ0FBQScgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdBQSc7XG4vLyAgICAgIHRoZSAnc2l6ZScgcHJvcGVydHkgc3RhdGVzICdsYXJnZScgb3IgJ3NtYWxsJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ3NtYWxsJy5cbi8vIElmIHRoZSBlbnRpcmUgb2JqZWN0IGlzIGFic2VudCwgaXNSZWFkYWJsZSBkZWZhdWx0cyB0byB7bGV2ZWw6XCJBQVwiLHNpemU6XCJzbWFsbFwifS5cblxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIpID0+IGZhbHNlXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIse2xldmVsOlwiQUFcIixzaXplOlwibGFyZ2VcIn0pID0+IGZhbHNlXG50aW55Y29sb3IuaXNSZWFkYWJsZSA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCB3Y2FnMikge1xuICAgIHZhciByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShjb2xvcjEsIGNvbG9yMik7XG4gICAgdmFyIHdjYWcyUGFybXMsIG91dDtcblxuICAgIG91dCA9IGZhbHNlO1xuXG4gICAgd2NhZzJQYXJtcyA9IHZhbGlkYXRlV0NBRzJQYXJtcyh3Y2FnMik7XG4gICAgc3dpdGNoICh3Y2FnMlBhcm1zLmxldmVsICsgd2NhZzJQYXJtcy5zaXplKSB7XG4gICAgICAgIGNhc2UgXCJBQXNtYWxsXCI6XG4gICAgICAgIGNhc2UgXCJBQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQWxhcmdlXCI6XG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQUFzbWFsbFwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuXG59O1xuXG4vLyBgbW9zdFJlYWRhYmxlYFxuLy8gR2l2ZW4gYSBiYXNlIGNvbG9yIGFuZCBhIGxpc3Qgb2YgcG9zc2libGUgZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kXG4vLyBjb2xvcnMgZm9yIHRoYXQgYmFzZSwgcmV0dXJucyB0aGUgbW9zdCByZWFkYWJsZSBjb2xvci5cbi8vIE9wdGlvbmFsbHkgcmV0dXJucyBCbGFjayBvciBXaGl0ZSBpZiB0aGUgbW9zdCByZWFkYWJsZSBjb2xvciBpcyB1bnJlYWRhYmxlLlxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjMTIzXCIsIFtcIiMxMjRcIiwgXCIjMTI1XCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6ZmFsc2V9KS50b0hleFN0cmluZygpOyAvLyBcIiMxMTIyNTVcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWV9KS50b0hleFN0cmluZygpOyAgLy8gXCIjZmZmZmZmXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcImxhcmdlXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmYWYzZjNcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiNhODAxNWFcIiwgW1wiI2ZhZjNmM1wiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWUsbGV2ZWw6XCJBQUFcIixzaXplOlwic21hbGxcIn0pLnRvSGV4U3RyaW5nKCk7IC8vIFwiI2ZmZmZmZlwiXG50aW55Y29sb3IubW9zdFJlYWRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9yLCBjb2xvckxpc3QsIGFyZ3MpIHtcbiAgICB2YXIgYmVzdENvbG9yID0gbnVsbDtcbiAgICB2YXIgYmVzdFNjb3JlID0gMDtcbiAgICB2YXIgcmVhZGFiaWxpdHk7XG4gICAgdmFyIGluY2x1ZGVGYWxsYmFja0NvbG9ycywgbGV2ZWwsIHNpemUgO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGluY2x1ZGVGYWxsYmFja0NvbG9ycyA9IGFyZ3MuaW5jbHVkZUZhbGxiYWNrQ29sb3JzIDtcbiAgICBsZXZlbCA9IGFyZ3MubGV2ZWw7XG4gICAgc2l6ZSA9IGFyZ3Muc2l6ZTtcblxuICAgIGZvciAodmFyIGk9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5KGJhc2VDb2xvciwgY29sb3JMaXN0W2ldKTtcbiAgICAgICAgaWYgKHJlYWRhYmlsaXR5ID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSByZWFkYWJpbGl0eTtcbiAgICAgICAgICAgIGJlc3RDb2xvciA9IHRpbnljb2xvcihjb2xvckxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbnljb2xvci5pc1JlYWRhYmxlKGJhc2VDb2xvciwgYmVzdENvbG9yLCB7XCJsZXZlbFwiOmxldmVsLFwic2l6ZVwiOnNpemV9KSB8fCAhaW5jbHVkZUZhbGxiYWNrQ29sb3JzKSB7XG4gICAgICAgIHJldHVybiBiZXN0Q29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycz1mYWxzZTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvci5tb3N0UmVhZGFibGUoYmFzZUNvbG9yLFtcIiNmZmZcIiwgXCIjMDAwXCJdLGFyZ3MpO1xuICAgIH1cbn07XG5cblxuLy8gQmlnIExpc3Qgb2YgQ29sb3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3I+XG52YXIgbmFtZXMgPSB0aW55Y29sb3IubmFtZXMgPSB7XG4gICAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuICAgIGFudGlxdWV3aGl0ZTogXCJmYWViZDdcIixcbiAgICBhcXVhOiBcIjBmZlwiLFxuICAgIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG4gICAgYXp1cmU6IFwiZjBmZmZmXCIsXG4gICAgYmVpZ2U6IFwiZjVmNWRjXCIsXG4gICAgYmlzcXVlOiBcImZmZTRjNFwiLFxuICAgIGJsYWNrOiBcIjAwMFwiLFxuICAgIGJsYW5jaGVkYWxtb25kOiBcImZmZWJjZFwiLFxuICAgIGJsdWU6IFwiMDBmXCIsXG4gICAgYmx1ZXZpb2xldDogXCI4YTJiZTJcIixcbiAgICBicm93bjogXCJhNTJhMmFcIixcbiAgICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gICAgYnVybnRzaWVubmE6IFwiZWE3ZTVkXCIsXG4gICAgY2FkZXRibHVlOiBcIjVmOWVhMFwiLFxuICAgIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG4gICAgY2hvY29sYXRlOiBcImQyNjkxZVwiLFxuICAgIGNvcmFsOiBcImZmN2Y1MFwiLFxuICAgIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuICAgIGNvcm5zaWxrOiBcImZmZjhkY1wiLFxuICAgIGNyaW1zb246IFwiZGMxNDNjXCIsXG4gICAgY3lhbjogXCIwZmZcIixcbiAgICBkYXJrYmx1ZTogXCIwMDAwOGJcIixcbiAgICBkYXJrY3lhbjogXCIwMDhiOGJcIixcbiAgICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuICAgIGRhcmtncmF5OiBcImE5YTlhOVwiLFxuICAgIGRhcmtncmVlbjogXCIwMDY0MDBcIixcbiAgICBkYXJrZ3JleTogXCJhOWE5YTlcIixcbiAgICBkYXJra2hha2k6IFwiYmRiNzZiXCIsXG4gICAgZGFya21hZ2VudGE6IFwiOGIwMDhiXCIsXG4gICAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG4gICAgZGFya29yYW5nZTogXCJmZjhjMDBcIixcbiAgICBkYXJrb3JjaGlkOiBcIjk5MzJjY1wiLFxuICAgIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG4gICAgZGFya3NhbG1vbjogXCJlOTk2N2FcIixcbiAgICBkYXJrc2VhZ3JlZW46IFwiOGZiYzhmXCIsXG4gICAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcbiAgICBkYXJrc2xhdGVncmF5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFwiMmY0ZjRmXCIsXG4gICAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcbiAgICBkYXJrdmlvbGV0OiBcIjk0MDBkM1wiLFxuICAgIGRlZXBwaW5rOiBcImZmMTQ5M1wiLFxuICAgIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuICAgIGRpbWdyYXk6IFwiNjk2OTY5XCIsXG4gICAgZGltZ3JleTogXCI2OTY5NjlcIixcbiAgICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuICAgIGZpcmVicmljazogXCJiMjIyMjJcIixcbiAgICBmbG9yYWx3aGl0ZTogXCJmZmZhZjBcIixcbiAgICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcbiAgICBmdWNoc2lhOiBcImYwZlwiLFxuICAgIGdhaW5zYm9ybzogXCJkY2RjZGNcIixcbiAgICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuICAgIGdvbGQ6IFwiZmZkNzAwXCIsXG4gICAgZ29sZGVucm9kOiBcImRhYTUyMFwiLFxuICAgIGdyYXk6IFwiODA4MDgwXCIsXG4gICAgZ3JlZW46IFwiMDA4MDAwXCIsXG4gICAgZ3JlZW55ZWxsb3c6IFwiYWRmZjJmXCIsXG4gICAgZ3JleTogXCI4MDgwODBcIixcbiAgICBob25leWRldzogXCJmMGZmZjBcIixcbiAgICBob3RwaW5rOiBcImZmNjliNFwiLFxuICAgIGluZGlhbnJlZDogXCJjZDVjNWNcIixcbiAgICBpbmRpZ286IFwiNGIwMDgyXCIsXG4gICAgaXZvcnk6IFwiZmZmZmYwXCIsXG4gICAga2hha2k6IFwiZjBlNjhjXCIsXG4gICAgbGF2ZW5kZXI6IFwiZTZlNmZhXCIsXG4gICAgbGF2ZW5kZXJibHVzaDogXCJmZmYwZjVcIixcbiAgICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG4gICAgbGVtb25jaGlmZm9uOiBcImZmZmFjZFwiLFxuICAgIGxpZ2h0Ymx1ZTogXCJhZGQ4ZTZcIixcbiAgICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuICAgIGxpZ2h0Y3lhbjogXCJlMGZmZmZcIixcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCJmYWZhZDJcIixcbiAgICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRncmVlbjogXCI5MGVlOTBcIixcbiAgICBsaWdodGdyZXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuICAgIGxpZ2h0c2FsbW9uOiBcImZmYTA3YVwiLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFwiMjBiMmFhXCIsXG4gICAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuICAgIGxpZ2h0eWVsbG93OiBcImZmZmZlMFwiLFxuICAgIGxpbWU6IFwiMGYwXCIsXG4gICAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuICAgIGxpbmVuOiBcImZhZjBlNlwiLFxuICAgIG1hZ2VudGE6IFwiZjBmXCIsXG4gICAgbWFyb29uOiBcIjgwMDAwMFwiLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFwiNjZjZGFhXCIsXG4gICAgbWVkaXVtYmx1ZTogXCIwMDAwY2RcIixcbiAgICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG4gICAgbWVkaXVtcHVycGxlOiBcIjkzNzBkYlwiLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBcIjNjYjM3MVwiLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogXCIwMGZhOWFcIixcbiAgICBtZWRpdW10dXJxdW9pc2U6IFwiNDhkMWNjXCIsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuICAgIG1pZG5pZ2h0Ymx1ZTogXCIxOTE5NzBcIixcbiAgICBtaW50Y3JlYW06IFwiZjVmZmZhXCIsXG4gICAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuICAgIG1vY2Nhc2luOiBcImZmZTRiNVwiLFxuICAgIG5hdmFqb3doaXRlOiBcImZmZGVhZFwiLFxuICAgIG5hdnk6IFwiMDAwMDgwXCIsXG4gICAgb2xkbGFjZTogXCJmZGY1ZTZcIixcbiAgICBvbGl2ZTogXCI4MDgwMDBcIixcbiAgICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG4gICAgb3JhbmdlOiBcImZmYTUwMFwiLFxuICAgIG9yYW5nZXJlZDogXCJmZjQ1MDBcIixcbiAgICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG4gICAgcGFsZWdvbGRlbnJvZDogXCJlZWU4YWFcIixcbiAgICBwYWxlZ3JlZW46IFwiOThmYjk4XCIsXG4gICAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcbiAgICBwYWxldmlvbGV0cmVkOiBcImRiNzA5M1wiLFxuICAgIHBhcGF5YXdoaXA6IFwiZmZlZmQ1XCIsXG4gICAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuICAgIHBlcnU6IFwiY2Q4NTNmXCIsXG4gICAgcGluazogXCJmZmMwY2JcIixcbiAgICBwbHVtOiBcImRkYTBkZFwiLFxuICAgIHBvd2RlcmJsdWU6IFwiYjBlMGU2XCIsXG4gICAgcHVycGxlOiBcIjgwMDA4MFwiLFxuICAgIHJlYmVjY2FwdXJwbGU6IFwiNjYzMzk5XCIsXG4gICAgcmVkOiBcImYwMFwiLFxuICAgIHJvc3licm93bjogXCJiYzhmOGZcIixcbiAgICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG4gICAgc2FkZGxlYnJvd246IFwiOGI0NTEzXCIsXG4gICAgc2FsbW9uOiBcImZhODA3MlwiLFxuICAgIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG4gICAgc2VhZ3JlZW46IFwiMmU4YjU3XCIsXG4gICAgc2Vhc2hlbGw6IFwiZmZmNWVlXCIsXG4gICAgc2llbm5hOiBcImEwNTIyZFwiLFxuICAgIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgICBza3libHVlOiBcIjg3Y2VlYlwiLFxuICAgIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcbiAgICBzbGF0ZWdyYXk6IFwiNzA4MDkwXCIsXG4gICAgc2xhdGVncmV5OiBcIjcwODA5MFwiLFxuICAgIHNub3c6IFwiZmZmYWZhXCIsXG4gICAgc3ByaW5nZ3JlZW46IFwiMDBmZjdmXCIsXG4gICAgc3RlZWxibHVlOiBcIjQ2ODJiNFwiLFxuICAgIHRhbjogXCJkMmI0OGNcIixcbiAgICB0ZWFsOiBcIjAwODA4MFwiLFxuICAgIHRoaXN0bGU6IFwiZDhiZmQ4XCIsXG4gICAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICAgIHR1cnF1b2lzZTogXCI0MGUwZDBcIixcbiAgICB2aW9sZXQ6IFwiZWU4MmVlXCIsXG4gICAgd2hlYXQ6IFwiZjVkZWIzXCIsXG4gICAgd2hpdGU6IFwiZmZmXCIsXG4gICAgd2hpdGVzbW9rZTogXCJmNWY1ZjVcIixcbiAgICB5ZWxsb3c6IFwiZmYwXCIsXG4gICAgeWVsbG93Z3JlZW46IFwiOWFjZDMyXCJcbn07XG5cbi8vIE1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgY29sb3JzIHZpYSBgaGV4TmFtZXNbaGV4XWBcbnZhciBoZXhOYW1lcyA9IHRpbnljb2xvci5oZXhOYW1lcyA9IGZsaXAobmFtZXMpO1xuXG5cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tXG5cbi8vIGB7ICduYW1lMSc6ICd2YWwxJyB9YCBiZWNvbWVzIGB7ICd2YWwxJzogJ25hbWUxJyB9YFxuZnVuY3Rpb24gZmxpcChvKSB7XG4gICAgdmFyIGZsaXBwZWQgPSB7IH07XG4gICAgZm9yICh2YXIgaSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBmbGlwcGVkW29baV1dID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZDtcbn1cblxuLy8gUmV0dXJuIGEgdmFsaWQgYWxwaGEgdmFsdWUgWzAsMV0gd2l0aCBhbGwgaW52YWxpZCB2YWx1ZXMgYmVpbmcgc2V0IHRvIDFcbmZ1bmN0aW9uIGJvdW5kQWxwaGEoYSkge1xuICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG4vLyBUYWtlIGlucHV0IGZyb20gWzAsIG5dIGFuZCByZXR1cm4gaXQgYXMgWzAsIDFdXG5mdW5jdGlvbiBib3VuZDAxKG4sIG1heCkge1xuICAgIGlmIChpc09uZVBvaW50WmVybyhuKSkgeyBuID0gXCIxMDAlXCI7IH1cblxuICAgIHZhciBwcm9jZXNzUGVyY2VudCA9IGlzUGVyY2VudGFnZShuKTtcbiAgICBuID0gbWF0aE1pbihtYXgsIG1hdGhNYXgoMCwgcGFyc2VGbG9hdChuKSkpO1xuXG4gICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IHBlcmNlbnRhZ2UgaW50byBudW1iZXJcbiAgICBpZiAocHJvY2Vzc1BlcmNlbnQpIHtcbiAgICAgICAgbiA9IHBhcnNlSW50KG4gKiBtYXgsIDEwKSAvIDEwMDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzXG4gICAgaWYgKChNYXRoLmFicyhuIC0gbWF4KSA8IDAuMDAwMDAxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gWzAsIDFdIHJhbmdlIGlmIGl0IGlzbid0IGFscmVhZHlcbiAgICByZXR1cm4gKG4gJSBtYXgpIC8gcGFyc2VGbG9hdChtYXgpO1xufVxuXG4vLyBGb3JjZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbmZ1bmN0aW9uIGNsYW1wMDEodmFsKSB7XG4gICAgcmV0dXJuIG1hdGhNaW4oMSwgbWF0aE1heCgwLCB2YWwpKTtcbn1cblxuLy8gUGFyc2UgYSBiYXNlLTE2IGhleCB2YWx1ZSBpbnRvIGEgYmFzZS0xMCBpbnRlZ2VyXG5mdW5jdGlvbiBwYXJzZUludEZyb21IZXgodmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTYpO1xufVxuXG4vLyBOZWVkIHRvIGhhbmRsZSAxLjAgYXMgMTAwJSwgc2luY2Ugb25jZSBpdCBpcyBhIG51bWJlciwgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGl0IGFuZCAxXG4vLyA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDIyMDcyL2phdmFzY3JpcHQtaG93LXRvLWRldGVjdC1udW1iZXItYXMtYS1kZWNpbWFsLWluY2x1ZGluZy0xLTA+XG5mdW5jdGlvbiBpc09uZVBvaW50WmVybyhuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCcuJykgIT0gLTEgJiYgcGFyc2VGbG9hdChuKSA9PT0gMTtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIHN0cmluZyBwYXNzZWQgaW4gaXMgYSBwZXJjZW50YWdlXG5mdW5jdGlvbiBpc1BlcmNlbnRhZ2Uobikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiAmJiBuLmluZGV4T2YoJyUnKSAhPSAtMTtcbn1cblxuLy8gRm9yY2UgYSBoZXggdmFsdWUgdG8gaGF2ZSAyIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBhZDIoYykge1xuICAgIHJldHVybiBjLmxlbmd0aCA9PSAxID8gJzAnICsgYyA6ICcnICsgYztcbn1cblxuLy8gUmVwbGFjZSBhIGRlY2ltYWwgd2l0aCBpdCdzIHBlcmNlbnRhZ2UgdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnRUb1BlcmNlbnRhZ2Uobikge1xuICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgbiA9IChuICogMTAwKSArIFwiJVwiO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG4vLyBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gYSBoZXggdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnREZWNpbWFsVG9IZXgoZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZCkgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIENvbnZlcnRzIGEgaGV4IHZhbHVlIHRvIGEgZGVjaW1hbFxuZnVuY3Rpb24gY29udmVydEhleFRvRGVjaW1hbChoKSB7XG4gICAgcmV0dXJuIChwYXJzZUludEZyb21IZXgoaCkgLyAyNTUpO1xufVxuXG52YXIgbWF0Y2hlcnMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI2ludGVnZXJzPlxuICAgIHZhciBDU1NfSU5URUdFUiA9IFwiWy1cXFxcK10/XFxcXGQrJT9cIjtcblxuICAgIC8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXZhbHVlcy8jbnVtYmVyLXZhbHVlPlxuICAgIHZhciBDU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG5cbiAgICAvLyBBbGxvdyBwb3NpdGl2ZS9uZWdhdGl2ZSBpbnRlZ2VyL251bWJlci4gIERvbid0IGNhcHR1cmUgdGhlIGVpdGhlci9vciwganVzdCB0aGUgZW50aXJlIG91dGNvbWUuXG4gICAgdmFyIENTU19VTklUID0gXCIoPzpcIiArIENTU19OVU1CRVIgKyBcIil8KD86XCIgKyBDU1NfSU5URUdFUiArIFwiKVwiO1xuXG4gICAgLy8gQWN0dWFsIG1hdGNoaW5nLlxuICAgIC8vIFBhcmVudGhlc2VzIGFuZCBjb21tYXMgYXJlIG9wdGlvbmFsLCBidXQgbm90IHJlcXVpcmVkLlxuICAgIC8vIFdoaXRlc3BhY2UgY2FuIHRha2UgdGhlIHBsYWNlIG9mIGNvbW1hcyBvciBvcGVuaW5nIHBhcmVuXG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0gzID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0g0ID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBDU1NfVU5JVDogbmV3IFJlZ0V4cChDU1NfVU5JVCksXG4gICAgICAgIHJnYjogbmV3IFJlZ0V4cChcInJnYlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICByZ2JhOiBuZXcgUmVnRXhwKFwicmdiYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoc2w6IG5ldyBSZWdFeHAoXCJoc2xcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgaHNsYTogbmV3IFJlZ0V4cChcImhzbGFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaHN2OiBuZXcgUmVnRXhwKFwiaHN2XCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIGhzdmE6IG5ldyBSZWdFeHAoXCJoc3ZhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhleDM6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICAgICAgaGV4NjogL14jPyhbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLFxuICAgICAgICBoZXg0OiAvXiM/KFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICBoZXg4OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvXG4gICAgfTtcbn0pKCk7XG5cbi8vIGBpc1ZhbGlkQ1NTVW5pdGBcbi8vIFRha2UgaW4gYSBzaW5nbGUgc3RyaW5nIC8gbnVtYmVyIGFuZCBjaGVjayB0byBzZWUgaWYgaXQgbG9va3MgbGlrZSBhIENTUyB1bml0XG4vLyAoc2VlIGBtYXRjaGVyc2AgYWJvdmUgZm9yIGRlZmluaXRpb24pLlxuZnVuY3Rpb24gaXNWYWxpZENTU1VuaXQoY29sb3IpIHtcbiAgICByZXR1cm4gISFtYXRjaGVycy5DU1NfVU5JVC5leGVjKGNvbG9yKTtcbn1cblxuLy8gYHN0cmluZ0lucHV0VG9PYmplY3RgXG4vLyBQZXJtaXNzaXZlIHN0cmluZyBwYXJzaW5nLiAgVGFrZSBpbiBhIG51bWJlciBvZiBmb3JtYXRzLCBhbmQgb3V0cHV0IGFuIG9iamVjdFxuLy8gYmFzZWQgb24gZGV0ZWN0ZWQgZm9ybWF0LiAgUmV0dXJucyBgeyByLCBnLCBiIH1gIG9yIGB7IGgsIHMsIGwgfWAgb3IgYHsgaCwgcywgdn1gXG5mdW5jdGlvbiBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKSB7XG5cbiAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UodHJpbUxlZnQsJycpLnJlcGxhY2UodHJpbVJpZ2h0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZWQgPSBmYWxzZTtcbiAgICBpZiAobmFtZXNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZXNbY29sb3JdO1xuICAgICAgICBuYW1lZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yID09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogMCwgZzogMCwgYjogMCwgYTogMCwgZm9ybWF0OiBcIm5hbWVcIiB9O1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtYXRjaCBzdHJpbmcgaW5wdXQgdXNpbmcgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAvLyBLZWVwIG1vc3Qgb2YgdGhlIG51bWJlciBib3VuZGluZyBvdXQgb2YgdGhpcyBmdW5jdGlvbiAtIGRvbid0IHdvcnJ5IGFib3V0IFswLDFdIG9yIFswLDEwMF0gb3IgWzAsMzYwXVxuICAgIC8vIEp1c3QgcmV0dXJuIGFuIG9iamVjdCBhbmQgbGV0IHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBoYW5kbGUgdGhhdC5cbiAgICAvLyBUaGlzIHdheSB0aGUgcmVzdWx0IHdpbGwgYmUgdGhlIHNhbWUgd2hldGhlciB0aGUgdGlueWNvbG9yIGlzIGluaXRpYWxpemVkIHdpdGggc3RyaW5nIG9yIG9iamVjdC5cbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2YS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSksXG4gICAgICAgICAgICBhOiBjb252ZXJ0SGV4VG9EZWNpbWFsKG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10gKyAnJyArIG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0gKyAnJyArIG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgJycgKyBtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0gKyAnJyArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXQ0FHMlBhcm1zKHBhcm1zKSB7XG4gICAgLy8gcmV0dXJuIHZhbGlkIFdDQUcyIHBhcm1zIGZvciBpc1JlYWRhYmxlLlxuICAgIC8vIElmIGlucHV0IHBhcm1zIGFyZSBpbnZhbGlkLCByZXR1cm4ge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn1cbiAgICB2YXIgbGV2ZWwsIHNpemU7XG4gICAgcGFybXMgPSBwYXJtcyB8fCB7XCJsZXZlbFwiOlwiQUFcIiwgXCJzaXplXCI6XCJzbWFsbFwifTtcbiAgICBsZXZlbCA9IChwYXJtcy5sZXZlbCB8fCBcIkFBXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgc2l6ZSA9IChwYXJtcy5zaXplIHx8IFwic21hbGxcIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGV2ZWwgIT09IFwiQUFcIiAmJiBsZXZlbCAhPT0gXCJBQUFcIikge1xuICAgICAgICBsZXZlbCA9IFwiQUFcIjtcbiAgICB9XG4gICAgaWYgKHNpemUgIT09IFwic21hbGxcIiAmJiBzaXplICE9PSBcImxhcmdlXCIpIHtcbiAgICAgICAgc2l6ZSA9IFwic21hbGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcImxldmVsXCI6bGV2ZWwsIFwic2l6ZVwiOnNpemV9O1xufVxuXG4vLyBOb2RlOiBFeHBvcnQgZnVuY3Rpb25cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW55Y29sb3I7XG59XG4vLyBBTUQvcmVxdWlyZWpzOiBEZWZpbmUgdGhlIG1vZHVsZVxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtyZXR1cm4gdGlueWNvbG9yO30pO1xufVxuLy8gQnJvd3NlcjogRXhwb3NlIHRvIHdpbmRvd1xuZWxzZSB7XG4gICAgd2luZG93LnRpbnljb2xvciA9IHRpbnljb2xvcjtcbn1cblxufSkoTWF0aCk7XG4iLCIvKiBXZWIgRm9udCBMb2FkZXIgdjEuNi4yOCAtIChjKSBBZG9iZSBTeXN0ZW1zLCBHb29nbGUuIExpY2Vuc2U6IEFwYWNoZSAyLjAgKi8oZnVuY3Rpb24oKXtmdW5jdGlvbiBhYShhLGIsYyl7cmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsYXJndW1lbnRzKX1mdW5jdGlvbiBiYShhLGIsYyl7aWYoIWEpdGhyb3cgRXJyb3IoKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0FycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsZCk7cmV0dXJuIGEuYXBwbHkoYixjKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBwKGEsYixjKXtwPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/YWE6YmE7cmV0dXJuIHAuYXBwbHkobnVsbCxhcmd1bWVudHMpfXZhciBxPURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX07ZnVuY3Rpb24gY2EoYSxiKXt0aGlzLmE9YTt0aGlzLm89Ynx8YTt0aGlzLmM9dGhpcy5vLmRvY3VtZW50fXZhciBkYT0hIXdpbmRvdy5Gb250RmFjZTtmdW5jdGlvbiB0KGEsYixjLGQpe2I9YS5jLmNyZWF0ZUVsZW1lbnQoYik7aWYoYylmb3IodmFyIGUgaW4gYyljLmhhc093blByb3BlcnR5KGUpJiYoXCJzdHlsZVwiPT1lP2Iuc3R5bGUuY3NzVGV4dD1jW2VdOmIuc2V0QXR0cmlidXRlKGUsY1tlXSkpO2QmJmIuYXBwZW5kQ2hpbGQoYS5jLmNyZWF0ZVRleHROb2RlKGQpKTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjKXthPWEuYy5nZXRFbGVtZW50c0J5VGFnTmFtZShiKVswXTthfHwoYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO2EuaW5zZXJ0QmVmb3JlKGMsYS5sYXN0Q2hpbGQpfWZ1bmN0aW9uIHYoYSl7YS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9XG5mdW5jdGlvbiB3KGEsYixjKXtiPWJ8fFtdO2M9Y3x8W107Zm9yKHZhciBkPWEuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyksZT0wO2U8Yi5sZW5ndGg7ZSs9MSl7Zm9yKHZhciBmPSExLGc9MDtnPGQubGVuZ3RoO2crPTEpaWYoYltlXT09PWRbZ10pe2Y9ITA7YnJlYWt9Znx8ZC5wdXNoKGJbZV0pfWI9W107Zm9yKGU9MDtlPGQubGVuZ3RoO2UrPTEpe2Y9ITE7Zm9yKGc9MDtnPGMubGVuZ3RoO2crPTEpaWYoZFtlXT09PWNbZ10pe2Y9ITA7YnJlYWt9Znx8Yi5wdXNoKGRbZV0pfWEuY2xhc3NOYW1lPWIuam9pbihcIiBcIikucmVwbGFjZSgvXFxzKy9nLFwiIFwiKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC8sXCJcIil9ZnVuY3Rpb24geShhLGIpe2Zvcih2YXIgYz1hLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspaWYoY1tkXT09YilyZXR1cm4hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIGVhKGEpe3JldHVybiBhLm8ubG9jYXRpb24uaG9zdG5hbWV8fGEuYS5sb2NhdGlvbi5ob3N0bmFtZX1mdW5jdGlvbiB6KGEsYixjKXtmdW5jdGlvbiBkKCl7bSYmZSYmZiYmKG0oZyksbT1udWxsKX1iPXQoYSxcImxpbmtcIix7cmVsOlwic3R5bGVzaGVldFwiLGhyZWY6YixtZWRpYTpcImFsbFwifSk7dmFyIGU9ITEsZj0hMCxnPW51bGwsbT1jfHxudWxsO2RhPyhiLm9ubG9hZD1mdW5jdGlvbigpe2U9ITA7ZCgpfSxiLm9uZXJyb3I9ZnVuY3Rpb24oKXtlPSEwO2c9RXJyb3IoXCJTdHlsZXNoZWV0IGZhaWxlZCB0byBsb2FkXCIpO2QoKX0pOnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlPSEwO2QoKX0sMCk7dShhLFwiaGVhZFwiLGIpfVxuZnVuY3Rpb24gQShhLGIsYyxkKXt2YXIgZT1hLmMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO2lmKGUpe3ZhciBmPXQoYSxcInNjcmlwdFwiLHtzcmM6Yn0pLGc9ITE7Zi5vbmxvYWQ9Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtnfHx0aGlzLnJlYWR5U3RhdGUmJlwibG9hZGVkXCIhPXRoaXMucmVhZHlTdGF0ZSYmXCJjb21wbGV0ZVwiIT10aGlzLnJlYWR5U3RhdGV8fChnPSEwLGMmJmMobnVsbCksZi5vbmxvYWQ9Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxcIkhFQURcIj09Zi5wYXJlbnROb2RlLnRhZ05hbWUmJmUucmVtb3ZlQ2hpbGQoZikpfTtlLmFwcGVuZENoaWxkKGYpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtnfHwoZz0hMCxjJiZjKEVycm9yKFwiU2NyaXB0IGxvYWQgdGltZW91dFwiKSkpfSxkfHw1RTMpO3JldHVybiBmfXJldHVybiBudWxsfTtmdW5jdGlvbiBCKCl7dGhpcy5hPTA7dGhpcy5jPW51bGx9ZnVuY3Rpb24gQyhhKXthLmErKztyZXR1cm4gZnVuY3Rpb24oKXthLmEtLTtEKGEpfX1mdW5jdGlvbiBFKGEsYil7YS5jPWI7RChhKX1mdW5jdGlvbiBEKGEpezA9PWEuYSYmYS5jJiYoYS5jKCksYS5jPW51bGwpfTtmdW5jdGlvbiBGKGEpe3RoaXMuYT1hfHxcIi1cIn1GLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTA7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliLnB1c2goYXJndW1lbnRzW2NdLnJlcGxhY2UoL1tcXFdfXSsvZyxcIlwiKS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gYi5qb2luKHRoaXMuYSl9O2Z1bmN0aW9uIEcoYSxiKXt0aGlzLmM9YTt0aGlzLmY9NDt0aGlzLmE9XCJuXCI7dmFyIGM9KGJ8fFwibjRcIikubWF0Y2goL14oW25pb10pKFsxLTldKSQvaSk7YyYmKHRoaXMuYT1jWzFdLHRoaXMuZj1wYXJzZUludChjWzJdLDEwKSl9ZnVuY3Rpb24gZmEoYSl7cmV0dXJuIEgoYSkrXCIgXCIrKGEuZitcIjAwXCIpK1wiIDMwMHB4IFwiK0koYS5jKX1mdW5jdGlvbiBJKGEpe3ZhciBiPVtdO2E9YS5zcGxpdCgvLFxccyovKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXS5yZXBsYWNlKC9bJ1wiXS9nLFwiXCIpOy0xIT1kLmluZGV4T2YoXCIgXCIpfHwvXlxcZC8udGVzdChkKT9iLnB1c2goXCInXCIrZCtcIidcIik6Yi5wdXNoKGQpfXJldHVybiBiLmpvaW4oXCIsXCIpfWZ1bmN0aW9uIEooYSl7cmV0dXJuIGEuYSthLmZ9ZnVuY3Rpb24gSChhKXt2YXIgYj1cIm5vcm1hbFwiO1wib1wiPT09YS5hP2I9XCJvYmxpcXVlXCI6XCJpXCI9PT1hLmEmJihiPVwiaXRhbGljXCIpO3JldHVybiBifVxuZnVuY3Rpb24gZ2EoYSl7dmFyIGI9NCxjPVwiblwiLGQ9bnVsbDthJiYoKGQ9YS5tYXRjaCgvKG5vcm1hbHxvYmxpcXVlfGl0YWxpYykvaSkpJiZkWzFdJiYoYz1kWzFdLnN1YnN0cigwLDEpLnRvTG93ZXJDYXNlKCkpLChkPWEubWF0Y2goLyhbMS05XTAwfG5vcm1hbHxib2xkKS9pKSkmJmRbMV0mJigvYm9sZC9pLnRlc3QoZFsxXSk/Yj03Oi9bMS05XTAwLy50ZXN0KGRbMV0pJiYoYj1wYXJzZUludChkWzFdLnN1YnN0cigwLDEpLDEwKSkpKTtyZXR1cm4gYytifTtmdW5jdGlvbiBoYShhLGIpe3RoaXMuYz1hO3RoaXMuZj1hLm8uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3RoaXMuaD1iO3RoaXMuYT1uZXcgRihcIi1cIik7dGhpcy5qPSExIT09Yi5ldmVudHM7dGhpcy5nPSExIT09Yi5jbGFzc2VzfWZ1bmN0aW9uIGlhKGEpe2EuZyYmdyhhLmYsW2EuYS5jKFwid2ZcIixcImxvYWRpbmdcIildKTtLKGEsXCJsb2FkaW5nXCIpfWZ1bmN0aW9uIEwoYSl7aWYoYS5nKXt2YXIgYj15KGEuZixhLmEuYyhcIndmXCIsXCJhY3RpdmVcIikpLGM9W10sZD1bYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKV07Ynx8Yy5wdXNoKGEuYS5jKFwid2ZcIixcImluYWN0aXZlXCIpKTt3KGEuZixjLGQpfUsoYSxcImluYWN0aXZlXCIpfWZ1bmN0aW9uIEsoYSxiLGMpe2lmKGEuaiYmYS5oW2JdKWlmKGMpYS5oW2JdKGMuYyxKKGMpKTtlbHNlIGEuaFtiXSgpfTtmdW5jdGlvbiBqYSgpe3RoaXMuYz17fX1mdW5jdGlvbiBrYShhLGIsYyl7dmFyIGQ9W10sZTtmb3IoZSBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoZSkpe3ZhciBmPWEuY1tlXTtmJiZkLnB1c2goZihiW2VdLGMpKX1yZXR1cm4gZH07ZnVuY3Rpb24gTShhLGIpe3RoaXMuYz1hO3RoaXMuZj1iO3RoaXMuYT10KHRoaXMuYyxcInNwYW5cIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSx0aGlzLmYpfWZ1bmN0aW9uIE4oYSl7dShhLmMsXCJib2R5XCIsYS5hKX1mdW5jdGlvbiBPKGEpe3JldHVyblwiZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTk5OTlweDtsZWZ0Oi05OTk5cHg7Zm9udC1zaXplOjMwMHB4O3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87bGluZS1oZWlnaHQ6bm9ybWFsO21hcmdpbjowO3BhZGRpbmc6MDtmb250LXZhcmlhbnQ6bm9ybWFsO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpcIitJKGEuYykrXCI7XCIrKFwiZm9udC1zdHlsZTpcIitIKGEpK1wiO2ZvbnQtd2VpZ2h0OlwiKyhhLmYrXCIwMFwiKStcIjtcIil9O2Z1bmN0aW9uIFAoYSxiLGMsZCxlLGYpe3RoaXMuZz1hO3RoaXMuaj1iO3RoaXMuYT1kO3RoaXMuYz1jO3RoaXMuZj1lfHwzRTM7dGhpcy5oPWZ8fHZvaWQgMH1QLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYy5vLmRvY3VtZW50LGI9dGhpcyxjPXEoKSxkPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gZigpe3EoKS1jPj1iLmY/ZSgpOmEuZm9udHMubG9hZChmYShiLmEpLGIuaCkudGhlbihmdW5jdGlvbihhKXsxPD1hLmxlbmd0aD9kKCk6c2V0VGltZW91dChmLDI1KX0sZnVuY3Rpb24oKXtlKCl9KX1mKCl9KSxlPW51bGwsZj1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGQpe2U9c2V0VGltZW91dChkLGIuZil9KTtQcm9taXNlLnJhY2UoW2YsZF0pLnRoZW4oZnVuY3Rpb24oKXtlJiYoY2xlYXJUaW1lb3V0KGUpLGU9bnVsbCk7Yi5nKGIuYSl9LGZ1bmN0aW9uKCl7Yi5qKGIuYSl9KX07ZnVuY3Rpb24gUShhLGIsYyxkLGUsZixnKXt0aGlzLnY9YTt0aGlzLkI9Yjt0aGlzLmM9Yzt0aGlzLmE9ZDt0aGlzLnM9Z3x8XCJCRVNic3d5XCI7dGhpcy5mPXt9O3RoaXMudz1lfHwzRTM7dGhpcy51PWZ8fG51bGw7dGhpcy5tPXRoaXMuaj10aGlzLmg9dGhpcy5nPW51bGw7dGhpcy5nPW5ldyBNKHRoaXMuYyx0aGlzLnMpO3RoaXMuaD1uZXcgTSh0aGlzLmMsdGhpcy5zKTt0aGlzLmo9bmV3IE0odGhpcy5jLHRoaXMucyk7dGhpcy5tPW5ldyBNKHRoaXMuYyx0aGlzLnMpO2E9bmV3IEcodGhpcy5hLmMrXCIsc2VyaWZcIixKKHRoaXMuYSkpO2E9TyhhKTt0aGlzLmcuYS5zdHlsZS5jc3NUZXh0PWE7YT1uZXcgRyh0aGlzLmEuYytcIixzYW5zLXNlcmlmXCIsSih0aGlzLmEpKTthPU8oYSk7dGhpcy5oLmEuc3R5bGUuY3NzVGV4dD1hO2E9bmV3IEcoXCJzZXJpZlwiLEoodGhpcy5hKSk7YT1PKGEpO3RoaXMuai5hLnN0eWxlLmNzc1RleHQ9YTthPW5ldyBHKFwic2Fucy1zZXJpZlwiLEoodGhpcy5hKSk7YT1cbk8oYSk7dGhpcy5tLmEuc3R5bGUuY3NzVGV4dD1hO04odGhpcy5nKTtOKHRoaXMuaCk7Tih0aGlzLmopO04odGhpcy5tKX12YXIgUj17RDpcInNlcmlmXCIsQzpcInNhbnMtc2VyaWZcIn0sUz1udWxsO2Z1bmN0aW9uIFQoKXtpZihudWxsPT09Uyl7dmFyIGE9L0FwcGxlV2ViS2l0XFwvKFswLTldKykoPzpcXC4oWzAtOV0rKSkvLmV4ZWMod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1M9ISFhJiYoNTM2PnBhcnNlSW50KGFbMV0sMTApfHw1MzY9PT1wYXJzZUludChhWzFdLDEwKSYmMTE+PXBhcnNlSW50KGFbMl0sMTApKX1yZXR1cm4gU31RLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3RoaXMuZi5zZXJpZj10aGlzLmouYS5vZmZzZXRXaWR0aDt0aGlzLmZbXCJzYW5zLXNlcmlmXCJdPXRoaXMubS5hLm9mZnNldFdpZHRoO3RoaXMuQT1xKCk7VSh0aGlzKX07XG5mdW5jdGlvbiBsYShhLGIsYyl7Zm9yKHZhciBkIGluIFIpaWYoUi5oYXNPd25Qcm9wZXJ0eShkKSYmYj09PWEuZltSW2RdXSYmYz09PWEuZltSW2RdXSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBVKGEpe3ZhciBiPWEuZy5hLm9mZnNldFdpZHRoLGM9YS5oLmEub2Zmc2V0V2lkdGgsZDsoZD1iPT09YS5mLnNlcmlmJiZjPT09YS5mW1wic2Fucy1zZXJpZlwiXSl8fChkPVQoKSYmbGEoYSxiLGMpKTtkP3EoKS1hLkE+PWEudz9UKCkmJmxhKGEsYixjKSYmKG51bGw9PT1hLnV8fGEudS5oYXNPd25Qcm9wZXJ0eShhLmEuYykpP1YoYSxhLnYpOlYoYSxhLkIpOm1hKGEpOlYoYSxhLnYpfWZ1bmN0aW9uIG1hKGEpe3NldFRpbWVvdXQocChmdW5jdGlvbigpe1UodGhpcyl9LGEpLDUwKX1mdW5jdGlvbiBWKGEsYil7c2V0VGltZW91dChwKGZ1bmN0aW9uKCl7dih0aGlzLmcuYSk7dih0aGlzLmguYSk7dih0aGlzLmouYSk7dih0aGlzLm0uYSk7Yih0aGlzLmEpfSxhKSwwKX07ZnVuY3Rpb24gVyhhLGIsYyl7dGhpcy5jPWE7dGhpcy5hPWI7dGhpcy5mPTA7dGhpcy5tPXRoaXMuaj0hMTt0aGlzLnM9Y312YXIgWD1udWxsO1cucHJvdG90eXBlLmc9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hO2IuZyYmdyhiLmYsW2IuYS5jKFwid2ZcIixhLmMsSihhKS50b1N0cmluZygpLFwiYWN0aXZlXCIpXSxbYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJsb2FkaW5nXCIpLGIuYS5jKFwid2ZcIixhLmMsSihhKS50b1N0cmluZygpLFwiaW5hY3RpdmVcIildKTtLKGIsXCJmb250YWN0aXZlXCIsYSk7dGhpcy5tPSEwO25hKHRoaXMpfTtcblcucHJvdG90eXBlLmg9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hO2lmKGIuZyl7dmFyIGM9eShiLmYsYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJhY3RpdmVcIikpLGQ9W10sZT1bYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJsb2FkaW5nXCIpXTtjfHxkLnB1c2goYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJpbmFjdGl2ZVwiKSk7dyhiLmYsZCxlKX1LKGIsXCJmb250aW5hY3RpdmVcIixhKTtuYSh0aGlzKX07ZnVuY3Rpb24gbmEoYSl7MD09LS1hLmYmJmEuaiYmKGEubT8oYT1hLmEsYS5nJiZ3KGEuZixbYS5hLmMoXCJ3ZlwiLFwiYWN0aXZlXCIpXSxbYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKSxhLmEuYyhcIndmXCIsXCJpbmFjdGl2ZVwiKV0pLEsoYSxcImFjdGl2ZVwiKSk6TChhLmEpKX07ZnVuY3Rpb24gb2EoYSl7dGhpcy5qPWE7dGhpcy5hPW5ldyBqYTt0aGlzLmg9MDt0aGlzLmY9dGhpcy5nPSEwfW9hLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3RoaXMuYz1uZXcgY2EodGhpcy5qLGEuY29udGV4dHx8dGhpcy5qKTt0aGlzLmc9ITEhPT1hLmV2ZW50czt0aGlzLmY9ITEhPT1hLmNsYXNzZXM7cGEodGhpcyxuZXcgaGEodGhpcy5jLGEpLGEpfTtcbmZ1bmN0aW9uIHFhKGEsYixjLGQsZSl7dmFyIGY9MD09LS1hLmg7KGEuZnx8YS5nKSYmc2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBhPWV8fG51bGwsbT1kfHxudWxsfHx7fTtpZigwPT09Yy5sZW5ndGgmJmYpTChiLmEpO2Vsc2V7Yi5mKz1jLmxlbmd0aDtmJiYoYi5qPWYpO3ZhciBoLGw9W107Zm9yKGg9MDtoPGMubGVuZ3RoO2grKyl7dmFyIGs9Y1toXSxuPW1bay5jXSxyPWIuYSx4PWs7ci5nJiZ3KHIuZixbci5hLmMoXCJ3ZlwiLHguYyxKKHgpLnRvU3RyaW5nKCksXCJsb2FkaW5nXCIpXSk7SyhyLFwiZm9udGxvYWRpbmdcIix4KTtyPW51bGw7aWYobnVsbD09PVgpaWYod2luZG93LkZvbnRGYWNlKXt2YXIgeD0vR2Vja28uKkZpcmVmb3hcXC8oXFxkKykvLmV4ZWMod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLHhhPS9PUyBYLipWZXJzaW9uXFwvMTBcXC4uKlNhZmFyaS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9BcHBsZS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnZlbmRvcik7XG5YPXg/NDI8cGFyc2VJbnQoeFsxXSwxMCk6eGE/ITE6ITB9ZWxzZSBYPSExO1g/cj1uZXcgUChwKGIuZyxiKSxwKGIuaCxiKSxiLmMsayxiLnMsbik6cj1uZXcgUShwKGIuZyxiKSxwKGIuaCxiKSxiLmMsayxiLnMsYSxuKTtsLnB1c2gocil9Zm9yKGg9MDtoPGwubGVuZ3RoO2grKylsW2hdLnN0YXJ0KCl9fSwwKX1mdW5jdGlvbiBwYShhLGIsYyl7dmFyIGQ9W10sZT1jLnRpbWVvdXQ7aWEoYik7dmFyIGQ9a2EoYS5hLGMsYS5jKSxmPW5ldyBXKGEuYyxiLGUpO2EuaD1kLmxlbmd0aDtiPTA7Zm9yKGM9ZC5sZW5ndGg7YjxjO2IrKylkW2JdLmxvYWQoZnVuY3Rpb24oYixkLGMpe3FhKGEsZixiLGQsYyl9KX07ZnVuY3Rpb24gcmEoYSxiKXt0aGlzLmM9YTt0aGlzLmE9Yn1cbnJhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtpZihmW1wiX19tdGlfZm50THN0XCIrZF0pe3ZhciBjPWZbXCJfX210aV9mbnRMc3RcIitkXSgpLGU9W10saDtpZihjKWZvcih2YXIgbD0wO2w8Yy5sZW5ndGg7bCsrKXt2YXIgaz1jW2xdLmZvbnRmYW1pbHk7dm9pZCAwIT1jW2xdLmZvbnRTdHlsZSYmdm9pZCAwIT1jW2xdLmZvbnRXZWlnaHQ/KGg9Y1tsXS5mb250U3R5bGUrY1tsXS5mb250V2VpZ2h0LGUucHVzaChuZXcgRyhrLGgpKSk6ZS5wdXNoKG5ldyBHKGspKX1hKGUpfWVsc2Ugc2V0VGltZW91dChmdW5jdGlvbigpe2IoKX0sNTApfXZhciBjPXRoaXMsZD1jLmEucHJvamVjdElkLGU9Yy5hLnZlcnNpb247aWYoZCl7dmFyIGY9Yy5jLm87QSh0aGlzLmMsKGMuYS5hcGl8fFwiaHR0cHM6Ly9mYXN0LmZvbnRzLm5ldC9qc2FwaVwiKStcIi9cIitkK1wiLmpzXCIrKGU/XCI/dj1cIitlOlwiXCIpLGZ1bmN0aW9uKGUpe2U/YShbXSk6KGZbXCJfX01vbm90eXBlQ29uZmlndXJhdGlvbl9fXCIrXG5kXT1mdW5jdGlvbigpe3JldHVybiBjLmF9LGIoKSl9KS5pZD1cIl9fTW9ub3R5cGVBUElTY3JpcHRfX1wiK2R9ZWxzZSBhKFtdKX07ZnVuY3Rpb24gc2EoYSxiKXt0aGlzLmM9YTt0aGlzLmE9Yn1zYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXt2YXIgYixjLGQ9dGhpcy5hLnVybHN8fFtdLGU9dGhpcy5hLmZhbWlsaWVzfHxbXSxmPXRoaXMuYS50ZXN0U3RyaW5nc3x8e30sZz1uZXcgQjtiPTA7Zm9yKGM9ZC5sZW5ndGg7YjxjO2IrKyl6KHRoaXMuYyxkW2JdLEMoZykpO3ZhciBtPVtdO2I9MDtmb3IoYz1lLmxlbmd0aDtiPGM7YisrKWlmKGQ9ZVtiXS5zcGxpdChcIjpcIiksZFsxXSlmb3IodmFyIGg9ZFsxXS5zcGxpdChcIixcIiksbD0wO2w8aC5sZW5ndGg7bCs9MSltLnB1c2gobmV3IEcoZFswXSxoW2xdKSk7ZWxzZSBtLnB1c2gobmV3IEcoZFswXSkpO0UoZyxmdW5jdGlvbigpe2EobSxmKX0pfTtmdW5jdGlvbiB0YShhLGIpe2E/dGhpcy5jPWE6dGhpcy5jPXVhO3RoaXMuYT1bXTt0aGlzLmY9W107dGhpcy5nPWJ8fFwiXCJ9dmFyIHVhPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3NcIjtmdW5jdGlvbiB2YShhLGIpe2Zvcih2YXIgYz1iLmxlbmd0aCxkPTA7ZDxjO2QrKyl7dmFyIGU9YltkXS5zcGxpdChcIjpcIik7Mz09ZS5sZW5ndGgmJmEuZi5wdXNoKGUucG9wKCkpO3ZhciBmPVwiXCI7Mj09ZS5sZW5ndGgmJlwiXCIhPWVbMV0mJihmPVwiOlwiKTthLmEucHVzaChlLmpvaW4oZikpfX1cbmZ1bmN0aW9uIHdhKGEpe2lmKDA9PWEuYS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJObyBmb250cyB0byBsb2FkIVwiKTtpZigtMSE9YS5jLmluZGV4T2YoXCJraXQ9XCIpKXJldHVybiBhLmM7Zm9yKHZhciBiPWEuYS5sZW5ndGgsYz1bXSxkPTA7ZDxiO2QrKyljLnB1c2goYS5hW2RdLnJlcGxhY2UoLyAvZyxcIitcIikpO2I9YS5jK1wiP2ZhbWlseT1cIitjLmpvaW4oXCIlN0NcIik7MDxhLmYubGVuZ3RoJiYoYis9XCImc3Vic2V0PVwiK2EuZi5qb2luKFwiLFwiKSk7MDxhLmcubGVuZ3RoJiYoYis9XCImdGV4dD1cIitlbmNvZGVVUklDb21wb25lbnQoYS5nKSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIHlhKGEpe3RoaXMuZj1hO3RoaXMuYT1bXTt0aGlzLmM9e319XG52YXIgemE9e2xhdGluOlwiQkVTYnN3eVwiLFwibGF0aW4tZXh0XCI6XCJcXHUwMGU3XFx1MDBmNlxcdTAwZmNcXHUwMTFmXFx1MDE1ZlwiLGN5cmlsbGljOlwiXFx1MDQzOVxcdTA0NGZcXHUwNDE2XCIsZ3JlZWs6XCJcXHUwM2IxXFx1MDNiMlxcdTAzYTNcIixraG1lcjpcIlxcdTE3ODBcXHUxNzgxXFx1MTc4MlwiLEhhbnVtYW46XCJcXHUxNzgwXFx1MTc4MVxcdTE3ODJcIn0sQWE9e3RoaW46XCIxXCIsZXh0cmFsaWdodDpcIjJcIixcImV4dHJhLWxpZ2h0XCI6XCIyXCIsdWx0cmFsaWdodDpcIjJcIixcInVsdHJhLWxpZ2h0XCI6XCIyXCIsbGlnaHQ6XCIzXCIscmVndWxhcjpcIjRcIixib29rOlwiNFwiLG1lZGl1bTpcIjVcIixcInNlbWktYm9sZFwiOlwiNlwiLHNlbWlib2xkOlwiNlwiLFwiZGVtaS1ib2xkXCI6XCI2XCIsZGVtaWJvbGQ6XCI2XCIsYm9sZDpcIjdcIixcImV4dHJhLWJvbGRcIjpcIjhcIixleHRyYWJvbGQ6XCI4XCIsXCJ1bHRyYS1ib2xkXCI6XCI4XCIsdWx0cmFib2xkOlwiOFwiLGJsYWNrOlwiOVwiLGhlYXZ5OlwiOVwiLGw6XCIzXCIscjpcIjRcIixiOlwiN1wifSxCYT17aTpcImlcIixpdGFsaWM6XCJpXCIsbjpcIm5cIixub3JtYWw6XCJuXCJ9LFxuQ2E9L14odGhpbnwoPzooPzpleHRyYXx1bHRyYSktPyk/bGlnaHR8cmVndWxhcnxib29rfG1lZGl1bXwoPzooPzpzZW1pfGRlbWl8ZXh0cmF8dWx0cmEpLT8pP2JvbGR8YmxhY2t8aGVhdnl8bHxyfGJ8WzEtOV0wMCk/KG58aXxub3JtYWx8aXRhbGljKT8kLztcbmZ1bmN0aW9uIERhKGEpe2Zvcih2YXIgYj1hLmYubGVuZ3RoLGM9MDtjPGI7YysrKXt2YXIgZD1hLmZbY10uc3BsaXQoXCI6XCIpLGU9ZFswXS5yZXBsYWNlKC9cXCsvZyxcIiBcIiksZj1bXCJuNFwiXTtpZigyPD1kLmxlbmd0aCl7dmFyIGc7dmFyIG09ZFsxXTtnPVtdO2lmKG0pZm9yKHZhciBtPW0uc3BsaXQoXCIsXCIpLGg9bS5sZW5ndGgsbD0wO2w8aDtsKyspe3ZhciBrO2s9bVtsXTtpZihrLm1hdGNoKC9eW1xcdy1dKyQvKSl7dmFyIG49Q2EuZXhlYyhrLnRvTG93ZXJDYXNlKCkpO2lmKG51bGw9PW4paz1cIlwiO2Vsc2V7az1uWzJdO2s9bnVsbD09a3x8XCJcIj09az9cIm5cIjpCYVtrXTtuPW5bMV07aWYobnVsbD09bnx8XCJcIj09biluPVwiNFwiO2Vsc2UgdmFyIHI9QWFbbl0sbj1yP3I6aXNOYU4obik/XCI0XCI6bi5zdWJzdHIoMCwxKTtrPVtrLG5dLmpvaW4oXCJcIil9fWVsc2Ugaz1cIlwiO2smJmcucHVzaChrKX0wPGcubGVuZ3RoJiYoZj1nKTszPT1kLmxlbmd0aCYmKGQ9ZFsyXSxnPVtdLGQ9ZD9kLnNwbGl0KFwiLFwiKTpcbmcsMDxkLmxlbmd0aCYmKGQ9emFbZFswXV0pJiYoYS5jW2VdPWQpKX1hLmNbZV18fChkPXphW2VdKSYmKGEuY1tlXT1kKTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCs9MSlhLmEucHVzaChuZXcgRyhlLGZbZF0pKX19O2Z1bmN0aW9uIEVhKGEsYil7dGhpcy5jPWE7dGhpcy5hPWJ9dmFyIEZhPXtBcmltbzohMCxDb3VzaW5lOiEwLFRpbm9zOiEwfTtFYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgQixjPXRoaXMuYyxkPW5ldyB0YSh0aGlzLmEuYXBpLHRoaXMuYS50ZXh0KSxlPXRoaXMuYS5mYW1pbGllczt2YShkLGUpO3ZhciBmPW5ldyB5YShlKTtEYShmKTt6KGMsd2EoZCksQyhiKSk7RShiLGZ1bmN0aW9uKCl7YShmLmEsZi5jLEZhKX0pfTtmdW5jdGlvbiBHYShhLGIpe3RoaXMuYz1hO3RoaXMuYT1ifUdhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYS5pZCxjPXRoaXMuYy5vO2I/QSh0aGlzLmMsKHRoaXMuYS5hcGl8fFwiaHR0cHM6Ly91c2UudHlwZWtpdC5uZXRcIikrXCIvXCIrYitcIi5qc1wiLGZ1bmN0aW9uKGIpe2lmKGIpYShbXSk7ZWxzZSBpZihjLlR5cGVraXQmJmMuVHlwZWtpdC5jb25maWcmJmMuVHlwZWtpdC5jb25maWcuZm4pe2I9Yy5UeXBla2l0LmNvbmZpZy5mbjtmb3IodmFyIGU9W10sZj0wO2Y8Yi5sZW5ndGg7Zis9Milmb3IodmFyIGc9YltmXSxtPWJbZisxXSxoPTA7aDxtLmxlbmd0aDtoKyspZS5wdXNoKG5ldyBHKGcsbVtoXSkpO3RyeXtjLlR5cGVraXQubG9hZCh7ZXZlbnRzOiExLGNsYXNzZXM6ITEsYXN5bmM6ITB9KX1jYXRjaChsKXt9YShlKX19LDJFMyk6YShbXSl9O2Z1bmN0aW9uIEhhKGEsYil7dGhpcy5jPWE7dGhpcy5mPWI7dGhpcy5hPVtdfUhhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZi5pZCxjPXRoaXMuYy5vLGQ9dGhpcztiPyhjLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX198fChjLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX189e30pLGMuX193ZWJmb250Zm9udGRlY2ttb2R1bGVfX1tiXT1mdW5jdGlvbihiLGMpe2Zvcih2YXIgZz0wLG09Yy5mb250cy5sZW5ndGg7ZzxtOysrZyl7dmFyIGg9Yy5mb250c1tnXTtkLmEucHVzaChuZXcgRyhoLm5hbWUsZ2EoXCJmb250LXdlaWdodDpcIitoLndlaWdodCtcIjtmb250LXN0eWxlOlwiK2guc3R5bGUpKSl9YShkLmEpfSxBKHRoaXMuYywodGhpcy5mLmFwaXx8XCJodHRwczovL2YuZm9udGRlY2suY29tL3MvY3NzL2pzL1wiKStlYSh0aGlzLmMpK1wiL1wiK2IrXCIuanNcIixmdW5jdGlvbihiKXtiJiZhKFtdKX0pKTphKFtdKX07dmFyIFk9bmV3IG9hKHdpbmRvdyk7WS5hLmMuY3VzdG9tPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBzYShiLGEpfTtZLmEuYy5mb250ZGVjaz1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgSGEoYixhKX07WS5hLmMubW9ub3R5cGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IHJhKGIsYSl9O1kuYS5jLnR5cGVraXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IEdhKGIsYSl9O1kuYS5jLmdvb2dsZT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgRWEoYixhKX07dmFyIFo9e2xvYWQ6cChZLmxvYWQsWSl9O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIFp9KTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9Wjood2luZG93LldlYkZvbnQ9Wix3aW5kb3cuV2ViRm9udENvbmZpZyYmWS5sb2FkKHdpbmRvdy5XZWJGb250Q29uZmlnKSk7fSgpKTtcbiIsIlxudmFyIHppcCA9IHJlcXVpcmUoJ3ppcCcpO1xuXG5mdW5jdGlvbiBjcmVhdGVVcmwoc3JjKXtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XG4gIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG52YXIgeldvcmtlciA9IGNyZWF0ZVVybChcIi8qIGpzaGludCB3b3JrZXI6dHJ1ZSAqL1xcbihmdW5jdGlvbiBtYWluKGdsb2JhbCkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRpZiAoZ2xvYmFsLnpXb3JrZXJJbml0aWFsaXplZClcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoJ3otd29ya2VyLmpzIHNob3VsZCBiZSBydW4gb25seSBvbmNlJyk7XFxuXFx0Z2xvYmFsLnpXb3JrZXJJbml0aWFsaXplZCA9IHRydWU7XFxuXFxuXFx0YWRkRXZlbnRMaXN0ZW5lcihcXFwibWVzc2FnZVxcXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0dmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhLCB0eXBlID0gbWVzc2FnZS50eXBlLCBzbiA9IG1lc3NhZ2Uuc247XFxuXFx0XFx0dmFyIGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXTtcXG5cXHRcXHRpZiAoaGFuZGxlcikge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcihtZXNzYWdlKTtcXG5cXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0b25FcnJvcih0eXBlLCBzbiwgZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHQvL2ZvciBkZWJ1Z1xcblxcdFxcdC8vcG9zdE1lc3NhZ2Uoe3R5cGU6ICdlY2hvJywgb3JpZ2luYWxUeXBlOiB0eXBlLCBzbjogc259KTtcXG5cXHR9KTtcXG5cXG5cXHR2YXIgaGFuZGxlcnMgPSB7XFxuXFx0XFx0aW1wb3J0U2NyaXB0czogZG9JbXBvcnRTY3JpcHRzLFxcblxcdFxcdG5ld1Rhc2s6IG5ld1Rhc2ssXFxuXFx0XFx0YXBwZW5kOiBwcm9jZXNzRGF0YSxcXG5cXHRcXHRmbHVzaDogcHJvY2Vzc0RhdGEsXFxuXFx0fTtcXG5cXG5cXHQvLyBkZWZsYXRlci9pbmZsYXRlciB0YXNrcyBpbmRleGVkIGJ5IHNlcmlhbCBudW1iZXJzXFxuXFx0dmFyIHRhc2tzID0ge307XFxuXFxuXFx0ZnVuY3Rpb24gZG9JbXBvcnRTY3JpcHRzKG1zZykge1xcblxcdFxcdGlmIChtc2cuc2NyaXB0cyAmJiBtc2cuc2NyaXB0cy5sZW5ndGggPiAwKVxcblxcdFxcdFxcdGltcG9ydFNjcmlwdHMuYXBwbHkodW5kZWZpbmVkLCBtc2cuc2NyaXB0cyk7XFxuXFx0XFx0cG9zdE1lc3NhZ2Uoe3R5cGU6ICdpbXBvcnRTY3JpcHRzJ30pO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBuZXdUYXNrKG1zZykge1xcblxcdFxcdHZhciBDb2RlY0NsYXNzID0gZ2xvYmFsW21zZy5jb2RlY0NsYXNzXTtcXG5cXHRcXHR2YXIgc24gPSBtc2cuc247XFxuXFx0XFx0aWYgKHRhc2tzW3NuXSlcXG5cXHRcXHRcXHR0aHJvdyBFcnJvcignZHVwbGljYXRlZCBzbicpO1xcblxcdFxcdHRhc2tzW3NuXSA9ICB7XFxuXFx0XFx0XFx0Y29kZWM6IG5ldyBDb2RlY0NsYXNzKG1zZy5vcHRpb25zKSxcXG5cXHRcXHRcXHRjcmNJbnB1dDogbXNnLmNyY1R5cGUgPT09ICdpbnB1dCcsXFxuXFx0XFx0XFx0Y3JjT3V0cHV0OiBtc2cuY3JjVHlwZSA9PT0gJ291dHB1dCcsXFxuXFx0XFx0XFx0Y3JjOiBuZXcgQ3JjMzIoKSxcXG5cXHRcXHR9O1xcblxcdFxcdHBvc3RNZXNzYWdlKHt0eXBlOiAnbmV3VGFzaycsIHNuOiBzbn0pO1xcblxcdH1cXG5cXG5cXHQvLyBwZXJmb3JtYW5jZSBtYXkgbm90IGJlIHN1cHBvcnRlZFxcblxcdHZhciBub3cgPSBnbG9iYWwucGVyZm9ybWFuY2UgPyBnbG9iYWwucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsLnBlcmZvcm1hbmNlKSA6IERhdGUubm93O1xcblxcblxcdGZ1bmN0aW9uIHByb2Nlc3NEYXRhKG1zZykge1xcblxcdFxcdHZhciBzbiA9IG1zZy5zbiwgdHlwZSA9IG1zZy50eXBlLCBpbnB1dCA9IG1zZy5kYXRhO1xcblxcdFxcdHZhciB0YXNrID0gdGFza3Nbc25dO1xcblxcdFxcdC8vIGFsbG93IGNyZWF0aW5nIGNvZGVjIG9uIGZpcnN0IGFwcGVuZFxcblxcdFxcdGlmICghdGFzayAmJiBtc2cuY29kZWNDbGFzcykge1xcblxcdFxcdFxcdG5ld1Rhc2sobXNnKTtcXG5cXHRcXHRcXHR0YXNrID0gdGFza3Nbc25dO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgaXNBcHBlbmQgPSB0eXBlID09PSAnYXBwZW5kJztcXG5cXHRcXHR2YXIgc3RhcnQgPSBub3coKTtcXG5cXHRcXHR2YXIgb3V0cHV0O1xcblxcdFxcdGlmIChpc0FwcGVuZCkge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0b3V0cHV0ID0gdGFzay5jb2RlYy5hcHBlbmQoaW5wdXQsIGZ1bmN0aW9uIG9ucHJvZ3Jlc3MobG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zdE1lc3NhZ2Uoe3R5cGU6ICdwcm9ncmVzcycsIHNuOiBzbiwgbG9hZGVkOiBsb2FkZWR9KTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHRhc2tzW3NuXTtcXG5cXHRcXHRcXHRcXHR0aHJvdyBlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRlbGV0ZSB0YXNrc1tzbl07XFxuXFx0XFx0XFx0b3V0cHV0ID0gdGFzay5jb2RlYy5mbHVzaCgpO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgY29kZWNUaW1lID0gbm93KCkgLSBzdGFydDtcXG5cXG5cXHRcXHRzdGFydCA9IG5vdygpO1xcblxcdFxcdGlmIChpbnB1dCAmJiB0YXNrLmNyY0lucHV0KVxcblxcdFxcdFxcdHRhc2suY3JjLmFwcGVuZChpbnB1dCk7XFxuXFx0XFx0aWYgKG91dHB1dCAmJiB0YXNrLmNyY091dHB1dClcXG5cXHRcXHRcXHR0YXNrLmNyYy5hcHBlbmQob3V0cHV0KTtcXG5cXHRcXHR2YXIgY3JjVGltZSA9IG5vdygpIC0gc3RhcnQ7XFxuXFxuXFx0XFx0dmFyIHJtc2cgPSB7dHlwZTogdHlwZSwgc246IHNuLCBjb2RlY1RpbWU6IGNvZGVjVGltZSwgY3JjVGltZTogY3JjVGltZX07XFxuXFx0XFx0dmFyIHRyYW5zZmVyYWJsZXMgPSBbXTtcXG5cXHRcXHRpZiAob3V0cHV0KSB7XFxuXFx0XFx0XFx0cm1zZy5kYXRhID0gb3V0cHV0O1xcblxcdFxcdFxcdHRyYW5zZmVyYWJsZXMucHVzaChvdXRwdXQuYnVmZmVyKTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCFpc0FwcGVuZCAmJiAodGFzay5jcmNJbnB1dCB8fCB0YXNrLmNyY091dHB1dCkpXFxuXFx0XFx0XFx0cm1zZy5jcmMgPSB0YXNrLmNyYy5nZXQoKTtcXG5cXHRcXHRcXG5cXHRcXHQvLyBwb3N0aW5nIGEgbWVzc2FnZSB3aXRoIHRyYW5zZmVyYWJsZXMgd2lsbCBmYWlsIG9uIElFMTBcXG5cXHRcXHR0cnkge1xcblxcdFxcdFxcdHBvc3RNZXNzYWdlKHJtc2csIHRyYW5zZmVyYWJsZXMpO1xcblxcdFxcdH0gY2F0Y2goZXgpIHtcXG5cXHRcXHRcXHRwb3N0TWVzc2FnZShybXNnKTsgLy8gcmV0cnkgd2l0aG91dCB0cmFuc2ZlcmFibGVzXFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBvbkVycm9yKHR5cGUsIHNuLCBlKSB7XFxuXFx0XFx0dmFyIG1zZyA9IHtcXG5cXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdHNuOiBzbixcXG5cXHRcXHRcXHRlcnJvcjogZm9ybWF0RXJyb3IoZSlcXG5cXHRcXHR9O1xcblxcdFxcdHBvc3RNZXNzYWdlKG1zZyk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGZvcm1hdEVycm9yKGUpIHtcXG5cXHRcXHRyZXR1cm4geyBtZXNzYWdlOiBlLm1lc3NhZ2UsIHN0YWNrOiBlLnN0YWNrIH07XFxuXFx0fVxcblxcblxcdC8vIENyYzMyIGNvZGUgY29waWVkIGZyb20gZmlsZSB6aXAuanNcXG5cXHRmdW5jdGlvbiBDcmMzMigpIHtcXG5cXHRcXHR0aGlzLmNyYyA9IC0xO1xcblxcdH1cXG5cXHRDcmMzMi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGRhdGEpIHtcXG5cXHRcXHR2YXIgY3JjID0gdGhpcy5jcmMgfCAwLCB0YWJsZSA9IHRoaXMudGFibGU7XFxuXFx0XFx0Zm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gZGF0YS5sZW5ndGggfCAwOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKVxcblxcdFxcdFxcdGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbKGNyYyBeIGRhdGFbb2Zmc2V0XSkgJiAweEZGXTtcXG5cXHRcXHR0aGlzLmNyYyA9IGNyYztcXG5cXHR9O1xcblxcdENyYzMyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XFxuXFx0XFx0cmV0dXJuIH50aGlzLmNyYztcXG5cXHR9O1xcblxcdENyYzMyLnByb3RvdHlwZS50YWJsZSA9IChmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaSwgaiwgdCwgdGFibGUgPSBbXTsgLy8gVWludDMyQXJyYXkgaXMgYWN0dWFsbHkgc2xvd2VyIHRoYW4gW11cXG5cXHRcXHRmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcXG5cXHRcXHRcXHR0ID0gaTtcXG5cXHRcXHRcXHRmb3IgKGogPSAwOyBqIDwgODsgaisrKVxcblxcdFxcdFxcdFxcdGlmICh0ICYgMSlcXG5cXHRcXHRcXHRcXHRcXHR0ID0gKHQgPj4+IDEpIF4gMHhFREI4ODMyMDtcXG5cXHRcXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0XFx0dCA9IHQgPj4+IDE7XFxuXFx0XFx0XFx0dGFibGVbaV0gPSB0O1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGFibGU7XFxuXFx0fSkoKTtcXG5cXG5cXHQvLyBcXFwibm8tb3BcXFwiIGNvZGVjXFxuXFx0ZnVuY3Rpb24gTk9PUCgpIHt9XFxuXFx0Z2xvYmFsLk5PT1AgPSBOT09QO1xcblxcdE5PT1AucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChieXRlcywgb25wcm9ncmVzcykge1xcblxcdFxcdHJldHVybiBieXRlcztcXG5cXHR9O1xcblxcdE5PT1AucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7fTtcXG59KSh0aGlzKTtcXG5cIik7XG56aXAud29ya2VyU2NyaXB0cyA9IHtcbiAgZGVmbGF0ZXI6IFt6V29ya2VyLCBjcmVhdGVVcmwoXCIvKlxcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXFxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXFxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG4gKi9cXG5cXG4vKlxcbiAqIFRoaXMgcHJvZ3JhbSBpcyBiYXNlZCBvbiBKWmxpYiAxLjAuMiB5bW5rLCBKQ3JhZnQsSW5jLlxcbiAqIEpabGliIGlzIGJhc2VkIG9uIHpsaWItMS4xLjMsIHNvIGFsbCBjcmVkaXQgc2hvdWxkIGdvIGF1dGhvcnNcXG4gKiBKZWFuLWxvdXAgR2FpbGx5KGpsb3VwQGd6aXAub3JnKSBhbmQgTWFyayBBZGxlcihtYWRsZXJAYWx1bW5pLmNhbHRlY2guZWR1KVxcbiAqIGFuZCBjb250cmlidXRvcnMgb2YgemxpYi5cXG4gKi9cXG5cXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdC8vIEdsb2JhbFxcblxcblxcdHZhciBNQVhfQklUUyA9IDE1O1xcblxcdHZhciBEX0NPREVTID0gMzA7XFxuXFx0dmFyIEJMX0NPREVTID0gMTk7XFxuXFxuXFx0dmFyIExFTkdUSF9DT0RFUyA9IDI5O1xcblxcdHZhciBMSVRFUkFMUyA9IDI1NjtcXG5cXHR2YXIgTF9DT0RFUyA9IChMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVMpO1xcblxcdHZhciBIRUFQX1NJWkUgPSAoMiAqIExfQ09ERVMgKyAxKTtcXG5cXG5cXHR2YXIgRU5EX0JMT0NLID0gMjU2O1xcblxcblxcdC8vIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHNcXG5cXHR2YXIgTUFYX0JMX0JJVFMgPSA3O1xcblxcblxcdC8vIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudClcXG5cXHR2YXIgUkVQXzNfNiA9IDE2O1xcblxcblxcdC8vIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgKDMgYml0cyBvZiByZXBlYXQgY291bnQpXFxuXFx0dmFyIFJFUFpfM18xMCA9IDE3O1xcblxcblxcdC8vIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudClcXG5cXHR2YXIgUkVQWl8xMV8xMzggPSAxODtcXG5cXG5cXHQvLyBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXFxuXFx0Ly8gcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdFxcblxcdC8vIGxlbmd0aCBjb2Rlcy5cXG5cXG5cXHR2YXIgQnVmX3NpemUgPSA4ICogMjtcXG5cXG5cXHQvLyBKWmxpYiB2ZXJzaW9uIDogXFxcIjEuMC4yXFxcIlxcblxcdHZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcXG5cXG5cXHQvLyBjb21wcmVzc2lvbiBzdHJhdGVneVxcblxcdHZhciBaX0ZJTFRFUkVEID0gMTtcXG5cXHR2YXIgWl9IVUZGTUFOX09OTFkgPSAyO1xcblxcdHZhciBaX0RFRkFVTFRfU1RSQVRFR1kgPSAwO1xcblxcblxcdHZhciBaX05PX0ZMVVNIID0gMDtcXG5cXHR2YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcXG5cXHR2YXIgWl9GVUxMX0ZMVVNIID0gMztcXG5cXHR2YXIgWl9GSU5JU0ggPSA0O1xcblxcblxcdHZhciBaX09LID0gMDtcXG5cXHR2YXIgWl9TVFJFQU1fRU5EID0gMTtcXG5cXHR2YXIgWl9ORUVEX0RJQ1QgPSAyO1xcblxcdHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcblxcdHZhciBaX0RBVEFfRVJST1IgPSAtMztcXG5cXHR2YXIgWl9CVUZfRVJST1IgPSAtNTtcXG5cXG5cXHQvLyBUcmVlXFxuXFxuXFx0Ly8gc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93XFxuXFx0dmFyIF9kaXN0X2NvZGUgPSBbIDAsIDEsIDIsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDYsIDYsIDcsIDcsIDcsIDcsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDksIDksIDksIDksIDksIDksIDksIDksIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLFxcblxcdFxcdFxcdDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLFxcblxcdFxcdFxcdDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLFxcblxcdFxcdFxcdDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LFxcblxcdFxcdFxcdDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LCAxNCwgMTQsIDE0LFxcblxcdFxcdFxcdDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LFxcblxcdFxcdFxcdDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMCwgMCwgMTYsIDE3LCAxOCwgMTgsIDE5LCAxOSxcXG5cXHRcXHRcXHQyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcXG5cXHRcXHRcXHQyNCwgMjQsIDI0LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNixcXG5cXHRcXHRcXHQyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNyxcXG5cXHRcXHRcXHQyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCxcXG5cXHRcXHRcXHQyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOSxcXG5cXHRcXHRcXHQyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSxcXG5cXHRcXHRcXHQyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjksIDI5LCAyOSwgMjkgXTtcXG5cXG5cXHRmdW5jdGlvbiBUcmVlKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHQvLyBkeW5fdHJlZTsgLy8gdGhlIGR5bmFtaWMgdHJlZVxcblxcdFxcdC8vIG1heF9jb2RlOyAvLyBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3lcXG5cXHRcXHQvLyBzdGF0X2Rlc2M7IC8vIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlXFxuXFxuXFx0XFx0Ly8gQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdFxcblxcdFxcdC8vIGxlbmd0aFxcblxcdFxcdC8vIGZvciB0aGUgY3VycmVudCBibG9jay5cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxcblxcdFxcdC8vIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXFxuXFx0XFx0Ly8gT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxcblxcdFxcdC8vIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxcblxcdFxcdC8vIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xcblxcdFxcdC8vIG5vdCBudWxsLlxcblxcdFxcdGZ1bmN0aW9uIGdlbl9iaXRsZW4ocykge1xcblxcdFxcdFxcdHZhciB0cmVlID0gdGhhdC5keW5fdHJlZTtcXG5cXHRcXHRcXHR2YXIgc3RyZWUgPSB0aGF0LnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcXG5cXHRcXHRcXHR2YXIgZXh0cmEgPSB0aGF0LnN0YXRfZGVzYy5leHRyYV9iaXRzO1xcblxcdFxcdFxcdHZhciBiYXNlID0gdGhhdC5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcXG5cXHRcXHRcXHR2YXIgbWF4X2xlbmd0aCA9IHRoYXQuc3RhdF9kZXNjLm1heF9sZW5ndGg7XFxuXFx0XFx0XFx0dmFyIGg7IC8vIGhlYXAgaW5kZXhcXG5cXHRcXHRcXHR2YXIgbiwgbTsgLy8gaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzXFxuXFx0XFx0XFx0dmFyIGJpdHM7IC8vIGJpdCBsZW5ndGhcXG5cXHRcXHRcXHR2YXIgeGJpdHM7IC8vIGV4dHJhIGJpdHNcXG5cXHRcXHRcXHR2YXIgZjsgLy8gZnJlcXVlbmN5XFxuXFx0XFx0XFx0dmFyIG92ZXJmbG93ID0gMDsgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2VcXG5cXG5cXHRcXHRcXHRmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspXFxuXFx0XFx0XFx0XFx0cy5ibF9jb3VudFtiaXRzXSA9IDA7XFxuXFxuXFx0XFx0XFx0Ly8gSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcXG5cXHRcXHRcXHQvLyBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cXG5cXHRcXHRcXHR0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXSA9IDA7IC8vIHJvb3Qgb2YgdGhlIGhlYXBcXG5cXG5cXHRcXHRcXHRmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XFxuXFx0XFx0XFx0XFx0biA9IHMuaGVhcFtoXTtcXG5cXHRcXHRcXHRcXHRiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0gKiAyICsgMV0gKyAxO1xcblxcdFxcdFxcdFxcdGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGJpdHMgPSBtYXhfbGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdG92ZXJmbG93Kys7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRyZWVbbiAqIDIgKyAxXSA9IGJpdHM7XFxuXFx0XFx0XFx0XFx0Ly8gV2Ugb3ZlcndyaXRlIHRyZWVbbioyKzFdIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWRcXG5cXG5cXHRcXHRcXHRcXHRpZiAobiA+IHRoYXQubWF4X2NvZGUpXFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7IC8vIG5vdCBhIGxlYWYgbm9kZVxcblxcblxcdFxcdFxcdFxcdHMuYmxfY291bnRbYml0c10rKztcXG5cXHRcXHRcXHRcXHR4Yml0cyA9IDA7XFxuXFx0XFx0XFx0XFx0aWYgKG4gPj0gYmFzZSlcXG5cXHRcXHRcXHRcXHRcXHR4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcXG5cXHRcXHRcXHRcXHRmID0gdHJlZVtuICogMl07XFxuXFx0XFx0XFx0XFx0cy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyZWUpXFxuXFx0XFx0XFx0XFx0XFx0cy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXSArIHhiaXRzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG92ZXJmbG93ID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1c1xcblxcdFxcdFxcdC8vIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcXG5cXHRcXHRcXHRcXHR3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRiaXRzLS07XFxuXFx0XFx0XFx0XFx0cy5ibF9jb3VudFtiaXRzXS0tOyAvLyBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWVcXG5cXHRcXHRcXHRcXHRzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvLyBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyXFxuXFx0XFx0XFx0XFx0cy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xcblxcdFxcdFxcdFxcdC8vIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXFxuXFx0XFx0XFx0XFx0Ly8gYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXFxuXFx0XFx0XFx0XFx0b3ZlcmZsb3cgLT0gMjtcXG5cXHRcXHRcXHR9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xcblxcblxcdFxcdFxcdGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xcblxcdFxcdFxcdFxcdG4gPSBzLmJsX2NvdW50W2JpdHNdO1xcblxcdFxcdFxcdFxcdHdoaWxlIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0bSA9IHMuaGVhcFstLWhdO1xcblxcdFxcdFxcdFxcdFxcdGlmIChtID4gdGhhdC5tYXhfY29kZSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHJlZVttICogMiArIDFdICE9IGJpdHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0pICogdHJlZVttICogMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJlZVttICogMiArIDFdID0gYml0cztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGFcXG5cXHRcXHQvLyBmYXN0ZXJcXG5cXHRcXHQvLyBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXFxuXFx0XFx0Ly8gSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxcblxcdFxcdGZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgLy8gdGhlIHZhbHVlIHRvIGludmVydFxcblxcdFxcdGxlbiAvLyBpdHMgYml0IGxlbmd0aFxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciByZXMgPSAwO1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRyZXMgfD0gY29kZSAmIDE7XFxuXFx0XFx0XFx0XFx0Y29kZSA+Pj49IDE7XFxuXFx0XFx0XFx0XFx0cmVzIDw8PSAxO1xcblxcdFxcdFxcdH0gd2hpbGUgKC0tbGVuID4gMCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlcyA+Pj4gMTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXFxuXFx0XFx0Ly8gb3B0aW1hbCkuXFxuXFx0XFx0Ly8gSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcXG5cXHRcXHQvLyB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxcblxcdFxcdC8vIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXFxuXFx0XFx0Ly8gemVybyBjb2RlIGxlbmd0aC5cXG5cXHRcXHRmdW5jdGlvbiBnZW5fY29kZXModHJlZSwgLy8gdGhlIHRyZWUgdG8gZGVjb3JhdGVcXG5cXHRcXHRtYXhfY29kZSwgLy8gbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5XFxuXFx0XFx0YmxfY291bnQgLy8gbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aFxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciBuZXh0X2NvZGUgPSBbXTsgLy8gbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoXFxuXFx0XFx0XFx0Ly8gYml0IGxlbmd0aFxcblxcdFxcdFxcdHZhciBjb2RlID0gMDsgLy8gcnVubmluZyBjb2RlIHZhbHVlXFxuXFx0XFx0XFx0dmFyIGJpdHM7IC8vIGJpdCBpbmRleFxcblxcdFxcdFxcdHZhciBuOyAvLyBjb2RlIGluZGV4XFxuXFx0XFx0XFx0dmFyIGxlbjtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcXG5cXHRcXHRcXHQvLyB3aXRob3V0IGJpdCByZXZlcnNhbC5cXG5cXHRcXHRcXHRmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcXG5cXHRcXHRcXHRcXHRuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxcblxcdFxcdFxcdC8vIG11c3QgYmUgYWxsIG9uZXMuXFxuXFx0XFx0XFx0Ly8gQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxcblxcdFxcdFxcdC8vIFxcXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1xcXCIpO1xcblxcdFxcdFxcdC8vIFRyYWNldigoc3RkZXJyLFxcXCJcXFxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXFxcIiwgbWF4X2NvZGUpKTtcXG5cXG5cXHRcXHRcXHRmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcXG5cXHRcXHRcXHRcXHRsZW4gPSB0cmVlW24gKiAyICsgMV07XFxuXFx0XFx0XFx0XFx0aWYgKGxlbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHQvLyBOb3cgcmV2ZXJzZSB0aGUgYml0c1xcblxcdFxcdFxcdFxcdHRyZWVbbiAqIDJdID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXFxuXFx0XFx0Ly8gVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXFxuXFx0XFx0Ly8gT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxcblxcdFxcdC8vIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXFxuXFx0XFx0Ly8gYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxcblxcdFxcdHRoYXQuYnVpbGRfdHJlZSA9IGZ1bmN0aW9uKHMpIHtcXG5cXHRcXHRcXHR2YXIgdHJlZSA9IHRoYXQuZHluX3RyZWU7XFxuXFx0XFx0XFx0dmFyIHN0cmVlID0gdGhhdC5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XFxuXFx0XFx0XFx0dmFyIGVsZW1zID0gdGhhdC5zdGF0X2Rlc2MuZWxlbXM7XFxuXFx0XFx0XFx0dmFyIG4sIG07IC8vIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzXFxuXFx0XFx0XFx0dmFyIG1heF9jb2RlID0gLTE7IC8vIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeVxcblxcdFxcdFxcdHZhciBub2RlOyAvLyBuZXcgbm9kZSBiZWluZyBjcmVhdGVkXFxuXFxuXFx0XFx0XFx0Ly8gQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxcblxcdFxcdFxcdC8vIGhlYXBbMV0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXFxuXFx0XFx0XFx0Ly8gaGVhcFswXSBpcyBub3QgdXNlZC5cXG5cXHRcXHRcXHRzLmhlYXBfbGVuID0gMDtcXG5cXHRcXHRcXHRzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xcblxcblxcdFxcdFxcdGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRyZWVbbiAqIDJdICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0cy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XFxuXFx0XFx0XFx0XFx0XFx0cy5kZXB0aFtuXSA9IDA7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0cmVlW24gKiAyICsgMV0gPSAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcXG5cXHRcXHRcXHQvLyBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcXG5cXHRcXHRcXHQvLyBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxcblxcdFxcdFxcdC8vIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXFxuXFx0XFx0XFx0d2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XFxuXFx0XFx0XFx0XFx0bm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDA7XFxuXFx0XFx0XFx0XFx0dHJlZVtub2RlICogMl0gPSAxO1xcblxcdFxcdFxcdFxcdHMuZGVwdGhbbm9kZV0gPSAwO1xcblxcdFxcdFxcdFxcdHMub3B0X2xlbi0tO1xcblxcdFxcdFxcdFxcdGlmIChzdHJlZSlcXG5cXHRcXHRcXHRcXHRcXHRzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXTtcXG5cXHRcXHRcXHRcXHQvLyBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHNcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhhdC5tYXhfY29kZSA9IG1heF9jb2RlO1xcblxcblxcdFxcdFxcdC8vIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcXG5cXHRcXHRcXHQvLyBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcXG5cXG5cXHRcXHRcXHRmb3IgKG4gPSBNYXRoLmZsb29yKHMuaGVhcF9sZW4gLyAyKTsgbiA+PSAxOyBuLS0pXFxuXFx0XFx0XFx0XFx0cy5wcWRvd25oZWFwKHRyZWUsIG4pO1xcblxcblxcdFxcdFxcdC8vIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cXG5cXHRcXHRcXHQvLyBmcmVxdWVudCBub2Rlcy5cXG5cXG5cXHRcXHRcXHRub2RlID0gZWxlbXM7IC8vIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZVxcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHQvLyBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3lcXG5cXHRcXHRcXHRcXHRuID0gcy5oZWFwWzFdO1xcblxcdFxcdFxcdFxcdHMuaGVhcFsxXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xcblxcdFxcdFxcdFxcdHMucHFkb3duaGVhcCh0cmVlLCAxKTtcXG5cXHRcXHRcXHRcXHRtID0gcy5oZWFwWzFdOyAvLyBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeVxcblxcblxcdFxcdFxcdFxcdHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLy8ga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeVxcblxcdFxcdFxcdFxcdHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbVxcblxcdFxcdFxcdFxcdHRyZWVbbm9kZSAqIDJdID0gKHRyZWVbbiAqIDJdICsgdHJlZVttICogMl0pO1xcblxcdFxcdFxcdFxcdHMuZGVwdGhbbm9kZV0gPSBNYXRoLm1heChzLmRlcHRoW25dLCBzLmRlcHRoW21dKSArIDE7XFxuXFx0XFx0XFx0XFx0dHJlZVtuICogMiArIDFdID0gdHJlZVttICogMiArIDFdID0gbm9kZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcFxcblxcdFxcdFxcdFxcdHMuaGVhcFsxXSA9IG5vZGUrKztcXG5cXHRcXHRcXHRcXHRzLnBxZG93bmhlYXAodHJlZSwgMSk7XFxuXFx0XFx0XFx0fSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcXG5cXG5cXHRcXHRcXHRzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxXTtcXG5cXG5cXHRcXHRcXHQvLyBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxcblxcblxcdFxcdFxcdGdlbl9iaXRsZW4ocyk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2Rlc1xcblxcdFxcdFxcdGdlbl9jb2Rlcyh0cmVlLCB0aGF0Lm1heF9jb2RlLCBzLmJsX2NvdW50KTtcXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHRUcmVlLl9sZW5ndGhfY29kZSA9IFsgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTIsIDEyLCAxMywgMTMsIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNixcXG5cXHRcXHRcXHQxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCxcXG5cXHRcXHRcXHQyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcXG5cXHRcXHRcXHQyMiwgMjIsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcXG5cXHRcXHRcXHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSxcXG5cXHRcXHRcXHQyNSwgMjUsIDI1LCAyNSwgMjUsIDI1LCAyNSwgMjUsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNixcXG5cXHRcXHRcXHQyNiwgMjYsIDI2LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjcsIDI3LCAyNywgMjggXTtcXG5cXG5cXHRUcmVlLmJhc2VfbGVuZ3RoID0gWyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAxMCwgMTIsIDE0LCAxNiwgMjAsIDI0LCAyOCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAwIF07XFxuXFxuXFx0VHJlZS5iYXNlX2Rpc3QgPSBbIDAsIDEsIDIsIDMsIDQsIDYsIDgsIDEyLCAxNiwgMjQsIDMyLCA0OCwgNjQsIDk2LCAxMjgsIDE5MiwgMjU2LCAzODQsIDUxMiwgNzY4LCAxMDI0LCAxNTM2LCAyMDQ4LCAzMDcyLCA0MDk2LCA2MTQ0LCA4MTkyLCAxMjI4OCwgMTYzODQsXFxuXFx0XFx0XFx0MjQ1NzYgXTtcXG5cXG5cXHQvLyBNYXBwaW5nIGZyb20gYSBkaXN0YW5jZSB0byBhIGRpc3RhbmNlIGNvZGUuIGRpc3QgaXMgdGhlIGRpc3RhbmNlIC0gMSBhbmRcXG5cXHQvLyBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy4gX2Rpc3RfY29kZVsyNTZdIGFuZCBfZGlzdF9jb2RlWzI1N10gYXJlIG5ldmVyXFxuXFx0Ly8gdXNlZC5cXG5cXHRUcmVlLmRfY29kZSA9IGZ1bmN0aW9uKGRpc3QpIHtcXG5cXHRcXHRyZXR1cm4gKChkaXN0KSA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArICgoZGlzdCkgPj4+IDcpXSk7XFxuXFx0fTtcXG5cXG5cXHQvLyBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlXFxuXFx0VHJlZS5leHRyYV9sYml0cyA9IFsgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCBdO1xcblxcblxcdC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZVxcblxcdFRyZWUuZXh0cmFfZGJpdHMgPSBbIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcblxcblxcdC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlXFxuXFx0VHJlZS5leHRyYV9ibGJpdHMgPSBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDcgXTtcXG5cXG5cXHRUcmVlLmJsX29yZGVyID0gWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XFxuXFxuXFx0Ly8gU3RhdGljVHJlZVxcblxcblxcdGZ1bmN0aW9uIFN0YXRpY1RyZWUoc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdHRoYXQuc3RhdGljX3RyZWUgPSBzdGF0aWNfdHJlZTtcXG5cXHRcXHR0aGF0LmV4dHJhX2JpdHMgPSBleHRyYV9iaXRzO1xcblxcdFxcdHRoYXQuZXh0cmFfYmFzZSA9IGV4dHJhX2Jhc2U7XFxuXFx0XFx0dGhhdC5lbGVtcyA9IGVsZW1zO1xcblxcdFxcdHRoYXQubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7XFxuXFx0fVxcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlID0gWyAxMiwgOCwgMTQwLCA4LCA3NiwgOCwgMjA0LCA4LCA0NCwgOCwgMTcyLCA4LCAxMDgsIDgsIDIzNiwgOCwgMjgsIDgsIDE1NiwgOCwgOTIsIDgsIDIyMCwgOCwgNjAsIDgsIDE4OCwgOCwgMTI0LCA4LCAyNTIsIDgsIDIsIDgsXFxuXFx0XFx0XFx0MTMwLCA4LCA2NiwgOCwgMTk0LCA4LCAzNCwgOCwgMTYyLCA4LCA5OCwgOCwgMjI2LCA4LCAxOCwgOCwgMTQ2LCA4LCA4MiwgOCwgMjEwLCA4LCA1MCwgOCwgMTc4LCA4LCAxMTQsIDgsIDI0MiwgOCwgMTAsIDgsIDEzOCwgOCwgNzQsIDgsIDIwMiwgOCwgNDIsXFxuXFx0XFx0XFx0OCwgMTcwLCA4LCAxMDYsIDgsIDIzNCwgOCwgMjYsIDgsIDE1NCwgOCwgOTAsIDgsIDIxOCwgOCwgNTgsIDgsIDE4NiwgOCwgMTIyLCA4LCAyNTAsIDgsIDYsIDgsIDEzNCwgOCwgNzAsIDgsIDE5OCwgOCwgMzgsIDgsIDE2NiwgOCwgMTAyLCA4LCAyMzAsIDgsXFxuXFx0XFx0XFx0MjIsIDgsIDE1MCwgOCwgODYsIDgsIDIxNCwgOCwgNTQsIDgsIDE4MiwgOCwgMTE4LCA4LCAyNDYsIDgsIDE0LCA4LCAxNDIsIDgsIDc4LCA4LCAyMDYsIDgsIDQ2LCA4LCAxNzQsIDgsIDExMCwgOCwgMjM4LCA4LCAzMCwgOCwgMTU4LCA4LCA5NCwgOCxcXG5cXHRcXHRcXHQyMjIsIDgsIDYyLCA4LCAxOTAsIDgsIDEyNiwgOCwgMjU0LCA4LCAxLCA4LCAxMjksIDgsIDY1LCA4LCAxOTMsIDgsIDMzLCA4LCAxNjEsIDgsIDk3LCA4LCAyMjUsIDgsIDE3LCA4LCAxNDUsIDgsIDgxLCA4LCAyMDksIDgsIDQ5LCA4LCAxNzcsIDgsIDExMyxcXG5cXHRcXHRcXHQ4LCAyNDEsIDgsIDksIDgsIDEzNywgOCwgNzMsIDgsIDIwMSwgOCwgNDEsIDgsIDE2OSwgOCwgMTA1LCA4LCAyMzMsIDgsIDI1LCA4LCAxNTMsIDgsIDg5LCA4LCAyMTcsIDgsIDU3LCA4LCAxODUsIDgsIDEyMSwgOCwgMjQ5LCA4LCA1LCA4LCAxMzMsIDgsXFxuXFx0XFx0XFx0NjksIDgsIDE5NywgOCwgMzcsIDgsIDE2NSwgOCwgMTAxLCA4LCAyMjksIDgsIDIxLCA4LCAxNDksIDgsIDg1LCA4LCAyMTMsIDgsIDUzLCA4LCAxODEsIDgsIDExNywgOCwgMjQ1LCA4LCAxMywgOCwgMTQxLCA4LCA3NywgOCwgMjA1LCA4LCA0NSwgOCxcXG5cXHRcXHRcXHQxNzMsIDgsIDEwOSwgOCwgMjM3LCA4LCAyOSwgOCwgMTU3LCA4LCA5MywgOCwgMjIxLCA4LCA2MSwgOCwgMTg5LCA4LCAxMjUsIDgsIDI1MywgOCwgMTksIDksIDI3NSwgOSwgMTQ3LCA5LCA0MDMsIDksIDgzLCA5LCAzMzksIDksIDIxMSwgOSwgNDY3LCA5LFxcblxcdFxcdFxcdDUxLCA5LCAzMDcsIDksIDE3OSwgOSwgNDM1LCA5LCAxMTUsIDksIDM3MSwgOSwgMjQzLCA5LCA0OTksIDksIDExLCA5LCAyNjcsIDksIDEzOSwgOSwgMzk1LCA5LCA3NSwgOSwgMzMxLCA5LCAyMDMsIDksIDQ1OSwgOSwgNDMsIDksIDI5OSwgOSwgMTcxLCA5LFxcblxcdFxcdFxcdDQyNywgOSwgMTA3LCA5LCAzNjMsIDksIDIzNSwgOSwgNDkxLCA5LCAyNywgOSwgMjgzLCA5LCAxNTUsIDksIDQxMSwgOSwgOTEsIDksIDM0NywgOSwgMjE5LCA5LCA0NzUsIDksIDU5LCA5LCAzMTUsIDksIDE4NywgOSwgNDQzLCA5LCAxMjMsIDksIDM3OSxcXG5cXHRcXHRcXHQ5LCAyNTEsIDksIDUwNywgOSwgNywgOSwgMjYzLCA5LCAxMzUsIDksIDM5MSwgOSwgNzEsIDksIDMyNywgOSwgMTk5LCA5LCA0NTUsIDksIDM5LCA5LCAyOTUsIDksIDE2NywgOSwgNDIzLCA5LCAxMDMsIDksIDM1OSwgOSwgMjMxLCA5LCA0ODcsIDksIDIzLFxcblxcdFxcdFxcdDksIDI3OSwgOSwgMTUxLCA5LCA0MDcsIDksIDg3LCA5LCAzNDMsIDksIDIxNSwgOSwgNDcxLCA5LCA1NSwgOSwgMzExLCA5LCAxODMsIDksIDQzOSwgOSwgMTE5LCA5LCAzNzUsIDksIDI0NywgOSwgNTAzLCA5LCAxNSwgOSwgMjcxLCA5LCAxNDMsIDksXFxuXFx0XFx0XFx0Mzk5LCA5LCA3OSwgOSwgMzM1LCA5LCAyMDcsIDksIDQ2MywgOSwgNDcsIDksIDMwMywgOSwgMTc1LCA5LCA0MzEsIDksIDExMSwgOSwgMzY3LCA5LCAyMzksIDksIDQ5NSwgOSwgMzEsIDksIDI4NywgOSwgMTU5LCA5LCA0MTUsIDksIDk1LCA5LCAzNTEsIDksXFxuXFx0XFx0XFx0MjIzLCA5LCA0NzksIDksIDYzLCA5LCAzMTksIDksIDE5MSwgOSwgNDQ3LCA5LCAxMjcsIDksIDM4MywgOSwgMjU1LCA5LCA1MTEsIDksIDAsIDcsIDY0LCA3LCAzMiwgNywgOTYsIDcsIDE2LCA3LCA4MCwgNywgNDgsIDcsIDExMiwgNywgOCwgNywgNzIsIDcsXFxuXFx0XFx0XFx0NDAsIDcsIDEwNCwgNywgMjQsIDcsIDg4LCA3LCA1NiwgNywgMTIwLCA3LCA0LCA3LCA2OCwgNywgMzYsIDcsIDEwMCwgNywgMjAsIDcsIDg0LCA3LCA1MiwgNywgMTE2LCA3LCAzLCA4LCAxMzEsIDgsIDY3LCA4LCAxOTUsIDgsIDM1LCA4LCAxNjMsIDgsXFxuXFx0XFx0XFx0OTksIDgsIDIyNywgOCBdO1xcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlID0gWyAwLCA1LCAxNiwgNSwgOCwgNSwgMjQsIDUsIDQsIDUsIDIwLCA1LCAxMiwgNSwgMjgsIDUsIDIsIDUsIDE4LCA1LCAxMCwgNSwgMjYsIDUsIDYsIDUsIDIyLCA1LCAxNCwgNSwgMzAsIDUsIDEsIDUsIDE3LCA1LCA5LCA1LFxcblxcdFxcdFxcdDI1LCA1LCA1LCA1LCAyMSwgNSwgMTMsIDUsIDI5LCA1LCAzLCA1LCAxOSwgNSwgMTEsIDUsIDI3LCA1LCA3LCA1LCAyMywgNSBdO1xcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlKFN0YXRpY1RyZWUuc3RhdGljX2x0cmVlLCBUcmVlLmV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcXG5cXG5cXHRTdGF0aWNUcmVlLnN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZShTdGF0aWNUcmVlLnN0YXRpY19kdHJlZSwgVHJlZS5leHRyYV9kYml0cywgMCwgRF9DT0RFUywgTUFYX0JJVFMpO1xcblxcblxcdFN0YXRpY1RyZWUuc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZShudWxsLCBUcmVlLmV4dHJhX2JsYml0cywgMCwgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcXG5cXG5cXHQvLyBEZWZsYXRlXFxuXFxuXFx0dmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xcblxcdHZhciBERUZfTUVNX0xFVkVMID0gODtcXG5cXG5cXHRmdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdHRoYXQuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcXG5cXHRcXHR0aGF0Lm1heF9sYXp5ID0gbWF4X2xhenk7XFxuXFx0XFx0dGhhdC5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xcblxcdFxcdHRoYXQubWF4X2NoYWluID0gbWF4X2NoYWluO1xcblxcdFxcdHRoYXQuZnVuYyA9IGZ1bmM7XFxuXFx0fVxcblxcblxcdHZhciBTVE9SRUQgPSAwO1xcblxcdHZhciBGQVNUID0gMTtcXG5cXHR2YXIgU0xPVyA9IDI7XFxuXFx0dmFyIGNvbmZpZ190YWJsZSA9IFsgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBTVE9SRUQpLCBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIEZBU1QpLCBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBGQVNUKSwgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIEZBU1QpLFxcblxcdFxcdFxcdG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBTTE9XKSwgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBTTE9XKSwgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIFNMT1cpLCBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgU0xPVyksXFxuXFx0XFx0XFx0bmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIFNMT1cpLCBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgU0xPVykgXTtcXG5cXG5cXHR2YXIgel9lcnJtc2cgPSBbIFxcXCJuZWVkIGRpY3Rpb25hcnlcXFwiLCAvLyBaX05FRURfRElDVFxcblxcdC8vIDJcXG5cXHRcXFwic3RyZWFtIGVuZFxcXCIsIC8vIFpfU1RSRUFNX0VORCAxXFxuXFx0XFxcIlxcXCIsIC8vIFpfT0sgMFxcblxcdFxcXCJcXFwiLCAvLyBaX0VSUk5PICgtMSlcXG5cXHRcXFwic3RyZWFtIGVycm9yXFxcIiwgLy8gWl9TVFJFQU1fRVJST1IgKC0yKVxcblxcdFxcXCJkYXRhIGVycm9yXFxcIiwgLy8gWl9EQVRBX0VSUk9SICgtMylcXG5cXHRcXFwiXFxcIiwgLy8gWl9NRU1fRVJST1IgKC00KVxcblxcdFxcXCJidWZmZXIgZXJyb3JcXFwiLCAvLyBaX0JVRl9FUlJPUiAoLTUpXFxuXFx0XFxcIlxcXCIsLy8gWl9WRVJTSU9OX0VSUk9SICgtNilcXG5cXHRcXFwiXFxcIiBdO1xcblxcblxcdC8vIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dFxcblxcdHZhciBOZWVkTW9yZSA9IDA7XFxuXFxuXFx0Ly8gYmxvY2sgZmx1c2ggcGVyZm9ybWVkXFxuXFx0dmFyIEJsb2NrRG9uZSA9IDE7XFxuXFxuXFx0Ly8gZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGVcXG5cXHR2YXIgRmluaXNoU3RhcnRlZCA9IDI7XFxuXFxuXFx0Ly8gZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dFxcblxcdHZhciBGaW5pc2hEb25lID0gMztcXG5cXG5cXHQvLyBwcmVzZXQgZGljdGlvbmFyeSBmbGFnIGluIHpsaWIgaGVhZGVyXFxuXFx0dmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcXG5cXG5cXHR2YXIgSU5JVF9TVEFURSA9IDQyO1xcblxcdHZhciBCVVNZX1NUQVRFID0gMTEzO1xcblxcdHZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XFxuXFxuXFx0Ly8gVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kXFxuXFx0dmFyIFpfREVGTEFURUQgPSA4O1xcblxcblxcdHZhciBTVE9SRURfQkxPQ0sgPSAwO1xcblxcdHZhciBTVEFUSUNfVFJFRVMgPSAxO1xcblxcdHZhciBEWU5fVFJFRVMgPSAyO1xcblxcblxcdHZhciBNSU5fTUFUQ0ggPSAzO1xcblxcdHZhciBNQVhfTUFUQ0ggPSAyNTg7XFxuXFx0dmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XFxuXFxuXFx0ZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xcblxcdFxcdHZhciB0bjIgPSB0cmVlW24gKiAyXTtcXG5cXHRcXHR2YXIgdG0yID0gdHJlZVttICogMl07XFxuXFx0XFx0cmV0dXJuICh0bjIgPCB0bTIgfHwgKHRuMiA9PSB0bTIgJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gRGVmbGF0ZSgpIHtcXG5cXG5cXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0dmFyIHN0cm07IC8vIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtXFxuXFx0XFx0dmFyIHN0YXR1czsgLy8gYXMgdGhlIG5hbWUgaW1wbGllc1xcblxcdFxcdC8vIHBlbmRpbmdfYnVmOyAvLyBvdXRwdXQgc3RpbGwgcGVuZGluZ1xcblxcdFxcdHZhciBwZW5kaW5nX2J1Zl9zaXplOyAvLyBzaXplIG9mIHBlbmRpbmdfYnVmXFxuXFx0XFx0Ly8gcGVuZGluZ19vdXQ7IC8vIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtXFxuXFx0XFx0Ly8gcGVuZGluZzsgLy8gbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyXFxuXFx0XFx0dmFyIG1ldGhvZDsgLy8gU1RPUkVEIChmb3IgemlwIG9ubHkpIG9yIERFRkxBVEVEXFxuXFx0XFx0dmFyIGxhc3RfZmx1c2g7IC8vIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGxcXG5cXG5cXHRcXHR2YXIgd19zaXplOyAvLyBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdClcXG5cXHRcXHR2YXIgd19iaXRzOyAvLyBsb2cyKHdfc2l6ZSkgKDguLjE2KVxcblxcdFxcdHZhciB3X21hc2s7IC8vIHdfc2l6ZSAtIDFcXG5cXG5cXHRcXHR2YXIgd2luZG93O1xcblxcdFxcdC8vIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxcblxcdFxcdC8vIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXFxuXFx0XFx0Ly8gYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxcblxcdFxcdC8vIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xcblxcdFxcdC8vIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLiBBbHNvLCBpdCBsaW1pdHNcXG5cXHRcXHQvLyB0aGUgd2luZG93IHNpemUgdG8gNjRLLCB3aGljaCBpcyBxdWl0ZSB1c2VmdWwgb24gTVNET1MuXFxuXFx0XFx0Ly8gVG8gZG86IHVzZSB0aGUgdXNlciBpbnB1dCBidWZmZXIgYXMgc2xpZGluZyB3aW5kb3cuXFxuXFxuXFx0XFx0dmFyIHdpbmRvd19zaXplO1xcblxcdFxcdC8vIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXFxuXFx0XFx0Ly8gaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cXG5cXG5cXHRcXHR2YXIgcHJldjtcXG5cXHRcXHQvLyBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xcblxcdFxcdC8vIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXFxuXFx0XFx0Ly8gQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXFxuXFxuXFx0XFx0dmFyIGhlYWQ7IC8vIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuXFxuXFxuXFx0XFx0dmFyIGluc19oOyAvLyBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZFxcblxcdFxcdHZhciBoYXNoX3NpemU7IC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlXFxuXFx0XFx0dmFyIGhhc2hfYml0czsgLy8gbG9nMihoYXNoX3NpemUpXFxuXFx0XFx0dmFyIGhhc2hfbWFzazsgLy8gaGFzaF9zaXplLTFcXG5cXG5cXHRcXHQvLyBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxcblxcdFxcdC8vIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxcblxcdFxcdC8vIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxcblxcdFxcdC8vIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXFxuXFx0XFx0dmFyIGhhc2hfc2hpZnQ7XFxuXFxuXFx0XFx0Ly8gV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXFxuXFx0XFx0Ly8gbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cXG5cXG5cXHRcXHR2YXIgYmxvY2tfc3RhcnQ7XFxuXFxuXFx0XFx0dmFyIG1hdGNoX2xlbmd0aDsgLy8gbGVuZ3RoIG9mIGJlc3QgbWF0Y2hcXG5cXHRcXHR2YXIgcHJldl9tYXRjaDsgLy8gcHJldmlvdXMgbWF0Y2hcXG5cXHRcXHR2YXIgbWF0Y2hfYXZhaWxhYmxlOyAvLyBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzXFxuXFx0XFx0dmFyIHN0cnN0YXJ0OyAvLyBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0XFxuXFx0XFx0dmFyIG1hdGNoX3N0YXJ0OyAvLyBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmdcXG5cXHRcXHR2YXIgbG9va2FoZWFkOyAvLyBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93XFxuXFxuXFx0XFx0Ly8gTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXFxuXFx0XFx0Ly8gYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXFxuXFx0XFx0dmFyIHByZXZfbGVuZ3RoO1xcblxcblxcdFxcdC8vIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXFxuXFx0XFx0Ly8gbGVuZ3RoLiBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlIHNwZWVkLlxcblxcdFxcdHZhciBtYXhfY2hhaW5fbGVuZ3RoO1xcblxcblxcdFxcdC8vIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcXG5cXHRcXHQvLyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxcblxcdFxcdC8vIGxldmVscyA+PSA0LlxcblxcdFxcdHZhciBtYXhfbGF6eV9tYXRjaDtcXG5cXG5cXHRcXHQvLyBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxcblxcdFxcdC8vIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cXG5cXHRcXHQvLyBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxcblxcblxcdFxcdHZhciBsZXZlbDsgLy8gY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpXFxuXFx0XFx0dmFyIHN0cmF0ZWd5OyAvLyBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZ1xcblxcblxcdFxcdC8vIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpc1xcblxcdFxcdHZhciBnb29kX21hdGNoO1xcblxcblxcdFxcdC8vIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXNcXG5cXHRcXHR2YXIgbmljZV9tYXRjaDtcXG5cXG5cXHRcXHR2YXIgZHluX2x0cmVlOyAvLyBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZVxcblxcdFxcdHZhciBkeW5fZHRyZWU7IC8vIGRpc3RhbmNlIHRyZWVcXG5cXHRcXHR2YXIgYmxfdHJlZTsgLy8gSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3Roc1xcblxcblxcdFxcdHZhciBsX2Rlc2MgPSBuZXcgVHJlZSgpOyAvLyBkZXNjIGZvciBsaXRlcmFsIHRyZWVcXG5cXHRcXHR2YXIgZF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgZGlzdGFuY2UgdHJlZVxcblxcdFxcdHZhciBibF9kZXNjID0gbmV3IFRyZWUoKTsgLy8gZGVzYyBmb3IgYml0IGxlbmd0aCB0cmVlXFxuXFxuXFx0XFx0Ly8gdGhhdC5oZWFwX2xlbjsgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwXFxuXFx0XFx0Ly8gdGhhdC5oZWFwX21heDsgLy8gZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeVxcblxcdFxcdC8vIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXFxuXFx0XFx0Ly8gVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cXG5cXG5cXHRcXHQvLyBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XFxuXFx0XFx0dGhhdC5kZXB0aCA9IFtdO1xcblxcblxcdFxcdHZhciBsX2J1ZjsgLy8gaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cXG5cXG5cXHRcXHQvLyBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcXG5cXHRcXHQvLyBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XFxuXFx0XFx0Ly8gLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcXG5cXHRcXHQvLyAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxcblxcdFxcdC8vIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXFxuXFx0XFx0Ly8gd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxcblxcdFxcdC8vIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxcblxcdFxcdC8vIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cXG5cXHRcXHQvLyBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXFxuXFx0XFx0Ly8gVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXFxuXFx0XFx0Ly8gLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcXG5cXHRcXHQvLyBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXFxuXFx0XFx0Ly8gZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XFxuXFx0XFx0Ly8gYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcXG5cXHRcXHQvLyBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcXG5cXHRcXHQvLyB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXFxuXFx0XFx0Ly8gLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcXG5cXHRcXHR2YXIgbGl0X2J1ZnNpemU7XFxuXFxuXFx0XFx0dmFyIGxhc3RfbGl0OyAvLyBydW5uaW5nIGluZGV4IGluIGxfYnVmXFxuXFxuXFx0XFx0Ly8gQnVmZmVyIGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxcblxcdFxcdC8vIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXFxuXFx0XFx0Ly8gYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxcblxcblxcdFxcdHZhciBkX2J1ZjsgLy8gaW5kZXggb2YgcGVuZGlnX2J1ZlxcblxcblxcdFxcdC8vIHRoYXQub3B0X2xlbjsgLy8gYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlc1xcblxcdFxcdC8vIHRoYXQuc3RhdGljX2xlbjsgLy8gYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzXFxuXFx0XFx0dmFyIG1hdGNoZXM7IC8vIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrXFxuXFx0XFx0dmFyIGxhc3RfZW9iX2xlbjsgLy8gYml0IGxlbmd0aCBvZiBFT0IgY29kZSBmb3IgbGFzdCBibG9ja1xcblxcblxcdFxcdC8vIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XFxuXFx0XFx0Ly8gc2lnbmlmaWNhbnQgYml0cykuXFxuXFx0XFx0dmFyIGJpX2J1ZjtcXG5cXG5cXHRcXHQvLyBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxcblxcdFxcdC8vIGFyZSBhbHdheXMgemVyby5cXG5cXHRcXHR2YXIgYmlfdmFsaWQ7XFxuXFxuXFx0XFx0Ly8gbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlXFxuXFx0XFx0dGhhdC5ibF9jb3VudCA9IFtdO1xcblxcblxcdFxcdC8vIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlc1xcblxcdFxcdHRoYXQuaGVhcCA9IFtdO1xcblxcblxcdFxcdGR5bl9sdHJlZSA9IFtdO1xcblxcdFxcdGR5bl9kdHJlZSA9IFtdO1xcblxcdFxcdGJsX3RyZWUgPSBbXTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBsbV9pbml0KCkge1xcblxcdFxcdFxcdHZhciBpO1xcblxcdFxcdFxcdHdpbmRvd19zaXplID0gMiAqIHdfc2l6ZTtcXG5cXG5cXHRcXHRcXHRoZWFkW2hhc2hfc2l6ZSAtIDFdID0gMDtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgaGFzaF9zaXplIC0gMTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aGVhZFtpXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XFxuXFx0XFx0XFx0bWF4X2xhenlfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9sYXp5O1xcblxcdFxcdFxcdGdvb2RfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLmdvb2RfbGVuZ3RoO1xcblxcdFxcdFxcdG5pY2VfbWF0Y2ggPSBjb25maWdfdGFibGVbbGV2ZWxdLm5pY2VfbGVuZ3RoO1xcblxcdFxcdFxcdG1heF9jaGFpbl9sZW5ndGggPSBjb25maWdfdGFibGVbbGV2ZWxdLm1heF9jaGFpbjtcXG5cXG5cXHRcXHRcXHRzdHJzdGFydCA9IDA7XFxuXFx0XFx0XFx0YmxvY2tfc3RhcnQgPSAwO1xcblxcdFxcdFxcdGxvb2thaGVhZCA9IDA7XFxuXFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gcHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcblxcdFxcdFxcdG1hdGNoX2F2YWlsYWJsZSA9IDA7XFxuXFx0XFx0XFx0aW5zX2ggPSAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBpbml0X2Jsb2NrKCkge1xcblxcdFxcdFxcdHZhciBpO1xcblxcdFxcdFxcdC8vIEluaXRpYWxpemUgdGhlIHRyZWVzLlxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBMX0NPREVTOyBpKyspXFxuXFx0XFx0XFx0XFx0ZHluX2x0cmVlW2kgKiAyXSA9IDA7XFxuXFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IERfQ09ERVM7IGkrKylcXG5cXHRcXHRcXHRcXHRkeW5fZHRyZWVbaSAqIDJdID0gMDtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgQkxfQ09ERVM7IGkrKylcXG5cXHRcXHRcXHRcXHRibF90cmVlW2kgKiAyXSA9IDA7XFxuXFxuXFx0XFx0XFx0ZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdID0gMTtcXG5cXHRcXHRcXHR0aGF0Lm9wdF9sZW4gPSB0aGF0LnN0YXRpY19sZW4gPSAwO1xcblxcdFxcdFxcdGxhc3RfbGl0ID0gbWF0Y2hlcyA9IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cXG5cXHRcXHRmdW5jdGlvbiB0cl9pbml0KCkge1xcblxcblxcdFxcdFxcdGxfZGVzYy5keW5fdHJlZSA9IGR5bl9sdHJlZTtcXG5cXHRcXHRcXHRsX2Rlc2Muc3RhdF9kZXNjID0gU3RhdGljVHJlZS5zdGF0aWNfbF9kZXNjO1xcblxcblxcdFxcdFxcdGRfZGVzYy5keW5fdHJlZSA9IGR5bl9kdHJlZTtcXG5cXHRcXHRcXHRkX2Rlc2Muc3RhdF9kZXNjID0gU3RhdGljVHJlZS5zdGF0aWNfZF9kZXNjO1xcblxcblxcdFxcdFxcdGJsX2Rlc2MuZHluX3RyZWUgPSBibF90cmVlO1xcblxcdFxcdFxcdGJsX2Rlc2Muc3RhdF9kZXNjID0gU3RhdGljVHJlZS5zdGF0aWNfYmxfZGVzYztcXG5cXG5cXHRcXHRcXHRiaV9idWYgPSAwO1xcblxcdFxcdFxcdGJpX3ZhbGlkID0gMDtcXG5cXHRcXHRcXHRsYXN0X2VvYl9sZW4gPSA4OyAvLyBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlXFxuXFxuXFx0XFx0XFx0Ly8gSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6XFxuXFx0XFx0XFx0aW5pdF9ibG9jaygpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcXG5cXHRcXHQvLyBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LFxcblxcdFxcdC8vIHN0b3BwaW5nXFxuXFx0XFx0Ly8gd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xcblxcdFxcdC8vIHR3byBzb25zKS5cXG5cXHRcXHR0aGF0LnBxZG93bmhlYXAgPSBmdW5jdGlvbih0cmVlLCAvLyB0aGUgdHJlZSB0byByZXN0b3JlXFxuXFx0XFx0ayAvLyBub2RlIHRvIG1vdmUgZG93blxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciBoZWFwID0gdGhhdC5oZWFwO1xcblxcdFxcdFxcdHZhciB2ID0gaGVhcFtrXTtcXG5cXHRcXHRcXHR2YXIgaiA9IGsgPDwgMTsgLy8gbGVmdCBzb24gb2Yga1xcblxcdFxcdFxcdHdoaWxlIChqIDw9IHRoYXQuaGVhcF9sZW4pIHtcXG5cXHRcXHRcXHRcXHQvLyBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOlxcblxcdFxcdFxcdFxcdGlmIChqIDwgdGhhdC5oZWFwX2xlbiAmJiBzbWFsbGVyKHRyZWUsIGhlYXBbaiArIDFdLCBoZWFwW2pdLCB0aGF0LmRlcHRoKSkge1xcblxcdFxcdFxcdFxcdFxcdGorKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnNcXG5cXHRcXHRcXHRcXHRpZiAoc21hbGxlcih0cmVlLCB2LCBoZWFwW2pdLCB0aGF0LmRlcHRoKSlcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvblxcblxcdFxcdFxcdFxcdGhlYXBba10gPSBoZWFwW2pdO1xcblxcdFxcdFxcdFxcdGsgPSBqO1xcblxcdFxcdFxcdFxcdC8vIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGtcXG5cXHRcXHRcXHRcXHRqIDw8PSAxO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRoZWFwW2tdID0gdjtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcXG5cXHRcXHQvLyBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxcblxcdFxcdGZ1bmN0aW9uIHNjYW5fdHJlZSh0cmVlLC8vIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWRcXG5cXHRcXHRtYXhfY29kZSAvLyBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3lcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHR2YXIgbjsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xcblxcdFxcdFxcdHZhciBwcmV2bGVuID0gLTE7IC8vIGxhc3QgZW1pdHRlZCBsZW5ndGhcXG5cXHRcXHRcXHR2YXIgY3VybGVuOyAvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV07IC8vIGxlbmd0aCBvZiBuZXh0IGNvZGVcXG5cXHRcXHRcXHR2YXIgY291bnQgPSAwOyAvLyByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZVxcblxcdFxcdFxcdHZhciBtYXhfY291bnQgPSA3OyAvLyBtYXggcmVwZWF0IGNvdW50XFxuXFx0XFx0XFx0dmFyIG1pbl9jb3VudCA9IDQ7IC8vIG1pbiByZXBlYXQgY291bnRcXG5cXG5cXHRcXHRcXHRpZiAobmV4dGxlbiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdG1heF9jb3VudCA9IDEzODtcXG5cXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdID0gMHhmZmZmOyAvLyBndWFyZFxcblxcblxcdFxcdFxcdGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xcblxcdFxcdFxcdFxcdGN1cmxlbiA9IG5leHRsZW47XFxuXFx0XFx0XFx0XFx0bmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXTtcXG5cXHRcXHRcXHRcXHRpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT0gbmV4dGxlbikge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW2N1cmxlbiAqIDJdICs9IGNvdW50O1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGN1cmxlbiAhPSBwcmV2bGVuKVxcblxcdFxcdFxcdFxcdFxcdFxcdGJsX3RyZWVbY3VybGVuICogMl0rKztcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW1JFUF8zXzYgKiAyXSsrO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW1JFUFpfM18xMCAqIDJdKys7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRibF90cmVlW1JFUFpfMTFfMTM4ICogMl0rKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y291bnQgPSAwO1xcblxcdFxcdFxcdFxcdHByZXZsZW4gPSBjdXJsZW47XFxuXFx0XFx0XFx0XFx0aWYgKG5leHRsZW4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSAxMzg7XFxuXFx0XFx0XFx0XFx0XFx0bWluX2NvdW50ID0gMztcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNjtcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNztcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSA0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cXG5cXHRcXHQvLyBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cXG5cXHRcXHRmdW5jdGlvbiBidWlsZF9ibF90cmVlKCkge1xcblxcdFxcdFxcdHZhciBtYXhfYmxpbmRleDsgLy8gaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcVxcblxcblxcdFxcdFxcdC8vIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXNcXG5cXHRcXHRcXHRzY2FuX3RyZWUoZHluX2x0cmVlLCBsX2Rlc2MubWF4X2NvZGUpO1xcblxcdFxcdFxcdHNjYW5fdHJlZShkeW5fZHRyZWUsIGRfZGVzYy5tYXhfY29kZSk7XFxuXFxuXFx0XFx0XFx0Ly8gQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTpcXG5cXHRcXHRcXHRibF9kZXNjLmJ1aWxkX3RyZWUodGhhdCk7XFxuXFx0XFx0XFx0Ly8gb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxcblxcdFxcdFxcdC8vIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZVxcblxcdFxcdFxcdC8vIGNvdW50cy5cXG5cXG5cXHRcXHRcXHQvLyBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcXG5cXHRcXHRcXHQvLyByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xcblxcdFxcdFxcdC8vIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcXG5cXHRcXHRcXHRmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGJsX3RyZWVbVHJlZS5ibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzXFxuXFx0XFx0XFx0dGhhdC5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF4X2JsaW5kZXg7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE91dHB1dCBhIGJ5dGUgb24gdGhlIHN0cmVhbS5cXG5cXHRcXHQvLyBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdfYnVmLlxcblxcdFxcdGZ1bmN0aW9uIHB1dF9ieXRlKHApIHtcXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmW3RoYXQucGVuZGluZysrXSA9IHA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHB1dF9zaG9ydCh3KSB7XFxuXFx0XFx0XFx0cHV0X2J5dGUodyAmIDB4ZmYpO1xcblxcdFxcdFxcdHB1dF9ieXRlKCh3ID4+PiA4KSAmIDB4ZmYpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBwdXRTaG9ydE1TQihiKSB7XFxuXFx0XFx0XFx0cHV0X2J5dGUoKGIgPj4gOCkgJiAweGZmKTtcXG5cXHRcXHRcXHRwdXRfYnl0ZSgoYiAmIDB4ZmYpICYgMHhmZik7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNlbmRfYml0cyh2YWx1ZSwgbGVuZ3RoKSB7XFxuXFx0XFx0XFx0dmFyIHZhbCwgbGVuID0gbGVuZ3RoO1xcblxcdFxcdFxcdGlmIChiaV92YWxpZCA+IEJ1Zl9zaXplIC0gbGVuKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0Ly8gYmlfYnVmIHw9ICh2YWwgPDwgYmlfdmFsaWQpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiB8PSAoKHZhbCA8PCBiaV92YWxpZCkgJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdHB1dF9zaG9ydChiaV9idWYpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiA9IHZhbCA+Pj4gKEJ1Zl9zaXplIC0gYmlfdmFsaWQpO1xcblxcdFxcdFxcdFxcdGJpX3ZhbGlkICs9IGxlbiAtIEJ1Zl9zaXplO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Ly8gYmlfYnVmIHw9ICh2YWx1ZSkgPDwgYmlfdmFsaWQ7XFxuXFx0XFx0XFx0XFx0YmlfYnVmIHw9ICgoKHZhbHVlKSA8PCBiaV92YWxpZCkgJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdGJpX3ZhbGlkICs9IGxlbjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNlbmRfY29kZShjLCB0cmVlKSB7XFxuXFx0XFx0XFx0dmFyIGMyID0gYyAqIDI7XFxuXFx0XFx0XFx0c2VuZF9iaXRzKHRyZWVbYzJdICYgMHhmZmZmLCB0cmVlW2MyICsgMV0gJiAweGZmZmYpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXFxuXFx0XFx0Ly8gYmxfdHJlZS5cXG5cXHRcXHRmdW5jdGlvbiBzZW5kX3RyZWUodHJlZSwvLyB0aGUgdHJlZSB0byBiZSBzZW50XFxuXFx0XFx0bWF4X2NvZGUgLy8gYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5XFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIG47IC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHNcXG5cXHRcXHRcXHR2YXIgcHJldmxlbiA9IC0xOyAvLyBsYXN0IGVtaXR0ZWQgbGVuZ3RoXFxuXFx0XFx0XFx0dmFyIGN1cmxlbjsgLy8gbGVuZ3RoIG9mIGN1cnJlbnQgY29kZVxcblxcdFxcdFxcdHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdOyAvLyBsZW5ndGggb2YgbmV4dCBjb2RlXFxuXFx0XFx0XFx0dmFyIGNvdW50ID0gMDsgLy8gcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGVcXG5cXHRcXHRcXHR2YXIgbWF4X2NvdW50ID0gNzsgLy8gbWF4IHJlcGVhdCBjb3VudFxcblxcdFxcdFxcdHZhciBtaW5fY291bnQgPSA0OyAvLyBtaW4gcmVwZWF0IGNvdW50XFxuXFxuXFx0XFx0XFx0aWYgKG5leHRsZW4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRtYXhfY291bnQgPSAxMzg7XFxuXFx0XFx0XFx0XFx0bWluX2NvdW50ID0gMztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XFxuXFx0XFx0XFx0XFx0Y3VybGVuID0gbmV4dGxlbjtcXG5cXHRcXHRcXHRcXHRuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdO1xcblxcdFxcdFxcdFxcdGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xcblxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoY3VybGVuLCBibF90cmVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChjdXJsZW4gIT0gcHJldmxlbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShjdXJsZW4sIGJsX3RyZWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShSRVBfM182LCBibF90cmVlKTtcXG5cXHRcXHRcXHRcXHRcXHRzZW5kX2JpdHMoY291bnQgLSAzLCAyKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2VuZF9jb2RlKFJFUFpfM18xMCwgYmxfdHJlZSk7XFxuXFx0XFx0XFx0XFx0XFx0c2VuZF9iaXRzKGNvdW50IC0gMywgMyk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoUkVQWl8xMV8xMzgsIGJsX3RyZWUpO1xcblxcdFxcdFxcdFxcdFxcdHNlbmRfYml0cyhjb3VudCAtIDExLCA3KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y291bnQgPSAwO1xcblxcdFxcdFxcdFxcdHByZXZsZW4gPSBjdXJsZW47XFxuXFx0XFx0XFx0XFx0aWYgKG5leHRsZW4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfY291bnQgPSAxMzg7XFxuXFx0XFx0XFx0XFx0XFx0bWluX2NvdW50ID0gMztcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGN1cmxlbiA9PSBuZXh0bGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNjtcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSAzO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF4X2NvdW50ID0gNztcXG5cXHRcXHRcXHRcXHRcXHRtaW5fY291bnQgPSA0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxcblxcdFxcdC8vIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxcblxcdFxcdC8vIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cXG5cXHRcXHRmdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhsY29kZXMsIGRjb2RlcywgYmxjb2Rlcykge1xcblxcdFxcdFxcdHZhciByYW5rOyAvLyBpbmRleCBpbiBibF9vcmRlclxcblxcblxcdFxcdFxcdHNlbmRfYml0cyhsY29kZXMgLSAyNTcsIDUpOyAvLyBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHRcXG5cXHRcXHRcXHRzZW5kX2JpdHMoZGNvZGVzIC0gMSwgNSk7XFxuXFx0XFx0XFx0c2VuZF9iaXRzKGJsY29kZXMgLSA0LCA0KTsgLy8gbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dFxcblxcdFxcdFxcdGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcXG5cXHRcXHRcXHRcXHRzZW5kX2JpdHMoYmxfdHJlZVtUcmVlLmJsX29yZGVyW3JhbmtdICogMiArIDFdLCAzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0c2VuZF90cmVlKGR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8vIGxpdGVyYWwgdHJlZVxcblxcdFxcdFxcdHNlbmRfdHJlZShkeW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvLyBkaXN0YW5jZSB0cmVlXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxcblxcdFxcdGZ1bmN0aW9uIGJpX2ZsdXNoKCkge1xcblxcdFxcdFxcdGlmIChiaV92YWxpZCA9PSAxNikge1xcblxcdFxcdFxcdFxcdHB1dF9zaG9ydChiaV9idWYpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiA9IDA7XFxuXFx0XFx0XFx0XFx0YmlfdmFsaWQgPSAwO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoYmlfdmFsaWQgPj0gOCkge1xcblxcdFxcdFxcdFxcdHB1dF9ieXRlKGJpX2J1ZiAmIDB4ZmYpO1xcblxcdFxcdFxcdFxcdGJpX2J1ZiA+Pj49IDg7XFxuXFx0XFx0XFx0XFx0YmlfdmFsaWQgLT0gODtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXFxuXFx0XFx0Ly8gVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXFxuXFx0XFx0Ly8gVGhlIGN1cnJlbnQgaW5mbGF0ZSBjb2RlIHJlcXVpcmVzIDkgYml0cyBvZiBsb29rYWhlYWQuIElmIHRoZVxcblxcdFxcdC8vIGxhc3QgdHdvIGNvZGVzIGZvciB0aGUgcHJldmlvdXMgYmxvY2sgKHJlYWwgY29kZSBwbHVzIEVPQikgd2VyZSBjb2RlZFxcblxcdFxcdC8vIG9uIDUgYml0cyBvciBsZXNzLCBpbmZsYXRlIG1heSBoYXZlIG9ubHkgNSszIGJpdHMgb2YgbG9va2FoZWFkIHRvIGRlY29kZVxcblxcdFxcdC8vIHRoZSBsYXN0IHJlYWwgY29kZS4gSW4gdGhpcyBjYXNlIHdlIHNlbmQgdHdvIGVtcHR5IHN0YXRpYyBibG9ja3MgaW5zdGVhZFxcblxcdFxcdC8vIG9mIG9uZS4gKFRoZXJlIGFyZSBubyBwcm9ibGVtcyBpZiB0aGUgcHJldmlvdXMgYmxvY2sgaXMgc3RvcmVkIG9yIGZpeGVkLilcXG5cXHRcXHQvLyBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgYXNzdW1lIHRoZSB3b3JzdCBjYXNlIG9mIGxhc3QgcmVhbCBjb2RlIGVuY29kZWRcXG5cXHRcXHQvLyBvbiBvbmUgYml0IG9ubHkuXFxuXFx0XFx0ZnVuY3Rpb24gX3RyX2FsaWduKCkge1xcblxcdFxcdFxcdHNlbmRfYml0cyhTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XFxuXFx0XFx0XFx0c2VuZF9jb2RlKEVORF9CTE9DSywgU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUpO1xcblxcblxcdFxcdFxcdGJpX2ZsdXNoKCk7XFxuXFxuXFx0XFx0XFx0Ly8gT2YgdGhlIDEwIGJpdHMgZm9yIHRoZSBlbXB0eSBibG9jaywgd2UgaGF2ZSBhbHJlYWR5IHNlbnRcXG5cXHRcXHRcXHQvLyAoMTAgLSBiaV92YWxpZCkgYml0cy4gVGhlIGxvb2thaGVhZCBmb3IgdGhlIGxhc3QgcmVhbCBjb2RlIChiZWZvcmVcXG5cXHRcXHRcXHQvLyB0aGUgRU9CIG9mIHRoZSBwcmV2aW91cyBibG9jaykgd2FzIHRodXMgYXQgbGVhc3Qgb25lIHBsdXMgdGhlIGxlbmd0aFxcblxcdFxcdFxcdC8vIG9mIHRoZSBFT0IgcGx1cyB3aGF0IHdlIGhhdmUganVzdCBzZW50IG9mIHRoZSBlbXB0eSBzdGF0aWMgYmxvY2suXFxuXFx0XFx0XFx0aWYgKDEgKyBsYXN0X2VvYl9sZW4gKyAxMCAtIGJpX3ZhbGlkIDwgOSkge1xcblxcdFxcdFxcdFxcdHNlbmRfYml0cyhTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XFxuXFx0XFx0XFx0XFx0c2VuZF9jb2RlKEVORF9CTE9DSywgU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUpO1xcblxcdFxcdFxcdFxcdGJpX2ZsdXNoKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGxhc3RfZW9iX2xlbiA9IDc7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxcblxcdFxcdC8vIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cXG5cXHRcXHRmdW5jdGlvbiBfdHJfdGFsbHkoZGlzdCwgLy8gZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmdcXG5cXHRcXHRsYyAvLyBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKVxcblxcdFxcdCkge1xcblxcdFxcdFxcdHZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBsYXN0X2xpdCAqIDJdID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmW2RfYnVmICsgbGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcXG5cXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmW2xfYnVmICsgbGFzdF9saXRdID0gbGMgJiAweGZmO1xcblxcdFxcdFxcdGxhc3RfbGl0Kys7XFxuXFxuXFx0XFx0XFx0aWYgKGRpc3QgPT09IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXJcXG5cXHRcXHRcXHRcXHRkeW5fbHRyZWVbbGMgKiAyXSsrO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlcysrO1xcblxcdFxcdFxcdFxcdC8vIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0hcXG5cXHRcXHRcXHRcXHRkaXN0LS07IC8vIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDFcXG5cXHRcXHRcXHRcXHRkeW5fbHRyZWVbKFRyZWUuX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXSsrO1xcblxcdFxcdFxcdFxcdGR5bl9kdHJlZVtUcmVlLmRfY29kZShkaXN0KSAqIDJdKys7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgobGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIGxldmVsID4gMikge1xcblxcdFxcdFxcdFxcdC8vIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aFxcblxcdFxcdFxcdFxcdG91dF9sZW5ndGggPSBsYXN0X2xpdCAqIDg7XFxuXFx0XFx0XFx0XFx0aW5fbGVuZ3RoID0gc3Ryc3RhcnQgLSBibG9ja19zdGFydDtcXG5cXHRcXHRcXHRcXHRmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3V0X2xlbmd0aCArPSBkeW5fZHRyZWVbZGNvZGUgKiAyXSAqICg1ICsgVHJlZS5leHRyYV9kYml0c1tkY29kZV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRvdXRfbGVuZ3RoID4+Pj0gMztcXG5cXHRcXHRcXHRcXHRpZiAoKG1hdGNoZXMgPCBNYXRoLmZsb29yKGxhc3RfbGl0IC8gMikpICYmIG91dF9sZW5ndGggPCBNYXRoLmZsb29yKGluX2xlbmd0aCAvIDIpKVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gKGxhc3RfbGl0ID09IGxpdF9idWZzaXplIC0gMSk7XFxuXFx0XFx0XFx0Ly8gV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXFxuXFx0XFx0XFx0Ly8gb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cXG5cXHRcXHRcXHQvLyA2NEstMSBieXRlcy5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXFxuXFx0XFx0ZnVuY3Rpb24gY29tcHJlc3NfYmxvY2sobHRyZWUsIGR0cmVlKSB7XFxuXFx0XFx0XFx0dmFyIGRpc3Q7IC8vIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nXFxuXFx0XFx0XFx0dmFyIGxjOyAvLyBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT09IDApXFxuXFx0XFx0XFx0dmFyIGx4ID0gMDsgLy8gcnVubmluZyBpbmRleCBpbiBsX2J1ZlxcblxcdFxcdFxcdHZhciBjb2RlOyAvLyB0aGUgY29kZSB0byBzZW5kXFxuXFx0XFx0XFx0dmFyIGV4dHJhOyAvLyBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kXFxuXFxuXFx0XFx0XFx0aWYgKGxhc3RfbGl0ICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdGRpc3QgPSAoKHRoYXQucGVuZGluZ19idWZbZF9idWYgKyBseCAqIDJdIDw8IDgpICYgMHhmZjAwKSB8ICh0aGF0LnBlbmRpbmdfYnVmW2RfYnVmICsgbHggKiAyICsgMV0gJiAweGZmKTtcXG5cXHRcXHRcXHRcXHRcXHRsYyA9ICh0aGF0LnBlbmRpbmdfYnVmW2xfYnVmICsgbHhdKSAmIDB4ZmY7XFxuXFx0XFx0XFx0XFx0XFx0bHgrKztcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZGlzdCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfY29kZShsYywgbHRyZWUpOyAvLyBzZW5kIGEgbGl0ZXJhbCBieXRlXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29kZSA9IFRyZWUuX2xlbmd0aF9jb2RlW2xjXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvLyBzZW5kIHRoZSBsZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0cmEgPSBUcmVlLmV4dHJhX2xiaXRzW2NvZGVdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChleHRyYSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxjIC09IFRyZWUuYmFzZV9sZW5ndGhbY29kZV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9iaXRzKGxjLCBleHRyYSk7IC8vIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGRpc3QtLTsgLy8gZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMVxcblxcdFxcdFxcdFxcdFxcdFxcdGNvZGUgPSBUcmVlLmRfY29kZShkaXN0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2NvZGUoY29kZSwgZHRyZWUpOyAvLyBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0cmEgPSBUcmVlLmV4dHJhX2RiaXRzW2NvZGVdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChleHRyYSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3QgLT0gVHJlZS5iYXNlX2Rpc3RbY29kZV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VuZF9iaXRzKGRpc3QsIGV4dHJhKTsgLy8gc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IC8vIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpc1xcblxcdFxcdFxcdFxcdFxcdC8vIG9rOlxcblxcdFxcdFxcdFxcdH0gd2hpbGUgKGx4IDwgbGFzdF9saXQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzZW5kX2NvZGUoRU5EX0JMT0NLLCBsdHJlZSk7XFxuXFx0XFx0XFx0bGFzdF9lb2JfbGVuID0gbHRyZWVbRU5EX0JMT0NLICogMiArIDFdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcXG5cXHRcXHRmdW5jdGlvbiBiaV93aW5kdXAoKSB7XFxuXFx0XFx0XFx0aWYgKGJpX3ZhbGlkID4gOCkge1xcblxcdFxcdFxcdFxcdHB1dF9zaG9ydChiaV9idWYpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoYmlfdmFsaWQgPiAwKSB7XFxuXFx0XFx0XFx0XFx0cHV0X2J5dGUoYmlfYnVmICYgMHhmZik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGJpX2J1ZiA9IDA7XFxuXFx0XFx0XFx0YmlfdmFsaWQgPSAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xcblxcdFxcdC8vIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxcblxcdFxcdGZ1bmN0aW9uIGNvcHlfYmxvY2soYnVmLCAvLyB0aGUgaW5wdXQgZGF0YVxcblxcdFxcdGxlbiwgLy8gaXRzIGxlbmd0aFxcblxcdFxcdGhlYWRlciAvLyB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW5cXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHRiaV93aW5kdXAoKTsgLy8gYWxpZ24gb24gYnl0ZSBib3VuZGFyeVxcblxcdFxcdFxcdGxhc3RfZW9iX2xlbiA9IDg7IC8vIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGVcXG5cXG5cXHRcXHRcXHRpZiAoaGVhZGVyKSB7XFxuXFx0XFx0XFx0XFx0cHV0X3Nob3J0KGxlbik7XFxuXFx0XFx0XFx0XFx0cHV0X3Nob3J0KH5sZW4pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmLnNldCh3aW5kb3cuc3ViYXJyYXkoYnVmLCBidWYgKyBsZW4pLCB0aGF0LnBlbmRpbmcpO1xcblxcdFxcdFxcdHRoYXQucGVuZGluZyArPSBsZW47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNlbmQgYSBzdG9yZWQgYmxvY2tcXG5cXHRcXHRmdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKGJ1ZiwgLy8gaW5wdXQgYmxvY2tcXG5cXHRcXHRzdG9yZWRfbGVuLCAvLyBsZW5ndGggb2YgaW5wdXQgYmxvY2tcXG5cXHRcXHRlb2YgLy8gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGVcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHRzZW5kX2JpdHMoKFNUT1JFRF9CTE9DSyA8PCAxKSArIChlb2YgPyAxIDogMCksIDMpOyAvLyBzZW5kIGJsb2NrIHR5cGVcXG5cXHRcXHRcXHRjb3B5X2Jsb2NrKGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8vIHdpdGggaGVhZGVyXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xcblxcdFxcdC8vIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cXG5cXHRcXHRmdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2soYnVmLCAvLyBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkXFxuXFx0XFx0c3RvcmVkX2xlbiwgLy8gbGVuZ3RoIG9mIGlucHV0IGJsb2NrXFxuXFx0XFx0ZW9mIC8vIHRydWUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsvLyBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzXFxuXFx0XFx0XFx0dmFyIG1heF9ibGluZGV4ID0gMDsgLy8gaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcVxcblxcblxcdFxcdFxcdC8vIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWRcXG5cXHRcXHRcXHRpZiAobGV2ZWwgPiAwKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlc1xcblxcdFxcdFxcdFxcdGxfZGVzYy5idWlsZF90cmVlKHRoYXQpO1xcblxcblxcdFxcdFxcdFxcdGRfZGVzYy5idWlsZF90cmVlKHRoYXQpO1xcblxcblxcdFxcdFxcdFxcdC8vIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3Roc1xcblxcdFxcdFxcdFxcdC8vIG9mXFxuXFx0XFx0XFx0XFx0Ly8gdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cXG5cXG5cXHRcXHRcXHRcXHQvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZVxcblxcdFxcdFxcdFxcdC8vIGluZGV4XFxuXFx0XFx0XFx0XFx0Ly8gaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXFxuXFx0XFx0XFx0XFx0bWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIGZpcnN0IHRoZSBibG9jayBsZW5ndGggaW5cXG5cXHRcXHRcXHRcXHQvLyBieXRlc1xcblxcdFxcdFxcdFxcdG9wdF9sZW5iID0gKHRoYXQub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcXG5cXHRcXHRcXHRcXHRzdGF0aWNfbGVuYiA9ICh0aGF0LnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKVxcblxcdFxcdFxcdFxcdFxcdG9wdF9sZW5iID0gc3RhdGljX2xlbmI7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8vIGZvcmNlIGEgc3RvcmVkIGJsb2NrXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIGJ1ZiAhPSAtMSkge1xcblxcdFxcdFxcdFxcdC8vIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHNcXG5cXHRcXHRcXHRcXHQvLyBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXNcXG5cXHRcXHRcXHRcXHQvLyBzaW5jZVxcblxcdFxcdFxcdFxcdC8vIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxcblxcdFxcdFxcdFxcdC8vIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xcblxcdFxcdFxcdFxcdC8vIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXFxuXFx0XFx0XFx0XFx0X3RyX3N0b3JlZF9ibG9jayhidWYsIHN0b3JlZF9sZW4sIGVvZik7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChzdGF0aWNfbGVuYiA9PSBvcHRfbGVuYikge1xcblxcdFxcdFxcdFxcdHNlbmRfYml0cygoU1RBVElDX1RSRUVTIDw8IDEpICsgKGVvZiA/IDEgOiAwKSwgMyk7XFxuXFx0XFx0XFx0XFx0Y29tcHJlc3NfYmxvY2soU3RhdGljVHJlZS5zdGF0aWNfbHRyZWUsIFN0YXRpY1RyZWUuc3RhdGljX2R0cmVlKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHNlbmRfYml0cygoRFlOX1RSRUVTIDw8IDEpICsgKGVvZiA/IDEgOiAwKSwgMyk7XFxuXFx0XFx0XFx0XFx0c2VuZF9hbGxfdHJlZXMobF9kZXNjLm1heF9jb2RlICsgMSwgZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcXG5cXHRcXHRcXHRcXHRjb21wcmVzc19ibG9jayhkeW5fbHRyZWUsIGR5bl9kdHJlZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXFxuXFx0XFx0XFx0Ly8gYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXFxuXFxuXFx0XFx0XFx0aW5pdF9ibG9jaygpO1xcblxcblxcdFxcdFxcdGlmIChlb2YpIHtcXG5cXHRcXHRcXHRcXHRiaV93aW5kdXAoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkoZW9mKSB7XFxuXFx0XFx0XFx0X3RyX2ZsdXNoX2Jsb2NrKGJsb2NrX3N0YXJ0ID49IDAgPyBibG9ja19zdGFydCA6IC0xLCBzdHJzdGFydCAtIGJsb2NrX3N0YXJ0LCBlb2YpO1xcblxcdFxcdFxcdGJsb2NrX3N0YXJ0ID0gc3Ryc3RhcnQ7XFxuXFx0XFx0XFx0c3RybS5mbHVzaF9wZW5kaW5nKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXFxuXFx0XFx0Ly8gVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXFxuXFx0XFx0Ly8gT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcXG5cXHRcXHQvLyBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PT0gMDsgcmVhZHMgYXJlXFxuXFx0XFx0Ly8gcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcXG5cXHRcXHQvLyBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cXG5cXHRcXHRmdW5jdGlvbiBmaWxsX3dpbmRvdygpIHtcXG5cXHRcXHRcXHR2YXIgbiwgbTtcXG5cXHRcXHRcXHR2YXIgcDtcXG5cXHRcXHRcXHR2YXIgbW9yZTsgLy8gQW1vdW50IG9mIGZyZWUgc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgd2luZG93LlxcblxcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRtb3JlID0gKHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnQpO1xcblxcblxcdFxcdFxcdFxcdC8vIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6XFxuXFx0XFx0XFx0XFx0aWYgKG1vcmUgPT09IDAgJiYgc3Ryc3RhcnQgPT09IDAgJiYgbG9va2FoZWFkID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0bW9yZSA9IHdfc2l6ZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG1vcmUgPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWYgc3Ryc3RhcnQgPT1cXG5cXHRcXHRcXHRcXHRcXHQvLyAwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYW5kIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIG9uZSBieXRlIGF0IHRpbWUpXFxuXFx0XFx0XFx0XFx0XFx0bW9yZS0tO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudFxcblxcdFxcdFxcdFxcdFxcdC8vIGxvb2thaGVhZCxcXG5cXHRcXHRcXHRcXHRcXHQvLyBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZVxcblxcdFxcdFxcdFxcdFxcdC8vIHVwcGVyIGhhbGYuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChzdHJzdGFydCA+PSB3X3NpemUgKyB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LnNldCh3aW5kb3cuc3ViYXJyYXkod19zaXplLCB3X3NpemUgKyB3X3NpemUpLCAwKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9zdGFydCAtPSB3X3NpemU7XFxuXFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQgLT0gd19zaXplOyAvLyB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVFxcblxcdFxcdFxcdFxcdFxcdGJsb2NrX3N0YXJ0IC09IHdfc2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHQvLyBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT1cXG5cXHRcXHRcXHRcXHRcXHQvLyAwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gPiAwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXFxuXFx0XFx0XFx0XFx0XFx0Ly8gemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcXG5cXG5cXHRcXHRcXHRcXHRcXHRuID0gaGFzaF9zaXplO1xcblxcdFxcdFxcdFxcdFxcdHAgPSBuO1xcblxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtID0gKGhlYWRbLS1wXSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtwXSA9IChtID49IHdfc2l6ZSA/IG0gLSB3X3NpemUgOiAwKTtcXG5cXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLW4gIT09IDApO1xcblxcblxcdFxcdFxcdFxcdFxcdG4gPSB3X3NpemU7XFxuXFx0XFx0XFx0XFx0XFx0cCA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdG0gPSAocHJldlstLXBdICYgMHhmZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2W3BdID0gKG0gPj0gd19zaXplID8gbSAtIHdfc2l6ZSA6IDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cXG5cXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLW4gIT09IDApO1xcblxcdFxcdFxcdFxcdFxcdG1vcmUgKz0gd19zaXplO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XFxuXFx0XFx0XFx0XFx0Ly8gc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcXG5cXHRcXHRcXHRcXHQvLyBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcXG5cXHRcXHRcXHRcXHQvLyA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcXG5cXHRcXHRcXHRcXHQvLyA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcXG5cXHRcXHRcXHRcXHQvLyBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcXG5cXHRcXHRcXHRcXHQvLyB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAmJlxcblxcdFxcdFxcdFxcdC8vIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxcblxcblxcdFxcdFxcdFxcdG4gPSBzdHJtLnJlYWRfYnVmKHdpbmRvdywgc3Ryc3RhcnQgKyBsb29rYWhlYWQsIG1vcmUpO1xcblxcdFxcdFxcdFxcdGxvb2thaGVhZCArPSBuO1xcblxcblxcdFxcdFxcdFxcdC8vIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OlxcblxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zX2ggPSB3aW5kb3dbc3Ryc3RhcnRdICYgMHhmZjtcXG5cXHRcXHRcXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbc3Ryc3RhcnQgKyAxXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpc1xcblxcdFxcdFxcdFxcdC8vIGdhcmJhZ2UsXFxuXFx0XFx0XFx0XFx0Ly8gYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZVxcblxcdFxcdFxcdFxcdC8vIGVtaXR0ZWQuXFxuXFx0XFx0XFx0fSB3aGlsZSAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLFxcblxcdFxcdC8vIHJldHVyblxcblxcdFxcdC8vIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxcblxcdFxcdC8vIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXFxuXFx0XFx0Ly8gdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcXG5cXHRcXHQvLyBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXFxuXFx0XFx0Ly8gTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxcblxcdFxcdC8vIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cXG5cXHRcXHRmdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChmbHVzaCkge1xcblxcdFxcdFxcdC8vIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXFxuXFx0XFx0XFx0Ly8gdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XFxuXFxuXFx0XFx0XFx0dmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xcblxcdFxcdFxcdHZhciBtYXhfc3RhcnQ7XFxuXFxuXFx0XFx0XFx0aWYgKG1heF9ibG9ja19zaXplID4gcGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcXG5cXHRcXHRcXHRcXHRtYXhfYmxvY2tfc2l6ZSA9IHBlbmRpbmdfYnVmX3NpemUgLSA1O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6XFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHQvLyBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTpcXG5cXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkIDw9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRmaWxsX3dpbmRvdygpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT0gWl9OT19GTFVTSClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c3Ryc3RhcnQgKz0gbG9va2FoZWFkO1xcblxcdFxcdFxcdFxcdGxvb2thaGVhZCA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6XFxuXFx0XFx0XFx0XFx0bWF4X3N0YXJ0ID0gYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcXG5cXHRcXHRcXHRcXHRpZiAoc3Ryc3RhcnQgPT09IDAgfHwgc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3Ryc3RhcnQgPT09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lXFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkID0gKHN0cnN0YXJ0IC0gbWF4X3N0YXJ0KTtcXG5cXHRcXHRcXHRcXHRcXHRzdHJzdGFydCA9IG1heF9zdGFydDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIE5lZWRNb3JlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcXG5cXHRcXHRcXHRcXHQvLyBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxcblxcdFxcdFxcdFxcdGlmIChzdHJzdGFydCAtIGJsb2NrX3N0YXJ0ID49IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHtcXG5cXHRcXHRcXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIE5lZWRNb3JlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmbHVzaCA9PSBaX0ZJTklTSCk7XFxuXFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybiAoZmx1c2ggPT0gWl9GSU5JU0gpID8gRmluaXNoU3RhcnRlZCA6IE5lZWRNb3JlO1xcblxcblxcdFxcdFxcdHJldHVybiBmbHVzaCA9PSBaX0ZJTklTSCA/IEZpbmlzaERvbmUgOiBCbG9ja0RvbmU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2goY3VyX21hdGNoKSB7XFxuXFx0XFx0XFx0dmFyIGNoYWluX2xlbmd0aCA9IG1heF9jaGFpbl9sZW5ndGg7IC8vIG1heCBoYXNoIGNoYWluIGxlbmd0aFxcblxcdFxcdFxcdHZhciBzY2FuID0gc3Ryc3RhcnQ7IC8vIGN1cnJlbnQgc3RyaW5nXFxuXFx0XFx0XFx0dmFyIG1hdGNoOyAvLyBtYXRjaGVkIHN0cmluZ1xcblxcdFxcdFxcdHZhciBsZW47IC8vIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoXFxuXFx0XFx0XFx0dmFyIGJlc3RfbGVuID0gcHJldl9sZW5ndGg7IC8vIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhclxcblxcdFxcdFxcdHZhciBsaW1pdCA9IHN0cnN0YXJ0ID4gKHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQpID8gc3Ryc3RhcnQgLSAod19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwO1xcblxcdFxcdFxcdHZhciBfbmljZV9tYXRjaCA9IG5pY2VfbWF0Y2g7XFxuXFxuXFx0XFx0XFx0Ly8gU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcXG5cXHRcXHRcXHQvLyB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxcblxcblxcdFxcdFxcdHZhciB3bWFzayA9IHdfbWFzaztcXG5cXG5cXHRcXHRcXHR2YXIgc3RyZW5kID0gc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XFxuXFx0XFx0XFx0dmFyIHNjYW5fZW5kMSA9IHdpbmRvd1tzY2FuICsgYmVzdF9sZW4gLSAxXTtcXG5cXHRcXHRcXHR2YXIgc2Nhbl9lbmQgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuXTtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZlxcblxcdFxcdFxcdC8vIDE2LlxcblxcdFxcdFxcdC8vIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXFxuXFxuXFx0XFx0XFx0Ly8gRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDpcXG5cXHRcXHRcXHRpZiAocHJldl9sZW5ndGggPj0gZ29vZF9tYXRjaCkge1xcblxcdFxcdFxcdFxcdGNoYWluX2xlbmd0aCA+Pj0gMjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzXFxuXFx0XFx0XFx0Ly8gbmVjZXNzYXJ5XFxuXFx0XFx0XFx0Ly8gdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXFxuXFx0XFx0XFx0aWYgKF9uaWNlX21hdGNoID4gbG9va2FoZWFkKVxcblxcdFxcdFxcdFxcdF9uaWNlX21hdGNoID0gbG9va2FoZWFkO1xcblxcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRtYXRjaCA9IGN1cl9tYXRjaDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcXG5cXHRcXHRcXHRcXHQvLyBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyOlxcblxcdFxcdFxcdFxcdGlmICh3aW5kb3dbbWF0Y2ggKyBiZXN0X2xlbl0gIT0gc2Nhbl9lbmQgfHwgd2luZG93W21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPSBzY2FuX2VuZDEgfHwgd2luZG93W21hdGNoXSAhPSB3aW5kb3dbc2Nhbl1cXG5cXHRcXHRcXHRcXHRcXHRcXHR8fCB3aW5kb3dbKyttYXRjaF0gIT0gd2luZG93W3NjYW4gKyAxXSlcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxcblxcdFxcdFxcdFxcdC8vIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXFxuXFx0XFx0XFx0XFx0Ly8gSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcXG5cXHRcXHRcXHRcXHQvLyBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XFxuXFx0XFx0XFx0XFx0Ly8gdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXFxuXFx0XFx0XFx0XFx0c2NhbiArPSAyO1xcblxcdFxcdFxcdFxcdG1hdGNoKys7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcXG5cXHRcXHRcXHRcXHQvLyB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAod2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF1cXG5cXHRcXHRcXHRcXHRcXHRcXHQmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgd2luZG93Wysrc2Nhbl0gPT0gd2luZG93WysrbWF0Y2hdICYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXVxcblxcdFxcdFxcdFxcdFxcdFxcdCYmIHdpbmRvd1srK3NjYW5dID09IHdpbmRvd1srK21hdGNoXSAmJiB3aW5kb3dbKytzY2FuXSA9PSB3aW5kb3dbKyttYXRjaF0gJiYgc2NhbiA8IHN0cmVuZCk7XFxuXFxuXFx0XFx0XFx0XFx0bGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xcblxcdFxcdFxcdFxcdHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGxlbiA+IGJlc3RfbGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XFxuXFx0XFx0XFx0XFx0XFx0YmVzdF9sZW4gPSBsZW47XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxlbiA+PSBfbmljZV9tYXRjaClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRzY2FuX2VuZDEgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuIC0gMV07XFxuXFx0XFx0XFx0XFx0XFx0c2Nhbl9lbmQgPSB3aW5kb3dbc2NhbiArIGJlc3RfbGVuXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSB3aGlsZSAoKGN1cl9tYXRjaCA9IChwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSAmIDB4ZmZmZikpID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xcblxcblxcdFxcdFxcdGlmIChiZXN0X2xlbiA8PSBsb29rYWhlYWQpXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGJlc3RfbGVuO1xcblxcdFxcdFxcdHJldHVybiBsb29rYWhlYWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcXG5cXHRcXHQvLyBibG9jayBzdGF0ZS5cXG5cXHRcXHQvLyBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcXG5cXHRcXHQvLyBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcXG5cXHRcXHQvLyBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXFxuXFx0XFx0ZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KGZsdXNoKSB7XFxuXFx0XFx0XFx0Ly8gc2hvcnQgaGFzaF9oZWFkID0gMDsgLy8gaGVhZCBvZiB0aGUgaGFzaCBjaGFpblxcblxcdFxcdFxcdHZhciBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIHRoZSBoYXNoIGNoYWluXFxuXFx0XFx0XFx0dmFyIGJmbHVzaDsgLy8gc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkXFxuXFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcXG5cXHRcXHRcXHRcXHQvLyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xcblxcdFxcdFxcdFxcdC8vIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxcblxcdFxcdFxcdFxcdC8vIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXFxuXFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcXG5cXHRcXHRcXHRcXHRcXHRmaWxsX3dpbmRvdygpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09IFpfTk9fRkxVU0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7IC8vIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcXG5cXHRcXHRcXHRcXHQvLyBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcXG5cXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xcblxcdFxcdFxcdFxcdFxcdGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1soc3Ryc3RhcnQpICsgKE1JTl9NQVRDSCAtIDEpXSAmIDB4ZmYpKSAmIGhhc2hfbWFzaztcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwcmV2W3N0cnN0YXJ0JndfbWFza109aGFzaF9oZWFkPWhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdFxcdGhhc2hfaGVhZCA9IChoZWFkW2luc19oXSAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0cHJldltzdHJzdGFydCAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRoZWFkW2luc19oXSA9IHN0cnN0YXJ0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxcblxcdFxcdFxcdFxcdC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXFxuXFxuXFx0XFx0XFx0XFx0aWYgKGhhc2hfaGVhZCAhPT0gMCAmJiAoKHN0cnN0YXJ0IC0gaGFzaF9oZWFkKSAmIDB4ZmZmZikgPD0gd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJhdGVneSAhPSBaX0hVRkZNQU5fT05MWSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2goaGFzaF9oZWFkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnRcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBjaGVja19tYXRjaChzdHJzdGFydCwgbWF0Y2hfc3RhcnQsIG1hdGNoX2xlbmd0aCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmZsdXNoID0gX3RyX3RhbGx5KHN0cnN0YXJ0IC0gbWF0Y2hfc3RhcnQsIG1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkIC09IG1hdGNoX2xlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hfbGVuZ3RoIDw9IG1heF9sYXp5X21hdGNoICYmIGxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGgtLTsgLy8gc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gaGFzaCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzdHJzdGFydCsrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc19oID0gKChpbnNfaCA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYXNoX2hlYWQgPSAoaGVhZFtpbnNfaF0gJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLW1hdGNoX2xlbmd0aCAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQrKztcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0ICs9IG1hdGNoX2xlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGggPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdGluc19oID0gd2luZG93W3N0cnN0YXJ0XSAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93W3N0cnN0YXJ0ICsgMV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lc1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG5vdFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZVxcblxcblxcdFxcdFxcdFxcdFxcdGJmbHVzaCA9IF90cl90YWxseSgwLCB3aW5kb3dbc3Ryc3RhcnRdICYgMHhmZik7XFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkLS07XFxuXFx0XFx0XFx0XFx0XFx0c3Ryc3RhcnQrKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGJmbHVzaCkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmbHVzaF9ibG9ja19vbmx5KGZsdXNoID09IFpfRklOSVNIKTtcXG5cXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRpZiAoZmx1c2ggPT0gWl9GSU5JU0gpXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEZpbmlzaFN0YXJ0ZWQ7XFxuXFx0XFx0XFx0XFx0ZWxzZVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZsdXNoID09IFpfRklOSVNIID8gRmluaXNoRG9uZSA6IEJsb2NrRG9uZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxcblxcdFxcdC8vIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcXG5cXHRcXHQvLyBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxcblxcdFxcdGZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhmbHVzaCkge1xcblxcdFxcdFxcdC8vIHNob3J0IGhhc2hfaGVhZCA9IDA7IC8vIGhlYWQgb2YgaGFzaCBjaGFpblxcblxcdFxcdFxcdHZhciBoYXNoX2hlYWQgPSAwOyAvLyBoZWFkIG9mIGhhc2ggY2hhaW5cXG5cXHRcXHRcXHR2YXIgYmZsdXNoOyAvLyBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWRcXG5cXHRcXHRcXHR2YXIgbWF4X2luc2VydDtcXG5cXG5cXHRcXHRcXHQvLyBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay5cXG5cXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxcblxcdFxcdFxcdFxcdC8vIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXFxuXFx0XFx0XFx0XFx0Ly8gZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cXG5cXG5cXHRcXHRcXHRcXHRpZiAobG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdFxcdGZpbGxfd2luZG93KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT0gWl9OT19GTFVTSCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxvb2thaGVhZCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2tcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxcblxcdFxcdFxcdFxcdC8vIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxcblxcblxcdFxcdFxcdFxcdGlmIChsb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zX2ggPSAoKChpbnNfaCkgPDwgaGFzaF9zaGlmdCkgXiAod2luZG93WyhzdHJzdGFydCkgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikpICYgaGFzaF9tYXNrO1xcblxcdFxcdFxcdFxcdFxcdC8vIHByZXZbc3Ryc3RhcnQmd19tYXNrXT1oYXNoX2hlYWQ9aGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0aGFzaF9oZWFkID0gKGhlYWRbaW5zX2hdICYgMHhmZmZmKTtcXG5cXHRcXHRcXHRcXHRcXHRwcmV2W3N0cnN0YXJ0ICYgd19tYXNrXSA9IGhlYWRbaW5zX2hdO1xcblxcdFxcdFxcdFxcdFxcdGhlYWRbaW5zX2hdID0gc3Ryc3RhcnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXFxuXFx0XFx0XFx0XFx0cHJldl9sZW5ndGggPSBtYXRjaF9sZW5ndGg7XFxuXFx0XFx0XFx0XFx0cHJldl9tYXRjaCA9IG1hdGNoX3N0YXJ0O1xcblxcdFxcdFxcdFxcdG1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGhhc2hfaGVhZCAhPT0gMCAmJiBwcmV2X2xlbmd0aCA8IG1heF9sYXp5X21hdGNoICYmICgoc3Ryc3RhcnQgLSBoYXNoX2hlYWQpICYgMHhmZmZmKSA8PSB3X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRcXHQvLyBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcXG5cXHRcXHRcXHRcXHRcXHQvLyBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cmF0ZWd5ICE9IFpfSFVGRk1BTl9PTkxZKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChoYXNoX2hlYWQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQvLyBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydFxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaF9sZW5ndGggPD0gNSAmJiAoc3RyYXRlZ3kgPT0gWl9GSUxURVJFRCB8fCAobWF0Y2hfbGVuZ3RoID09IE1JTl9NQVRDSCAmJiBzdHJzdGFydCAtIG1hdGNoX3N0YXJ0ID4gNDA5NikpKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxcblxcdFxcdFxcdFxcdC8vIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XFxuXFx0XFx0XFx0XFx0aWYgKHByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBtYXRjaF9sZW5ndGggPD0gcHJldl9sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhfaW5zZXJ0ID0gc3Ryc3RhcnQgKyBsb29rYWhlYWQgLSBNSU5fTUFUQ0g7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY2hlY2tfbWF0Y2goc3Ryc3RhcnQtMSwgcHJldl9tYXRjaCwgcHJldl9sZW5ndGgpO1xcblxcblxcdFxcdFxcdFxcdFxcdGJmbHVzaCA9IF90cl90YWxseShzdHJzdGFydCAtIDEgLSBwcmV2X21hdGNoLCBwcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxcblxcdFxcdFxcdFxcdFxcdC8vIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgaGFzaCB0YWJsZS5cXG5cXHRcXHRcXHRcXHRcXHRsb29rYWhlYWQgLT0gcHJldl9sZW5ndGggLSAxO1xcblxcdFxcdFxcdFxcdFxcdHByZXZfbGVuZ3RoIC09IDI7XFxuXFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgrK3N0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbKHN0cnN0YXJ0KSArIChNSU5fTUFUQ0ggLSAxKV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJldltzdHJzdGFydCZ3X21hc2tdPWhhc2hfaGVhZD1oZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYXNoX2hlYWQgPSAoaGVhZFtpbnNfaF0gJiAweGZmZmYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHByZXZbc3Ryc3RhcnQgJiB3X21hc2tdID0gaGVhZFtpbnNfaF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtpbnNfaF0gPSBzdHJzdGFydDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSB3aGlsZSAoLS1wcmV2X2xlbmd0aCAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hfYXZhaWxhYmxlID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xcblxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0Kys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJmbHVzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZsdXNoX2Jsb2NrX29ubHkoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcXG5cXHRcXHRcXHRcXHRcXHQvLyBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cXG5cXG5cXHRcXHRcXHRcXHRcXHRiZmx1c2ggPSBfdHJfdGFsbHkoMCwgd2luZG93W3N0cnN0YXJ0IC0gMV0gJiAweGZmKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoYmZsdXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0Kys7XFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkLS07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBOZWVkTW9yZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRjaF9hdmFpbGFibGUgPSAxO1xcblxcdFxcdFxcdFxcdFxcdHN0cnN0YXJ0Kys7XFxuXFx0XFx0XFx0XFx0XFx0bG9va2FoZWFkLS07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAobWF0Y2hfYXZhaWxhYmxlICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0YmZsdXNoID0gX3RyX3RhbGx5KDAsIHdpbmRvd1tzdHJzdGFydCAtIDFdICYgMHhmZik7XFxuXFx0XFx0XFx0XFx0bWF0Y2hfYXZhaWxhYmxlID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zmx1c2hfYmxvY2tfb25seShmbHVzaCA9PSBaX0ZJTklTSCk7XFxuXFxuXFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGZsdXNoID09IFpfRklOSVNIKVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBGaW5pc2hTdGFydGVkO1xcblxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gTmVlZE1vcmU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmbHVzaCA9PSBaX0ZJTklTSCA/IEZpbmlzaERvbmUgOiBCbG9ja0RvbmU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XFxuXFx0XFx0XFx0c3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcXG5cXHRcXHRcXHRzdHJtLm1zZyA9IG51bGw7IC8vXFxuXFx0XFx0XFx0XFxuXFx0XFx0XFx0dGhhdC5wZW5kaW5nID0gMDtcXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfb3V0ID0gMDtcXG5cXG5cXHRcXHRcXHRzdGF0dXMgPSBCVVNZX1NUQVRFO1xcblxcblxcdFxcdFxcdGxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xcblxcblxcdFxcdFxcdHRyX2luaXQoKTtcXG5cXHRcXHRcXHRsbV9pbml0KCk7XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoYXQuZGVmbGF0ZUluaXQgPSBmdW5jdGlvbihzdHJtLCBfbGV2ZWwsIGJpdHMsIF9tZXRob2QsIG1lbUxldmVsLCBfc3RyYXRlZ3kpIHtcXG5cXHRcXHRcXHRpZiAoIV9tZXRob2QpXFxuXFx0XFx0XFx0XFx0X21ldGhvZCA9IFpfREVGTEFURUQ7XFxuXFx0XFx0XFx0aWYgKCFtZW1MZXZlbClcXG5cXHRcXHRcXHRcXHRtZW1MZXZlbCA9IERFRl9NRU1fTEVWRUw7XFxuXFx0XFx0XFx0aWYgKCFfc3RyYXRlZ3kpXFxuXFx0XFx0XFx0XFx0X3N0cmF0ZWd5ID0gWl9ERUZBVUxUX1NUUkFURUdZO1xcblxcblxcdFxcdFxcdC8vIGJ5dGVbXSBteV92ZXJzaW9uPVpMSUJfVkVSU0lPTjtcXG5cXG5cXHRcXHRcXHQvL1xcblxcdFxcdFxcdC8vIGlmICghdmVyc2lvbiB8fCB2ZXJzaW9uWzBdICE9IG15X3ZlcnNpb25bMF1cXG5cXHRcXHRcXHQvLyB8fCBzdHJlYW1fc2l6ZSAhPSBzaXplb2Yoel9zdHJlYW0pKSB7XFxuXFx0XFx0XFx0Ly8gcmV0dXJuIFpfVkVSU0lPTl9FUlJPUjtcXG5cXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0c3RybS5tc2cgPSBudWxsO1xcblxcblxcdFxcdFxcdGlmIChfbGV2ZWwgPT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKVxcblxcdFxcdFxcdFxcdF9sZXZlbCA9IDY7XFxuXFxuXFx0XFx0XFx0aWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgX21ldGhvZCAhPSBaX0RFRkxBVEVEIHx8IGJpdHMgPCA5IHx8IGJpdHMgPiAxNSB8fCBfbGV2ZWwgPCAwIHx8IF9sZXZlbCA+IDkgfHwgX3N0cmF0ZWd5IDwgMFxcblxcdFxcdFxcdFxcdFxcdHx8IF9zdHJhdGVneSA+IFpfSFVGRk1BTl9PTkxZKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzdHJtLmRzdGF0ZSA9IHRoYXQ7XFxuXFxuXFx0XFx0XFx0d19iaXRzID0gYml0cztcXG5cXHRcXHRcXHR3X3NpemUgPSAxIDw8IHdfYml0cztcXG5cXHRcXHRcXHR3X21hc2sgPSB3X3NpemUgLSAxO1xcblxcblxcdFxcdFxcdGhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcXG5cXHRcXHRcXHRoYXNoX3NpemUgPSAxIDw8IGhhc2hfYml0cztcXG5cXHRcXHRcXHRoYXNoX21hc2sgPSBoYXNoX3NpemUgLSAxO1xcblxcdFxcdFxcdGhhc2hfc2hpZnQgPSBNYXRoLmZsb29yKChoYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XFxuXFxuXFx0XFx0XFx0d2luZG93ID0gbmV3IFVpbnQ4QXJyYXkod19zaXplICogMik7XFxuXFx0XFx0XFx0cHJldiA9IFtdO1xcblxcdFxcdFxcdGhlYWQgPSBbXTtcXG5cXG5cXHRcXHRcXHRsaXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8vIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0XFxuXFxuXFx0XFx0XFx0Ly8gV2Ugb3ZlcmxheSBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYuIFRoaXMgd29ya3Mgc2luY2UgdGhlIGF2ZXJhZ2VcXG5cXHRcXHRcXHQvLyBvdXRwdXQgc2l6ZSBmb3IgKGxlbmd0aCxkaXN0YW5jZSkgY29kZXMgaXMgPD0gMjQgYml0cy5cXG5cXHRcXHRcXHR0aGF0LnBlbmRpbmdfYnVmID0gbmV3IFVpbnQ4QXJyYXkobGl0X2J1ZnNpemUgKiA0KTtcXG5cXHRcXHRcXHRwZW5kaW5nX2J1Zl9zaXplID0gbGl0X2J1ZnNpemUgKiA0O1xcblxcblxcdFxcdFxcdGRfYnVmID0gTWF0aC5mbG9vcihsaXRfYnVmc2l6ZSAvIDIpO1xcblxcdFxcdFxcdGxfYnVmID0gKDEgKyAyKSAqIGxpdF9idWZzaXplO1xcblxcblxcdFxcdFxcdGxldmVsID0gX2xldmVsO1xcblxcblxcdFxcdFxcdHN0cmF0ZWd5ID0gX3N0cmF0ZWd5O1xcblxcdFxcdFxcdG1ldGhvZCA9IF9tZXRob2QgJiAweGZmO1xcblxcblxcdFxcdFxcdHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmRlZmxhdGVFbmQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoc3RhdHVzICE9IElOSVRfU1RBVEUgJiYgc3RhdHVzICE9IEJVU1lfU1RBVEUgJiYgc3RhdHVzICE9IEZJTklTSF9TVEFURSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gRGVhbGxvY2F0ZSBpbiByZXZlcnNlIG9yZGVyIG9mIGFsbG9jYXRpb25zOlxcblxcdFxcdFxcdHRoYXQucGVuZGluZ19idWYgPSBudWxsO1xcblxcdFxcdFxcdGhlYWQgPSBudWxsO1xcblxcdFxcdFxcdHByZXYgPSBudWxsO1xcblxcdFxcdFxcdHdpbmRvdyA9IG51bGw7XFxuXFx0XFx0XFx0Ly8gZnJlZVxcblxcdFxcdFxcdHRoYXQuZHN0YXRlID0gbnVsbDtcXG5cXHRcXHRcXHRyZXR1cm4gc3RhdHVzID09IEJVU1lfU1RBVEUgPyBaX0RBVEFfRVJST1IgOiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5kZWZsYXRlUGFyYW1zID0gZnVuY3Rpb24oc3RybSwgX2xldmVsLCBfc3RyYXRlZ3kpIHtcXG5cXHRcXHRcXHR2YXIgZXJyID0gWl9PSztcXG5cXG5cXHRcXHRcXHRpZiAoX2xldmVsID09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xcblxcdFxcdFxcdFxcdF9sZXZlbCA9IDY7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChfbGV2ZWwgPCAwIHx8IF9sZXZlbCA+IDkgfHwgX3N0cmF0ZWd5IDwgMCB8fCBfc3RyYXRlZ3kgPiBaX0hVRkZNQU5fT05MWSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGNvbmZpZ190YWJsZVtsZXZlbF0uZnVuYyAhPSBjb25maWdfdGFibGVbX2xldmVsXS5mdW5jICYmIHN0cm0udG90YWxfaW4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBGbHVzaCB0aGUgbGFzdCBidWZmZXI6XFxuXFx0XFx0XFx0XFx0ZXJyID0gc3RybS5kZWZsYXRlKFpfUEFSVElBTF9GTFVTSCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChsZXZlbCAhPSBfbGV2ZWwpIHtcXG5cXHRcXHRcXHRcXHRsZXZlbCA9IF9sZXZlbDtcXG5cXHRcXHRcXHRcXHRtYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubWF4X2xhenk7XFxuXFx0XFx0XFx0XFx0Z29vZF9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0uZ29vZF9sZW5ndGg7XFxuXFx0XFx0XFx0XFx0bmljZV9tYXRjaCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubmljZV9sZW5ndGg7XFxuXFx0XFx0XFx0XFx0bWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ190YWJsZVtsZXZlbF0ubWF4X2NoYWluO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzdHJhdGVneSA9IF9zdHJhdGVneTtcXG5cXHRcXHRcXHRyZXR1cm4gZXJyO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gZGljdExlbmd0aDtcXG5cXHRcXHRcXHR2YXIgbiwgaW5kZXggPSAwO1xcblxcblxcdFxcdFxcdGlmICghZGljdGlvbmFyeSB8fCBzdGF0dXMgIT0gSU5JVF9TVEFURSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFxuXFx0XFx0XFx0aWYgKGxlbmd0aCA8IE1JTl9NQVRDSClcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHRcXHRpZiAobGVuZ3RoID4gd19zaXplIC0gTUlOX0xPT0tBSEVBRCkge1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9IHdfc2l6ZSAtIE1JTl9MT09LQUhFQUQ7XFxuXFx0XFx0XFx0XFx0aW5kZXggPSBkaWN0TGVuZ3RoIC0gbGVuZ3RoOyAvLyB1c2UgdGhlIHRhaWwgb2YgdGhlIGRpY3Rpb25hcnlcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0d2luZG93LnNldChkaWN0aW9uYXJ5LnN1YmFycmF5KGluZGV4LCBpbmRleCArIGxlbmd0aCksIDApO1xcblxcblxcdFxcdFxcdHN0cnN0YXJ0ID0gbGVuZ3RoO1xcblxcdFxcdFxcdGJsb2NrX3N0YXJ0ID0gbGVuZ3RoO1xcblxcblxcdFxcdFxcdC8vIEluc2VydCBhbGwgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSAoZXhjZXB0IGZvciB0aGUgbGFzdCB0d28gYnl0ZXMpLlxcblxcdFxcdFxcdC8vIHMtPmxvb2thaGVhZCBzdGF5cyBudWxsLCBzbyBzLT5pbnNfaCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgdGhlIG5leHRcXG5cXHRcXHRcXHQvLyBjYWxsIG9mIGZpbGxfd2luZG93LlxcblxcblxcdFxcdFxcdGluc19oID0gd2luZG93WzBdICYgMHhmZjtcXG5cXHRcXHRcXHRpbnNfaCA9ICgoKGluc19oKSA8PCBoYXNoX3NoaWZ0KSBeICh3aW5kb3dbMV0gJiAweGZmKSkgJiBoYXNoX21hc2s7XFxuXFxuXFx0XFx0XFx0Zm9yIChuID0gMDsgbiA8PSBsZW5ndGggLSBNSU5fTUFUQ0g7IG4rKykge1xcblxcdFxcdFxcdFxcdGluc19oID0gKCgoaW5zX2gpIDw8IGhhc2hfc2hpZnQpIF4gKHdpbmRvd1sobikgKyAoTUlOX01BVENIIC0gMSldICYgMHhmZikpICYgaGFzaF9tYXNrO1xcblxcdFxcdFxcdFxcdHByZXZbbiAmIHdfbWFza10gPSBoZWFkW2luc19oXTtcXG5cXHRcXHRcXHRcXHRoZWFkW2luc19oXSA9IG47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5kZWZsYXRlID0gZnVuY3Rpb24oX3N0cm0sIGZsdXNoKSB7XFxuXFx0XFx0XFx0dmFyIGksIGhlYWRlciwgbGV2ZWxfZmxhZ3MsIG9sZF9mbHVzaCwgYnN0YXRlO1xcblxcblxcdFxcdFxcdGlmIChmbHVzaCA+IFpfRklOSVNIIHx8IGZsdXNoIDwgMCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFfc3RybS5uZXh0X291dCB8fCAoIV9zdHJtLm5leHRfaW4gJiYgX3N0cm0uYXZhaWxfaW4gIT09IDApIHx8IChzdGF0dXMgPT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9IFpfRklOSVNIKSkge1xcblxcdFxcdFxcdFxcdF9zdHJtLm1zZyA9IHpfZXJybXNnW1pfTkVFRF9ESUNUIC0gKFpfU1RSRUFNX0VSUk9SKV07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoX3N0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0X3N0cm0ubXNnID0gel9lcnJtc2dbWl9ORUVEX0RJQ1QgLSAoWl9CVUZfRVJST1IpXTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9CVUZfRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0cm0gPSBfc3RybTsgLy8ganVzdCBpbiBjYXNlXFxuXFx0XFx0XFx0b2xkX2ZsdXNoID0gbGFzdF9mbHVzaDtcXG5cXHRcXHRcXHRsYXN0X2ZsdXNoID0gZmx1c2g7XFxuXFxuXFx0XFx0XFx0Ly8gV3JpdGUgdGhlIHpsaWIgaGVhZGVyXFxuXFx0XFx0XFx0aWYgKHN0YXR1cyA9PSBJTklUX1NUQVRFKSB7XFxuXFx0XFx0XFx0XFx0aGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHdfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xcblxcdFxcdFxcdFxcdGxldmVsX2ZsYWdzID0gKChsZXZlbCAtIDEpICYgMHhmZikgPj4gMTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAobGV2ZWxfZmxhZ3MgPiAzKVxcblxcdFxcdFxcdFxcdFxcdGxldmVsX2ZsYWdzID0gMztcXG5cXHRcXHRcXHRcXHRoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xcblxcdFxcdFxcdFxcdGlmIChzdHJzdGFydCAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7XFxuXFx0XFx0XFx0XFx0aGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcXG5cXG5cXHRcXHRcXHRcXHRzdGF0dXMgPSBCVVNZX1NUQVRFO1xcblxcdFxcdFxcdFxcdHB1dFNob3J0TVNCKGhlYWRlcik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGVcXG5cXHRcXHRcXHRpZiAodGhhdC5wZW5kaW5nICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0c3RybS5mbHVzaF9wZW5kaW5nKCk7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcIiBhdmFpbF9vdXQ9PTBcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcXG5cXHRcXHRcXHRcXHRcXHQvLyBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcXG5cXHRcXHRcXHRcXHRcXHQvLyBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxcblxcdFxcdFxcdFxcdFxcdC8vIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcXG5cXHRcXHRcXHRcXHRcXHRsYXN0X2ZsdXNoID0gLTE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZVxcblxcdFxcdFxcdFxcdC8vIGNvbnNlY3V0aXZlXFxuXFx0XFx0XFx0XFx0Ly8gZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcXG5cXHRcXHRcXHRcXHQvLyByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZGX0VSUk9SLlxcblxcdFxcdFxcdH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBmbHVzaCA8PSBvbGRfZmx1c2ggJiYgZmx1c2ggIT0gWl9GSU5JU0gpIHtcXG5cXHRcXHRcXHRcXHRzdHJtLm1zZyA9IHpfZXJybXNnW1pfTkVFRF9ESUNUIC0gKFpfQlVGX0VSUk9SKV07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfQlVGX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOlxcblxcdFxcdFxcdGlmIChzdGF0dXMgPT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRfc3RybS5tc2cgPSB6X2Vycm1zZ1taX05FRURfRElDVCAtIChaX0JVRl9FUlJPUildO1xcblxcdFxcdFxcdFxcdHJldHVybiBaX0JVRl9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxcblxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IGxvb2thaGVhZCAhPT0gMCB8fCAoZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBzdGF0dXMgIT0gRklOSVNIX1NUQVRFKSkge1xcblxcdFxcdFxcdFxcdGJzdGF0ZSA9IC0xO1xcblxcdFxcdFxcdFxcdHN3aXRjaCAoY29uZmlnX3RhYmxlW2xldmVsXS5mdW5jKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBTVE9SRUQ6XFxuXFx0XFx0XFx0XFx0XFx0YnN0YXRlID0gZGVmbGF0ZV9zdG9yZWQoZmx1c2gpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgRkFTVDpcXG5cXHRcXHRcXHRcXHRcXHRic3RhdGUgPSBkZWZsYXRlX2Zhc3QoZmx1c2gpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgU0xPVzpcXG5cXHRcXHRcXHRcXHRcXHRic3RhdGUgPSBkZWZsYXRlX3Nsb3coZmx1c2gpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChic3RhdGUgPT0gRmluaXNoU3RhcnRlZCB8fCBic3RhdGUgPT0gRmluaXNoRG9uZSkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1cyA9IEZJTklTSF9TVEFURTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGJzdGF0ZSA9PSBOZWVkTW9yZSB8fCBic3RhdGUgPT0gRmluaXNoU3RhcnRlZCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RfZmx1c2ggPSAtMTsgLy8gYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdFxcdFxcdFxcdC8vIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09PSAwLCB0aGUgbmV4dCBjYWxsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cXG5cXHRcXHRcXHRcXHRcXHQvLyBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xcblxcdFxcdFxcdFxcdFxcdC8vIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxcblxcdFxcdFxcdFxcdFxcdC8vIG9uZSBlbXB0eSBibG9jay5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGJzdGF0ZSA9PSBCbG9ja0RvbmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZmx1c2ggPT0gWl9QQVJUSUFMX0ZMVVNIKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RyX2FsaWduKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHsgLy8gRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIXFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RyX3N0b3JlZF9ibG9jaygwLCAwLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChmbHVzaCA9PSBaX0ZVTExfRkxVU0gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzdGF0ZS5oZWFkW3MuaGFzaF9zaXplLTFdPTA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IGhhc2hfc2l6ZS8qLTEqLzsgaSsrKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGZvcmdldCBoaXN0b3J5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aGVhZFtpXSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzdHJtLmZsdXNoX3BlbmRpbmcoKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0X2ZsdXNoID0gLTE7IC8vIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChmbHVzaCAhPSBaX0ZJTklTSClcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRU5EO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8vIFpTdHJlYW1cXG5cXG5cXHRmdW5jdGlvbiBaU3RyZWFtKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHR0aGF0Lm5leHRfaW5faW5kZXggPSAwO1xcblxcdFxcdHRoYXQubmV4dF9vdXRfaW5kZXggPSAwO1xcblxcdFxcdC8vIHRoYXQubmV4dF9pbjsgLy8gbmV4dCBpbnB1dCBieXRlXFxuXFx0XFx0dGhhdC5hdmFpbF9pbiA9IDA7IC8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgbmV4dF9pblxcblxcdFxcdHRoYXQudG90YWxfaW4gPSAwOyAvLyB0b3RhbCBuYiBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhclxcblxcdFxcdC8vIHRoYXQubmV4dF9vdXQ7IC8vIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZVxcblxcdFxcdHRoYXQuYXZhaWxfb3V0ID0gMDsgLy8gcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgbmV4dF9vdXRcXG5cXHRcXHR0aGF0LnRvdGFsX291dCA9IDA7IC8vIHRvdGFsIG5iIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXJcXG5cXHRcXHQvLyB0aGF0Lm1zZztcXG5cXHRcXHQvLyB0aGF0LmRzdGF0ZTtcXG5cXHR9XFxuXFxuXFx0WlN0cmVhbS5wcm90b3R5cGUgPSB7XFxuXFx0XFx0ZGVmbGF0ZUluaXQgOiBmdW5jdGlvbihsZXZlbCwgYml0cykge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHR0aGF0LmRzdGF0ZSA9IG5ldyBEZWZsYXRlKCk7XFxuXFx0XFx0XFx0aWYgKCFiaXRzKVxcblxcdFxcdFxcdFxcdGJpdHMgPSBNQVhfQklUUztcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZUluaXQodGhhdCwgbGV2ZWwsIGJpdHMpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVmbGF0ZSA6IGZ1bmN0aW9uKGZsdXNoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdGlmICghdGhhdC5kc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0aGF0LmRzdGF0ZS5kZWZsYXRlKHRoYXQsIGZsdXNoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlZmxhdGVFbmQgOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmRzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0dmFyIHJldCA9IHRoYXQuZHN0YXRlLmRlZmxhdGVFbmQoKTtcXG5cXHRcXHRcXHR0aGF0LmRzdGF0ZSA9IG51bGw7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlZmxhdGVQYXJhbXMgOiBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3kpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmRzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQuZHN0YXRlLmRlZmxhdGVQYXJhbXModGhhdCwgbGV2ZWwsIHN0cmF0ZWd5KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlZmxhdGVTZXREaWN0aW9uYXJ5IDogZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuZHN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5kc3RhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhhdCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZVxcblxcdFxcdC8vIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxcblxcdFxcdC8vIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXFxuXFx0XFx0Ly8gYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfaW4gYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXFxuXFx0XFx0Ly8gKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXFxuXFx0XFx0cmVhZF9idWYgOiBmdW5jdGlvbihidWYsIHN0YXJ0LCBzaXplKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdHZhciBsZW4gPSB0aGF0LmF2YWlsX2luO1xcblxcdFxcdFxcdGlmIChsZW4gPiBzaXplKVxcblxcdFxcdFxcdFxcdGxlbiA9IHNpemU7XFxuXFx0XFx0XFx0aWYgKGxlbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHRcXHR0aGF0LmF2YWlsX2luIC09IGxlbjtcXG5cXHRcXHRcXHRidWYuc2V0KHRoYXQubmV4dF9pbi5zdWJhcnJheSh0aGF0Lm5leHRfaW5faW5kZXgsIHRoYXQubmV4dF9pbl9pbmRleCArIGxlbiksIHN0YXJ0KTtcXG5cXHRcXHRcXHR0aGF0Lm5leHRfaW5faW5kZXggKz0gbGVuO1xcblxcdFxcdFxcdHRoYXQudG90YWxfaW4gKz0gbGVuO1xcblxcdFxcdFxcdHJldHVybiBsZW47XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXFxuXFx0XFx0Ly8gdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxcblxcdFxcdC8vIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5uZXh0X291dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cXG5cXHRcXHQvLyAoU2VlIGFsc28gcmVhZF9idWYoKSkuXFxuXFx0XFx0Zmx1c2hfcGVuZGluZyA6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHR2YXIgbGVuID0gdGhhdC5kc3RhdGUucGVuZGluZztcXG5cXG5cXHRcXHRcXHRpZiAobGVuID4gdGhhdC5hdmFpbF9vdXQpXFxuXFx0XFx0XFx0XFx0bGVuID0gdGhhdC5hdmFpbF9vdXQ7XFxuXFx0XFx0XFx0aWYgKGxlbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0Ly8gaWYgKHRoYXQuZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aCA8PSB0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8PSB0aGF0Lm5leHRfb3V0X2luZGV4XFxuXFx0XFx0XFx0Ly8gfHwgdGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoIDwgKHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSB8fCB0aGF0Lm5leHRfb3V0Lmxlbmd0aCA8ICh0aGF0Lm5leHRfb3V0X2luZGV4ICtcXG5cXHRcXHRcXHQvLyBsZW4pKSB7XFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2codGhhdC5kc3RhdGUucGVuZGluZ19idWYubGVuZ3RoICsgXFxcIiwgXFxcIiArIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgXFxcIiwgXFxcIiArIHRoYXQubmV4dF9vdXQubGVuZ3RoICsgXFxcIiwgXFxcIiArXFxuXFx0XFx0XFx0Ly8gdGhhdC5uZXh0X291dF9pbmRleCArIFxcXCIsIFxcXCIgKyBsZW4pO1xcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJhdmFpbF9vdXQ9XFxcIiArIHRoYXQuYXZhaWxfb3V0KTtcXG5cXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0dGhhdC5uZXh0X291dC5zZXQodGhhdC5kc3RhdGUucGVuZGluZ19idWYuc3ViYXJyYXkodGhhdC5kc3RhdGUucGVuZGluZ19vdXQsIHRoYXQuZHN0YXRlLnBlbmRpbmdfb3V0ICsgbGVuKSwgdGhhdC5uZXh0X291dF9pbmRleCk7XFxuXFxuXFx0XFx0XFx0dGhhdC5uZXh0X291dF9pbmRleCArPSBsZW47XFxuXFx0XFx0XFx0dGhhdC5kc3RhdGUucGVuZGluZ19vdXQgKz0gbGVuO1xcblxcdFxcdFxcdHRoYXQudG90YWxfb3V0ICs9IGxlbjtcXG5cXHRcXHRcXHR0aGF0LmF2YWlsX291dCAtPSBsZW47XFxuXFx0XFx0XFx0dGhhdC5kc3RhdGUucGVuZGluZyAtPSBsZW47XFxuXFx0XFx0XFx0aWYgKHRoYXQuZHN0YXRlLnBlbmRpbmcgPT09IDApIHtcXG5cXHRcXHRcXHRcXHR0aGF0LmRzdGF0ZS5wZW5kaW5nX291dCA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8vIERlZmxhdGVyXFxuXFxuXFx0ZnVuY3Rpb24gRGVmbGF0ZXIob3B0aW9ucykge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHR2YXIgeiA9IG5ldyBaU3RyZWFtKCk7XFxuXFx0XFx0dmFyIGJ1ZnNpemUgPSA1MTI7XFxuXFx0XFx0dmFyIGZsdXNoID0gWl9OT19GTFVTSDtcXG5cXHRcXHR2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmc2l6ZSk7XFxuXFx0XFx0dmFyIGxldmVsID0gb3B0aW9ucyA/IG9wdGlvbnMubGV2ZWwgOiBaX0RFRkFVTFRfQ09NUFJFU1NJT047XFxuXFx0XFx0aWYgKHR5cGVvZiBsZXZlbCA9PSBcXFwidW5kZWZpbmVkXFxcIilcXG5cXHRcXHRcXHRsZXZlbCA9IFpfREVGQVVMVF9DT01QUkVTU0lPTjtcXG5cXHRcXHR6LmRlZmxhdGVJbml0KGxldmVsKTtcXG5cXHRcXHR6Lm5leHRfb3V0ID0gYnVmO1xcblxcblxcdFxcdHRoYXQuYXBwZW5kID0gZnVuY3Rpb24oZGF0YSwgb25wcm9ncmVzcykge1xcblxcdFxcdFxcdHZhciBlcnIsIGJ1ZmZlcnMgPSBbXSwgbGFzdEluZGV4ID0gMCwgYnVmZmVySW5kZXggPSAwLCBidWZmZXJTaXplID0gMCwgYXJyYXk7XFxuXFx0XFx0XFx0aWYgKCFkYXRhLmxlbmd0aClcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gMDtcXG5cXHRcXHRcXHR6Lm5leHRfaW4gPSBkYXRhO1xcblxcdFxcdFxcdHouYXZhaWxfaW4gPSBkYXRhLmxlbmd0aDtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0ei5uZXh0X291dF9pbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0ei5hdmFpbF9vdXQgPSBidWZzaXplO1xcblxcdFxcdFxcdFxcdGVyciA9IHouZGVmbGF0ZShmbHVzaCk7XFxuXFx0XFx0XFx0XFx0aWYgKGVyciAhPSBaX09LKVxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiZGVmbGF0aW5nOiBcXFwiICsgei5tc2cpO1xcblxcdFxcdFxcdFxcdGlmICh6Lm5leHRfb3V0X2luZGV4KVxcblxcdFxcdFxcdFxcdFxcdGlmICh6Lm5leHRfb3V0X2luZGV4ID09IGJ1ZnNpemUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpO1xcblxcdFxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmLnN1YmFycmF5KDAsIHoubmV4dF9vdXRfaW5kZXgpKSk7XFxuXFx0XFx0XFx0XFx0YnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xcblxcdFxcdFxcdFxcdGlmIChvbnByb2dyZXNzICYmIHoubmV4dF9pbl9pbmRleCA+IDAgJiYgei5uZXh0X2luX2luZGV4ICE9IGxhc3RJbmRleCkge1xcblxcdFxcdFxcdFxcdFxcdG9ucHJvZ3Jlc3Moei5uZXh0X2luX2luZGV4KTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0SW5kZXggPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcXG5cXHRcXHRcXHRhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xcblxcdFxcdFxcdGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xcblxcdFxcdFxcdFxcdGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcblxcdFxcdFxcdFxcdGJ1ZmZlckluZGV4ICs9IGNodW5rLmxlbmd0aDtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGF0LmZsdXNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGVyciwgYnVmZmVycyA9IFtdLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0ei5uZXh0X291dF9pbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0ei5hdmFpbF9vdXQgPSBidWZzaXplO1xcblxcdFxcdFxcdFxcdGVyciA9IHouZGVmbGF0ZShaX0ZJTklTSCk7XFxuXFx0XFx0XFx0XFx0aWYgKGVyciAhPSBaX1NUUkVBTV9FTkQgJiYgZXJyICE9IFpfT0spXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJkZWZsYXRpbmc6IFxcXCIgKyB6Lm1zZyk7XFxuXFx0XFx0XFx0XFx0aWYgKGJ1ZnNpemUgLSB6LmF2YWlsX291dCA+IDApXFxuXFx0XFx0XFx0XFx0XFx0YnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1Zi5zdWJhcnJheSgwLCB6Lm5leHRfb3V0X2luZGV4KSkpO1xcblxcdFxcdFxcdFxcdGJ1ZmZlclNpemUgKz0gei5uZXh0X291dF9pbmRleDtcXG5cXHRcXHRcXHR9IHdoaWxlICh6LmF2YWlsX2luID4gMCB8fCB6LmF2YWlsX291dCA9PT0gMCk7XFxuXFx0XFx0XFx0ei5kZWZsYXRlRW5kKCk7XFxuXFx0XFx0XFx0YXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJTaXplKTtcXG5cXHRcXHRcXHRidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcXG5cXHRcXHRcXHRcXHRhcnJheS5zZXQoY2h1bmssIGJ1ZmZlckluZGV4KTtcXG5cXHRcXHRcXHRcXHRidWZmZXJJbmRleCArPSBjaHVuay5sZW5ndGg7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8vICd6aXAnIG1heSBub3QgYmUgZGVmaW5lZCBpbiB6LXdvcmtlciBhbmQgc29tZSB0ZXN0c1xcblxcdHZhciBlbnYgPSBnbG9iYWwuemlwIHx8IGdsb2JhbDtcXG5cXHRlbnYuRGVmbGF0ZXIgPSBlbnYuX2p6bGliX0RlZmxhdGVyID0gRGVmbGF0ZXI7XFxufSkodGhpcyk7XFxuXCIpXSxcbiAgaW5mbGF0ZXI6IFt6V29ya2VyLCBjcmVhdGVVcmwoXCIvKlxcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXFxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXFxuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG4gKi9cXG5cXG4vKlxcbiAqIFRoaXMgcHJvZ3JhbSBpcyBiYXNlZCBvbiBKWmxpYiAxLjAuMiB5bW5rLCBKQ3JhZnQsSW5jLlxcbiAqIEpabGliIGlzIGJhc2VkIG9uIHpsaWItMS4xLjMsIHNvIGFsbCBjcmVkaXQgc2hvdWxkIGdvIGF1dGhvcnNcXG4gKiBKZWFuLWxvdXAgR2FpbGx5KGpsb3VwQGd6aXAub3JnKSBhbmQgTWFyayBBZGxlcihtYWRsZXJAYWx1bW5pLmNhbHRlY2guZWR1KVxcbiAqIGFuZCBjb250cmlidXRvcnMgb2YgemxpYi5cXG4gKi9cXG5cXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdC8vIEdsb2JhbFxcblxcdHZhciBNQVhfQklUUyA9IDE1O1xcblxcblxcdHZhciBaX09LID0gMDtcXG5cXHR2YXIgWl9TVFJFQU1fRU5EID0gMTtcXG5cXHR2YXIgWl9ORUVEX0RJQ1QgPSAyO1xcblxcdHZhciBaX1NUUkVBTV9FUlJPUiA9IC0yO1xcblxcdHZhciBaX0RBVEFfRVJST1IgPSAtMztcXG5cXHR2YXIgWl9NRU1fRVJST1IgPSAtNDtcXG5cXHR2YXIgWl9CVUZfRVJST1IgPSAtNTtcXG5cXG5cXHR2YXIgaW5mbGF0ZV9tYXNrID0gWyAweDAwMDAwMDAwLCAweDAwMDAwMDAxLCAweDAwMDAwMDAzLCAweDAwMDAwMDA3LCAweDAwMDAwMDBmLCAweDAwMDAwMDFmLCAweDAwMDAwMDNmLCAweDAwMDAwMDdmLCAweDAwMDAwMGZmLCAweDAwMDAwMWZmLCAweDAwMDAwM2ZmLFxcblxcdFxcdFxcdDB4MDAwMDA3ZmYsIDB4MDAwMDBmZmYsIDB4MDAwMDFmZmYsIDB4MDAwMDNmZmYsIDB4MDAwMDdmZmYsIDB4MDAwMGZmZmYgXTtcXG5cXG5cXHR2YXIgTUFOWSA9IDE0NDA7XFxuXFxuXFx0Ly8gSlpsaWIgdmVyc2lvbiA6IFxcXCIxLjAuMlxcXCJcXG5cXHR2YXIgWl9OT19GTFVTSCA9IDA7XFxuXFx0dmFyIFpfRklOSVNIID0gNDtcXG5cXG5cXHQvLyBJbmZUcmVlXFxuXFx0dmFyIGZpeGVkX2JsID0gOTtcXG5cXHR2YXIgZml4ZWRfYmQgPSA1O1xcblxcblxcdHZhciBmaXhlZF90bCA9IFsgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksIDE5MiwgODAsIDcsIDEwLCAwLCA4LCA5NiwgMCwgOCwgMzIsIDAsIDksIDE2MCwgMCwgOCwgMCxcXG5cXHRcXHRcXHQwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjQsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NCwgODMsIDcsIDU5LCAwLCA4LCAxMjAsIDAsIDgsIDU2LCAwLCA5LCAyMDgsIDgxLCA3LCAxNywgMCwgOCwgMTA0LCAwLCA4LCA0MCxcXG5cXHRcXHRcXHQwLCA5LCAxNzYsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MCwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsIDIyNywgODMsIDcsIDQzLCAwLCA4LCAxMTYsIDAsIDgsIDUyLCAwLCA5LCAyMDAsIDgxLCA3LCAxMyxcXG5cXHRcXHRcXHQwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjgsIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMiwgODAsIDcsIDgsIDAsIDgsIDkyLCAwLCA4LCAyOCwgMCwgOSwgMTUyLCA4NCwgNywgODMsIDAsIDgsIDEyNCwgMCwgOCwgNjAsXFxuXFx0XFx0XFx0MCwgOSwgMjE2LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NCwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksIDI0OCwgODAsIDcsIDMsIDAsIDgsIDgyLCAwLCA4LCAxOCwgODUsIDgsIDE2MywgODMsIDcsXFxuXFx0XFx0XFx0MzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NiwgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NCwgMCwgOCwgMiwgMCwgOCwgMTMwLCAwLCA4LCA2NiwgMCwgOSwgMjI4LCA4MCwgNywgNywgMCwgOCwgOTAsIDAsIDgsXFxuXFx0XFx0XFx0MjYsIDAsIDksIDE0OCwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTIsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSwgMTgwLCAwLCA4LCAxMCwgMCwgOCwgMTM4LCAwLCA4LCA3NCwgMCwgOSwgMjQ0LCA4MCxcXG5cXHRcXHRcXHQ3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDQsIDgxLCA3LCAxNSwgMCwgOCwgMTAyLCAwLCA4LCAzOCwgMCwgOSwgMTcyLCAwLCA4LCA2LCAwLCA4LCAxMzQsIDAsXFxuXFx0XFx0XFx0OCwgNzAsIDAsIDksIDIzNiwgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU2LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksIDIyMCwgODIsIDcsIDI3LCAwLCA4LCAxMTAsIDAsIDgsIDQ2LCAwLCA5LCAxODgsIDAsXFxuXFx0XFx0XFx0OCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MiwgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsIDgsIDExMywgMCwgOCwgNDksIDAsIDksIDE5NCwgODAsIDcsIDEwLCAwLCA4LCA5NyxcXG5cXHRcXHRcXHQwLCA4LCAzMywgMCwgOSwgMTYyLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjYsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksIDE0NiwgODMsIDcsIDU5LCAwLCA4LCAxMjEsIDAsIDgsIDU3LCAwLCA5LCAyMTAsXFxuXFx0XFx0XFx0ODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzgsIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MiwgODAsIDcsIDQsIDAsIDgsIDg1LCAwLCA4LCAyMSwgODAsIDgsIDI1OCwgODMsIDcsIDQzLCAwLCA4LCAxMTcsXFxuXFx0XFx0XFx0MCwgOCwgNTMsIDAsIDksIDIwMiwgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzAsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksIDIzNCwgODAsIDcsIDgsIDAsIDgsIDkzLCAwLCA4LCAyOSwgMCwgOSwgMTU0LFxcblxcdFxcdFxcdDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE4LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NiwgMCwgOCwgMTMsIDAsIDgsIDE0MSwgMCwgOCwgNzcsIDAsIDksIDI1MCwgODAsIDcsIDMsIDAsIDgsIDgzLFxcblxcdFxcdFxcdDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OCwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksIDE2NiwgMCwgOCwgMywgMCwgOCwgMTMxLCAwLCA4LCA2NywgMCwgOSwgMjMwLFxcblxcdFxcdFxcdDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MCwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTQsIDgyLCA3LCAxOSwgMCwgOCwgMTA3LCAwLCA4LCA0MywgMCwgOSwgMTgyLCAwLCA4LCAxMSwgMCwgOCwgMTM5LFxcblxcdFxcdFxcdDAsIDgsIDc1LCAwLCA5LCAyNDYsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LCAyMDYsIDgxLCA3LCAxNSwgMCwgOCwgMTAzLCAwLCA4LCAzOSwgMCwgOSwgMTc0LFxcblxcdFxcdFxcdDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOCwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU4LCA4NCwgNywgOTksIDAsIDgsIDEyNywgMCwgOCwgNjMsIDAsIDksIDIyMiwgODIsIDcsIDI3LCAwLCA4LCAxMTEsXFxuXFx0XFx0XFx0MCwgOCwgNDcsIDAsIDksIDE5MCwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NCwgOTYsIDcsIDI1NiwgMCwgOCwgODAsIDAsIDgsIDE2LCA4NCwgOCwgMTE1LCA4MiwgNywgMzEsIDAsIDgsIDExMiwgMCwgOCwgNDgsIDAsIDksXFxuXFx0XFx0XFx0MTkzLCA4MCwgNywgMTAsIDAsIDgsIDk2LCAwLCA4LCAzMiwgMCwgOSwgMTYxLCAwLCA4LCAwLCAwLCA4LCAxMjgsIDAsIDgsIDY0LCAwLCA5LCAyMjUsIDgwLCA3LCA2LCAwLCA4LCA4OCwgMCwgOCwgMjQsIDAsIDksIDE0NSwgODMsIDcsIDU5LCAwLCA4LFxcblxcdFxcdFxcdDEyMCwgMCwgOCwgNTYsIDAsIDksIDIwOSwgODEsIDcsIDE3LCAwLCA4LCAxMDQsIDAsIDgsIDQwLCAwLCA5LCAxNzcsIDAsIDgsIDgsIDAsIDgsIDEzNiwgMCwgOCwgNzIsIDAsIDksIDI0MSwgODAsIDcsIDQsIDAsIDgsIDg0LCAwLCA4LCAyMCwgODUsIDgsXFxuXFx0XFx0XFx0MjI3LCA4MywgNywgNDMsIDAsIDgsIDExNiwgMCwgOCwgNTIsIDAsIDksIDIwMSwgODEsIDcsIDEzLCAwLCA4LCAxMDAsIDAsIDgsIDM2LCAwLCA5LCAxNjksIDAsIDgsIDQsIDAsIDgsIDEzMiwgMCwgOCwgNjgsIDAsIDksIDIzMywgODAsIDcsIDgsIDAsIDgsXFxuXFx0XFx0XFx0OTIsIDAsIDgsIDI4LCAwLCA5LCAxNTMsIDg0LCA3LCA4MywgMCwgOCwgMTI0LCAwLCA4LCA2MCwgMCwgOSwgMjE3LCA4MiwgNywgMjMsIDAsIDgsIDEwOCwgMCwgOCwgNDQsIDAsIDksIDE4NSwgMCwgOCwgMTIsIDAsIDgsIDE0MCwgMCwgOCwgNzYsIDAsIDksXFxuXFx0XFx0XFx0MjQ5LCA4MCwgNywgMywgMCwgOCwgODIsIDAsIDgsIDE4LCA4NSwgOCwgMTYzLCA4MywgNywgMzUsIDAsIDgsIDExNCwgMCwgOCwgNTAsIDAsIDksIDE5NywgODEsIDcsIDExLCAwLCA4LCA5OCwgMCwgOCwgMzQsIDAsIDksIDE2NSwgMCwgOCwgMiwgMCwgOCxcXG5cXHRcXHRcXHQxMzAsIDAsIDgsIDY2LCAwLCA5LCAyMjksIDgwLCA3LCA3LCAwLCA4LCA5MCwgMCwgOCwgMjYsIDAsIDksIDE0OSwgODQsIDcsIDY3LCAwLCA4LCAxMjIsIDAsIDgsIDU4LCAwLCA5LCAyMTMsIDgyLCA3LCAxOSwgMCwgOCwgMTA2LCAwLCA4LCA0MiwgMCwgOSxcXG5cXHRcXHRcXHQxODEsIDAsIDgsIDEwLCAwLCA4LCAxMzgsIDAsIDgsIDc0LCAwLCA5LCAyNDUsIDgwLCA3LCA1LCAwLCA4LCA4NiwgMCwgOCwgMjIsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTgsIDAsIDgsIDU0LCAwLCA5LCAyMDUsIDgxLCA3LCAxNSwgMCwgOCxcXG5cXHRcXHRcXHQxMDIsIDAsIDgsIDM4LCAwLCA5LCAxNzMsIDAsIDgsIDYsIDAsIDgsIDEzNCwgMCwgOCwgNzAsIDAsIDksIDIzNywgODAsIDcsIDksIDAsIDgsIDk0LCAwLCA4LCAzMCwgMCwgOSwgMTU3LCA4NCwgNywgOTksIDAsIDgsIDEyNiwgMCwgOCwgNjIsIDAsIDksXFxuXFx0XFx0XFx0MjIxLCA4MiwgNywgMjcsIDAsIDgsIDExMCwgMCwgOCwgNDYsIDAsIDksIDE4OSwgMCwgOCwgMTQsIDAsIDgsIDE0MiwgMCwgOCwgNzgsIDAsIDksIDI1MywgOTYsIDcsIDI1NiwgMCwgOCwgODEsIDAsIDgsIDE3LCA4NSwgOCwgMTMxLCA4MiwgNywgMzEsIDAsXFxuXFx0XFx0XFx0OCwgMTEzLCAwLCA4LCA0OSwgMCwgOSwgMTk1LCA4MCwgNywgMTAsIDAsIDgsIDk3LCAwLCA4LCAzMywgMCwgOSwgMTYzLCAwLCA4LCAxLCAwLCA4LCAxMjksIDAsIDgsIDY1LCAwLCA5LCAyMjcsIDgwLCA3LCA2LCAwLCA4LCA4OSwgMCwgOCwgMjUsIDAsIDksXFxuXFx0XFx0XFx0MTQ3LCA4MywgNywgNTksIDAsIDgsIDEyMSwgMCwgOCwgNTcsIDAsIDksIDIxMSwgODEsIDcsIDE3LCAwLCA4LCAxMDUsIDAsIDgsIDQxLCAwLCA5LCAxNzksIDAsIDgsIDksIDAsIDgsIDEzNywgMCwgOCwgNzMsIDAsIDksIDI0MywgODAsIDcsIDQsIDAsIDgsXFxuXFx0XFx0XFx0ODUsIDAsIDgsIDIxLCA4MCwgOCwgMjU4LCA4MywgNywgNDMsIDAsIDgsIDExNywgMCwgOCwgNTMsIDAsIDksIDIwMywgODEsIDcsIDEzLCAwLCA4LCAxMDEsIDAsIDgsIDM3LCAwLCA5LCAxNzEsIDAsIDgsIDUsIDAsIDgsIDEzMywgMCwgOCwgNjksIDAsIDksXFxuXFx0XFx0XFx0MjM1LCA4MCwgNywgOCwgMCwgOCwgOTMsIDAsIDgsIDI5LCAwLCA5LCAxNTUsIDg0LCA3LCA4MywgMCwgOCwgMTI1LCAwLCA4LCA2MSwgMCwgOSwgMjE5LCA4MiwgNywgMjMsIDAsIDgsIDEwOSwgMCwgOCwgNDUsIDAsIDksIDE4NywgMCwgOCwgMTMsIDAsIDgsXFxuXFx0XFx0XFx0MTQxLCAwLCA4LCA3NywgMCwgOSwgMjUxLCA4MCwgNywgMywgMCwgOCwgODMsIDAsIDgsIDE5LCA4NSwgOCwgMTk1LCA4MywgNywgMzUsIDAsIDgsIDExNSwgMCwgOCwgNTEsIDAsIDksIDE5OSwgODEsIDcsIDExLCAwLCA4LCA5OSwgMCwgOCwgMzUsIDAsIDksXFxuXFx0XFx0XFx0MTY3LCAwLCA4LCAzLCAwLCA4LCAxMzEsIDAsIDgsIDY3LCAwLCA5LCAyMzEsIDgwLCA3LCA3LCAwLCA4LCA5MSwgMCwgOCwgMjcsIDAsIDksIDE1MSwgODQsIDcsIDY3LCAwLCA4LCAxMjMsIDAsIDgsIDU5LCAwLCA5LCAyMTUsIDgyLCA3LCAxOSwgMCwgOCxcXG5cXHRcXHRcXHQxMDcsIDAsIDgsIDQzLCAwLCA5LCAxODMsIDAsIDgsIDExLCAwLCA4LCAxMzksIDAsIDgsIDc1LCAwLCA5LCAyNDcsIDgwLCA3LCA1LCAwLCA4LCA4NywgMCwgOCwgMjMsIDE5MiwgOCwgMCwgODMsIDcsIDUxLCAwLCA4LCAxMTksIDAsIDgsIDU1LCAwLCA5LFxcblxcdFxcdFxcdDIwNywgODEsIDcsIDE1LCAwLCA4LCAxMDMsIDAsIDgsIDM5LCAwLCA5LCAxNzUsIDAsIDgsIDcsIDAsIDgsIDEzNSwgMCwgOCwgNzEsIDAsIDksIDIzOSwgODAsIDcsIDksIDAsIDgsIDk1LCAwLCA4LCAzMSwgMCwgOSwgMTU5LCA4NCwgNywgOTksIDAsIDgsXFxuXFx0XFx0XFx0MTI3LCAwLCA4LCA2MywgMCwgOSwgMjIzLCA4MiwgNywgMjcsIDAsIDgsIDExMSwgMCwgOCwgNDcsIDAsIDksIDE5MSwgMCwgOCwgMTUsIDAsIDgsIDE0MywgMCwgOCwgNzksIDAsIDksIDI1NSBdO1xcblxcdHZhciBmaXhlZF90ZCA9IFsgODAsIDUsIDEsIDg3LCA1LCAyNTcsIDgzLCA1LCAxNywgOTEsIDUsIDQwOTcsIDgxLCA1LCA1LCA4OSwgNSwgMTAyNSwgODUsIDUsIDY1LCA5MywgNSwgMTYzODUsIDgwLCA1LCAzLCA4OCwgNSwgNTEzLCA4NCwgNSwgMzMsIDkyLCA1LFxcblxcdFxcdFxcdDgxOTMsIDgyLCA1LCA5LCA5MCwgNSwgMjA0OSwgODYsIDUsIDEyOSwgMTkyLCA1LCAyNDU3NywgODAsIDUsIDIsIDg3LCA1LCAzODUsIDgzLCA1LCAyNSwgOTEsIDUsIDYxNDUsIDgxLCA1LCA3LCA4OSwgNSwgMTUzNywgODUsIDUsIDk3LCA5MywgNSxcXG5cXHRcXHRcXHQyNDU3NywgODAsIDUsIDQsIDg4LCA1LCA3NjksIDg0LCA1LCA0OSwgOTIsIDUsIDEyMjg5LCA4MiwgNSwgMTMsIDkwLCA1LCAzMDczLCA4NiwgNSwgMTkzLCAxOTIsIDUsIDI0NTc3IF07XFxuXFxuXFx0Ly8gVGFibGVzIGZvciBkZWZsYXRlIGZyb20gUEtaSVAncyBhcHBub3RlLnR4dC5cXG5cXHR2YXIgY3BsZW5zID0gWyAvLyBDb3B5IGxlbmd0aHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcXG5cXHQzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLCAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMCBdO1xcblxcblxcdC8vIHNlZSBub3RlICMxMyBhYm92ZSBhYm91dCAyNThcXG5cXHR2YXIgY3BsZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XFxuXFx0MCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgMTEyLCAxMTIgLy8gMTEyPT1pbnZhbGlkXFxuXFx0XTtcXG5cXG5cXHR2YXIgY3BkaXN0ID0gWyAvLyBDb3B5IG9mZnNldHMgZm9yIGRpc3RhbmNlIGNvZGVzIDAuLjI5XFxuXFx0MSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLCAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcgXTtcXG5cXG5cXHR2YXIgY3BkZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBkaXN0YW5jZSBjb2Rlc1xcblxcdDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMyBdO1xcblxcblxcdC8vIElmIEJNQVggbmVlZHMgdG8gYmUgbGFyZ2VyIHRoYW4gMTYsIHRoZW4gaCBhbmQgeFtdIHNob3VsZCBiZSB1TG9uZy5cXG5cXHR2YXIgQk1BWCA9IDE1OyAvLyBtYXhpbXVtIGJpdCBsZW5ndGggb2YgYW55IGNvZGVcXG5cXG5cXHRmdW5jdGlvbiBJbmZUcmVlKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHR2YXIgaG47IC8vIGh1ZnRzIHVzZWQgaW4gc3BhY2VcXG5cXHRcXHR2YXIgdjsgLy8gd29yayBhcmVhIGZvciBodWZ0X2J1aWxkXFxuXFx0XFx0dmFyIGM7IC8vIGJpdCBsZW5ndGggY291bnQgdGFibGVcXG5cXHRcXHR2YXIgcjsgLy8gdGFibGUgZW50cnkgZm9yIHN0cnVjdHVyZSBhc3NpZ25tZW50XFxuXFx0XFx0dmFyIHU7IC8vIHRhYmxlIHN0YWNrXFxuXFx0XFx0dmFyIHg7IC8vIGJpdCBvZmZzZXRzLCB0aGVuIGNvZGUgc3RhY2tcXG5cXG5cXHRcXHRmdW5jdGlvbiBodWZ0X2J1aWxkKGIsIC8vIGNvZGUgbGVuZ3RocyBpbiBiaXRzIChhbGwgYXNzdW1lZCA8PVxcblxcdFxcdC8vIEJNQVgpXFxuXFx0XFx0YmluZGV4LCBuLCAvLyBudW1iZXIgb2YgY29kZXMgKGFzc3VtZWQgPD0gMjg4KVxcblxcdFxcdHMsIC8vIG51bWJlciBvZiBzaW1wbGUtdmFsdWVkIGNvZGVzICgwLi5zLTEpXFxuXFx0XFx0ZCwgLy8gbGlzdCBvZiBiYXNlIHZhbHVlcyBmb3Igbm9uLXNpbXBsZSBjb2Rlc1xcblxcdFxcdGUsIC8vIGxpc3Qgb2YgZXh0cmEgYml0cyBmb3Igbm9uLXNpbXBsZSBjb2Rlc1xcblxcdFxcdHQsIC8vIHJlc3VsdDogc3RhcnRpbmcgdGFibGVcXG5cXHRcXHRtLCAvLyBtYXhpbXVtIGxvb2t1cCBiaXRzLCByZXR1cm5zIGFjdHVhbFxcblxcdFxcdGhwLC8vIHNwYWNlIGZvciB0cmVlc1xcblxcdFxcdGhuLC8vIGh1ZnRzIHVzZWQgaW4gc3BhY2VcXG5cXHRcXHR2IC8vIHdvcmtpbmcgYXJlYTogdmFsdWVzIGluIG9yZGVyIG9mIGJpdCBsZW5ndGhcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHQvLyBHaXZlbiBhIGxpc3Qgb2YgY29kZSBsZW5ndGhzIGFuZCBhIG1heGltdW0gdGFibGUgc2l6ZSwgbWFrZSBhIHNldCBvZlxcblxcdFxcdFxcdC8vIHRhYmxlcyB0byBkZWNvZGUgdGhhdCBzZXQgb2YgY29kZXMuIFJldHVybiBaX09LIG9uIHN1Y2Nlc3MsXFxuXFx0XFx0XFx0Ly8gWl9CVUZfRVJST1JcXG5cXHRcXHRcXHQvLyBpZiB0aGUgZ2l2ZW4gY29kZSBzZXQgaXMgaW5jb21wbGV0ZSAodGhlIHRhYmxlcyBhcmUgc3RpbGwgYnVpbHQgaW5cXG5cXHRcXHRcXHQvLyB0aGlzXFxuXFx0XFx0XFx0Ly8gY2FzZSksIFpfREFUQV9FUlJPUiBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZCAoYW4gb3Zlci1zdWJzY3JpYmVkIHNldFxcblxcdFxcdFxcdC8vIG9mXFxuXFx0XFx0XFx0Ly8gbGVuZ3RocyksIG9yIFpfTUVNX0VSUk9SIGlmIG5vdCBlbm91Z2ggbWVtb3J5LlxcblxcblxcdFxcdFxcdHZhciBhOyAvLyBjb3VudGVyIGZvciBjb2RlcyBvZiBsZW5ndGgga1xcblxcdFxcdFxcdHZhciBmOyAvLyBpIHJlcGVhdHMgaW4gdGFibGUgZXZlcnkgZiBlbnRyaWVzXFxuXFx0XFx0XFx0dmFyIGc7IC8vIG1heGltdW0gY29kZSBsZW5ndGhcXG5cXHRcXHRcXHR2YXIgaDsgLy8gdGFibGUgbGV2ZWxcXG5cXHRcXHRcXHR2YXIgaTsgLy8gY291bnRlciwgY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIGo7IC8vIGNvdW50ZXJcXG5cXHRcXHRcXHR2YXIgazsgLy8gbnVtYmVyIG9mIGJpdHMgaW4gY3VycmVudCBjb2RlXFxuXFx0XFx0XFx0dmFyIGw7IC8vIGJpdHMgcGVyIHRhYmxlIChyZXR1cm5lZCBpbiBtKVxcblxcdFxcdFxcdHZhciBtYXNrOyAvLyAoMSA8PCB3KSAtIDEsIHRvIGF2b2lkIGNjIC1PIGJ1ZyBvbiBIUFxcblxcdFxcdFxcdHZhciBwOyAvLyBwb2ludGVyIGludG8gY1tdLCBiW10sIG9yIHZbXVxcblxcdFxcdFxcdHZhciBxOyAvLyBwb2ludHMgdG8gY3VycmVudCB0YWJsZVxcblxcdFxcdFxcdHZhciB3OyAvLyBiaXRzIGJlZm9yZSB0aGlzIHRhYmxlID09IChsICogaClcXG5cXHRcXHRcXHR2YXIgeHA7IC8vIHBvaW50ZXIgaW50byB4XFxuXFx0XFx0XFx0dmFyIHk7IC8vIG51bWJlciBvZiBkdW1teSBjb2RlcyBhZGRlZFxcblxcdFxcdFxcdHZhciB6OyAvLyBudW1iZXIgb2YgZW50cmllcyBpbiBjdXJyZW50IHRhYmxlXFxuXFxuXFx0XFx0XFx0Ly8gR2VuZXJhdGUgY291bnRzIGZvciBlYWNoIGJpdCBsZW5ndGhcXG5cXG5cXHRcXHRcXHRwID0gMDtcXG5cXHRcXHRcXHRpID0gbjtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0Y1tiW2JpbmRleCArIHBdXSsrO1xcblxcdFxcdFxcdFxcdHArKztcXG5cXHRcXHRcXHRcXHRpLS07IC8vIGFzc3VtZSBhbGwgZW50cmllcyA8PSBCTUFYXFxuXFx0XFx0XFx0fSB3aGlsZSAoaSAhPT0gMCk7XFxuXFxuXFx0XFx0XFx0aWYgKGNbMF0gPT0gbikgeyAvLyBudWxsIGlucHV0LS1hbGwgemVybyBsZW5ndGggY29kZXNcXG5cXHRcXHRcXHRcXHR0WzBdID0gLTE7XFxuXFx0XFx0XFx0XFx0bVswXSA9IDA7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZpbmQgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGgsIGJvdW5kICptIGJ5IHRob3NlXFxuXFx0XFx0XFx0bCA9IG1bMF07XFxuXFx0XFx0XFx0Zm9yIChqID0gMTsgaiA8PSBCTUFYOyBqKyspXFxuXFx0XFx0XFx0XFx0aWYgKGNbal0gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0ayA9IGo7IC8vIG1pbmltdW0gY29kZSBsZW5ndGhcXG5cXHRcXHRcXHRpZiAobCA8IGopIHtcXG5cXHRcXHRcXHRcXHRsID0gajtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gQk1BWDsgaSAhPT0gMDsgaS0tKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGNbaV0gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGcgPSBpOyAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXFxuXFx0XFx0XFx0aWYgKGwgPiBpKSB7XFxuXFx0XFx0XFx0XFx0bCA9IGk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1bMF0gPSBsO1xcblxcblxcdFxcdFxcdC8vIEFkanVzdCBsYXN0IGxlbmd0aCBjb3VudCB0byBmaWxsIG91dCBjb2RlcywgaWYgbmVlZGVkXFxuXFx0XFx0XFx0Zm9yICh5ID0gMSA8PCBqOyBqIDwgaTsgaisrLCB5IDw8PSAxKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCh5IC09IGNbal0pIDwgMCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoKHkgLT0gY1tpXSkgPCAwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y1tpXSArPSB5O1xcblxcblxcdFxcdFxcdC8vIEdlbmVyYXRlIHN0YXJ0aW5nIG9mZnNldHMgaW50byB0aGUgdmFsdWUgdGFibGUgZm9yIGVhY2ggbGVuZ3RoXFxuXFx0XFx0XFx0eFsxXSA9IGogPSAwO1xcblxcdFxcdFxcdHAgPSAxO1xcblxcdFxcdFxcdHhwID0gMjtcXG5cXHRcXHRcXHR3aGlsZSAoLS1pICE9PSAwKSB7IC8vIG5vdGUgdGhhdCBpID09IGcgZnJvbSBhYm92ZVxcblxcdFxcdFxcdFxcdHhbeHBdID0gKGogKz0gY1twXSk7XFxuXFx0XFx0XFx0XFx0eHArKztcXG5cXHRcXHRcXHRcXHRwKys7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1ha2UgYSB0YWJsZSBvZiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aHNcXG5cXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHRwID0gMDtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0aWYgKChqID0gYltiaW5kZXggKyBwXSkgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHR2W3hbal0rK10gPSBpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwKys7XFxuXFx0XFx0XFx0fSB3aGlsZSAoKytpIDwgbik7XFxuXFx0XFx0XFx0biA9IHhbZ107IC8vIHNldCBuIHRvIGxlbmd0aCBvZiB2XFxuXFxuXFx0XFx0XFx0Ly8gR2VuZXJhdGUgdGhlIEh1ZmZtYW4gY29kZXMgYW5kIGZvciBlYWNoLCBtYWtlIHRoZSB0YWJsZSBlbnRyaWVzXFxuXFx0XFx0XFx0eFswXSA9IGkgPSAwOyAvLyBmaXJzdCBIdWZmbWFuIGNvZGUgaXMgemVyb1xcblxcdFxcdFxcdHAgPSAwOyAvLyBncmFiIHZhbHVlcyBpbiBiaXQgb3JkZXJcXG5cXHRcXHRcXHRoID0gLTE7IC8vIG5vIHRhYmxlcyB5ZXQtLWxldmVsIC0xXFxuXFx0XFx0XFx0dyA9IC1sOyAvLyBiaXRzIGRlY29kZWQgPT0gKGwgKiBoKVxcblxcdFxcdFxcdHVbMF0gPSAwOyAvLyBqdXN0IHRvIGtlZXAgY29tcGlsZXJzIGhhcHB5XFxuXFx0XFx0XFx0cSA9IDA7IC8vIGRpdHRvXFxuXFx0XFx0XFx0eiA9IDA7IC8vIGRpdHRvXFxuXFxuXFx0XFx0XFx0Ly8gZ28gdGhyb3VnaCB0aGUgYml0IGxlbmd0aHMgKGsgYWxyZWFkeSBpcyBiaXRzIGluIHNob3J0ZXN0IGNvZGUpXFxuXFx0XFx0XFx0Zm9yICg7IGsgPD0gZzsgaysrKSB7XFxuXFx0XFx0XFx0XFx0YSA9IGNba107XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGEtLSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIGhlcmUgaSBpcyB0aGUgSHVmZm1hbiBjb2RlIG9mIGxlbmd0aCBrIGJpdHMgZm9yIHZhbHVlICpwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbWFrZSB0YWJsZXMgdXAgdG8gcmVxdWlyZWQgbGV2ZWxcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA+IHcgKyBsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aCsrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHcgKz0gbDsgLy8gcHJldmlvdXMgdGFibGUgYWx3YXlzIGwgYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvbXB1dGUgbWluaW11bSBzaXplIHRhYmxlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBsIGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gZyAtIHc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9ICh6ID4gbCkgPyBsIDogejsgLy8gdGFibGUgc2l6ZSB1cHBlciBsaW1pdFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgoZiA9IDEgPDwgKGogPSBrIC0gdykpID4gYSArIDEpIHsgLy8gdHJ5IGEgay13IGJpdCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHRvbyBmZXcgY29kZXMgZm9yXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gay13IGJpdCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGYgLT0gYSArIDE7IC8vIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zIGxlZnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR4cCA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGogPCB6KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCsraiA8IHopIHsgLy8gdHJ5IHNtYWxsZXIgdGFibGVzIHVwIHRvIHogYml0c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICgoZiA8PD0gMSkgPD0gY1srK3hwXSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gZW5vdWdoIGNvZGVzIHRvIHVzZSB1cCBqIGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmIC09IGNbeHBdOyAvLyBlbHNlIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IDEgPDwgajsgLy8gdGFibGUgZW50cmllcyBmb3Igai1iaXQgdGFibGVcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhbGxvY2F0ZSBuZXcgdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaG5bMF0gKyB6ID4gTUFOWSkgeyAvLyAobm90ZTogZG9lc24ndCBtYXR0ZXIgZm9yIGZpeGVkKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX0RBVEFfRVJST1I7IC8vIG92ZXJmbG93IG9mIE1BTllcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0dVtoXSA9IHEgPSAvKiBocCsgKi9oblswXTsgLy8gREVCVUdcXG5cXHRcXHRcXHRcXHRcXHRcXHRoblswXSArPSB6O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvbm5lY3QgdG8gbGFzdCB0YWJsZSwgaWYgdGhlcmUgaXMgb25lXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGggIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR4W2hdID0gaTsgLy8gc2F2ZSBwYXR0ZXJuIGZvciBiYWNraW5nIHVwXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0clswXSA9IC8qIChieXRlKSAqL2o7IC8vIGJpdHMgaW4gdGhpcyB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJbMV0gPSAvKiAoYnl0ZSkgKi9sOyAvLyBiaXRzIHRvIGR1bXAgYmVmb3JlIHRoaXMgdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqID0gaSA+Pj4gKHcgLSBsKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyWzJdID0gLyogKGludCkgKi8ocSAtIHVbaCAtIDFdIC0gaik7IC8vIG9mZnNldCB0byB0aGlzIHRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aHAuc2V0KHIsICh1W2ggLSAxXSArIGopICogMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gdG9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBsYXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRbMF0gPSBxOyAvLyBmaXJzdCB0YWJsZSBpcyByZXR1cm5lZCByZXN1bHRcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHNldCB1cCB0YWJsZSBlbnRyeSBpbiByXFxuXFx0XFx0XFx0XFx0XFx0clsxXSA9IC8qIChieXRlKSAqLyhrIC0gdyk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHAgPj0gbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJbMF0gPSAxMjggKyA2NDsgLy8gb3V0IG9mIHZhbHVlcy0taW52YWxpZCBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICh2W3BdIDwgcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJbMF0gPSAvKiAoYnl0ZSkgKi8odltwXSA8IDI1NiA/IDAgOiAzMiArIDY0KTsgLy8gMjU2IGlzXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZW5kLW9mLWJsb2NrXFxuXFx0XFx0XFx0XFx0XFx0XFx0clsyXSA9IHZbcCsrXTsgLy8gc2ltcGxlIGNvZGUgaXMganVzdCB0aGUgdmFsdWVcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJbMF0gPSAvKiAoYnl0ZSkgKi8oZVt2W3BdIC0gc10gKyAxNiArIDY0KTsgLy8gbm9uLXNpbXBsZS0tbG9va1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHVwIGluIGxpc3RzXFxuXFx0XFx0XFx0XFx0XFx0XFx0clsyXSA9IGRbdltwKytdIC0gc107XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZpbGwgY29kZS1saWtlIGVudHJpZXMgd2l0aCByXFxuXFx0XFx0XFx0XFx0XFx0ZiA9IDEgPDwgKGsgLSB3KTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGogPSBpID4+PiB3OyBqIDwgejsgaiArPSBmKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aHAuc2V0KHIsIChxICsgaikgKiAzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYmFja3dhcmRzIGluY3JlbWVudCB0aGUgay1iaXQgY29kZSBpXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChqID0gMSA8PCAoayAtIDEpOyAoaSAmIGopICE9PSAwOyBqID4+Pj0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGkgXj0gajtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aSBePSBqO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGJhY2t1cCBvdmVyIGZpbmlzaGVkIHRhYmxlc1xcblxcdFxcdFxcdFxcdFxcdG1hc2sgPSAoMSA8PCB3KSAtIDE7IC8vIG5lZWRlZCBvbiBIUCwgY2MgLU8gYnVnXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKChpICYgbWFzaykgIT0geFtoXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGgtLTsgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgcVxcblxcdFxcdFxcdFxcdFxcdFxcdHcgLT0gbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXNrID0gKDEgPDwgdykgLSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIFJldHVybiBaX0JVRl9FUlJPUiBpZiB3ZSB3ZXJlIGdpdmVuIGFuIGluY29tcGxldGUgdGFibGVcXG5cXHRcXHRcXHRyZXR1cm4geSAhPT0gMCAmJiBnICE9IDEgPyBaX0JVRl9FUlJPUiA6IFpfT0s7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGluaXRXb3JrQXJlYSh2c2l6ZSkge1xcblxcdFxcdFxcdHZhciBpO1xcblxcdFxcdFxcdGlmICghaG4pIHtcXG5cXHRcXHRcXHRcXHRobiA9IFtdOyAvLyBbXTsgLy9uZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0diA9IFtdOyAvLyBuZXcgQXJyYXkodnNpemUpO1xcblxcdFxcdFxcdFxcdGMgPSBuZXcgSW50MzJBcnJheShCTUFYICsgMSk7IC8vIG5ldyBBcnJheShCTUFYICsgMSk7XFxuXFx0XFx0XFx0XFx0ciA9IFtdOyAvLyBuZXcgQXJyYXkoMyk7XFxuXFx0XFx0XFx0XFx0dSA9IG5ldyBJbnQzMkFycmF5KEJNQVgpOyAvLyBuZXcgQXJyYXkoQk1BWCk7XFxuXFx0XFx0XFx0XFx0eCA9IG5ldyBJbnQzMkFycmF5KEJNQVggKyAxKTsgLy8gbmV3IEFycmF5KEJNQVggKyAxKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHYubGVuZ3RoIDwgdnNpemUpIHtcXG5cXHRcXHRcXHRcXHR2ID0gW107IC8vIG5ldyBBcnJheSh2c2l6ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCB2c2l6ZTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dltpXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBCTUFYICsgMTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Y1tpXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRyW2ldID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gZm9yKGludCBpPTA7IGk8Qk1BWDsgaSsrKXt1W2ldPTA7fVxcblxcdFxcdFxcdHUuc2V0KGMuc3ViYXJyYXkoMCwgQk1BWCksIDApO1xcblxcdFxcdFxcdC8vIGZvcihpbnQgaT0wOyBpPEJNQVgrMTsgaSsrKXt4W2ldPTA7fVxcblxcdFxcdFxcdHguc2V0KGMuc3ViYXJyYXkoMCwgQk1BWCArIDEpLCAwKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhhdC5pbmZsYXRlX3RyZWVzX2JpdHMgPSBmdW5jdGlvbihjLCAvLyAxOSBjb2RlIGxlbmd0aHNcXG5cXHRcXHRiYiwgLy8gYml0cyB0cmVlIGRlc2lyZWQvYWN0dWFsIGRlcHRoXFxuXFx0XFx0dGIsIC8vIGJpdHMgdHJlZSByZXN1bHRcXG5cXHRcXHRocCwgLy8gc3BhY2UgZm9yIHRyZWVzXFxuXFx0XFx0eiAvLyBmb3IgbWVzc2FnZXNcXG5cXHRcXHQpIHtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0O1xcblxcdFxcdFxcdGluaXRXb3JrQXJlYSgxOSk7XFxuXFx0XFx0XFx0aG5bMF0gPSAwO1xcblxcdFxcdFxcdHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgMCwgMTksIDE5LCBudWxsLCBudWxsLCB0YiwgYmIsIGhwLCBobiwgdik7XFxuXFxuXFx0XFx0XFx0aWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1IpIHtcXG5cXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJvdmVyc3Vic2NyaWJlZCBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcXFwiO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAocmVzdWx0ID09IFpfQlVGX0VSUk9SIHx8IGJiWzBdID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW5jb21wbGV0ZSBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcXFwiO1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuaW5mbGF0ZV90cmVlc19keW5hbWljID0gZnVuY3Rpb24obmwsIC8vIG51bWJlciBvZiBsaXRlcmFsL2xlbmd0aCBjb2Rlc1xcblxcdFxcdG5kLCAvLyBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXNcXG5cXHRcXHRjLCAvLyB0aGF0IG1hbnkgKHRvdGFsKSBjb2RlIGxlbmd0aHNcXG5cXHRcXHRibCwgLy8gbGl0ZXJhbCBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcXG5cXHRcXHRiZCwgLy8gZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXFxuXFx0XFx0dGwsIC8vIGxpdGVyYWwvbGVuZ3RoIHRyZWUgcmVzdWx0XFxuXFx0XFx0dGQsIC8vIGRpc3RhbmNlIHRyZWUgcmVzdWx0XFxuXFx0XFx0aHAsIC8vIHNwYWNlIGZvciB0cmVlc1xcblxcdFxcdHogLy8gZm9yIG1lc3NhZ2VzXFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dmFyIHJlc3VsdDtcXG5cXG5cXHRcXHRcXHQvLyBidWlsZCBsaXRlcmFsL2xlbmd0aCB0cmVlXFxuXFx0XFx0XFx0aW5pdFdvcmtBcmVhKDI4OCk7XFxuXFx0XFx0XFx0aG5bMF0gPSAwO1xcblxcdFxcdFxcdHJlc3VsdCA9IGh1ZnRfYnVpbGQoYywgMCwgbmwsIDI1NywgY3BsZW5zLCBjcGxleHQsIHRsLCBibCwgaHAsIGhuLCB2KTtcXG5cXHRcXHRcXHRpZiAocmVzdWx0ICE9IFpfT0sgfHwgYmxbMF0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRpZiAocmVzdWx0ID09IFpfREFUQV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcIm92ZXJzdWJzY3JpYmVkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcXFwiO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW5jb21wbGV0ZSBsaXRlcmFsL2xlbmd0aCB0cmVlXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGJ1aWxkIGRpc3RhbmNlIHRyZWVcXG5cXHRcXHRcXHRpbml0V29ya0FyZWEoMjg4KTtcXG5cXHRcXHRcXHRyZXN1bHQgPSBodWZ0X2J1aWxkKGMsIG5sLCBuZCwgMCwgY3BkaXN0LCBjcGRleHQsIHRkLCBiZCwgaHAsIGhuLCB2KTtcXG5cXG5cXHRcXHRcXHRpZiAocmVzdWx0ICE9IFpfT0sgfHwgKGJkWzBdID09PSAwICYmIG5sID4gMjU3KSkge1xcblxcdFxcdFxcdFxcdGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwib3ZlcnN1YnNjcmliZWQgZGlzdGFuY2UgdHJlZVxcXCI7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChyZXN1bHQgPT0gWl9CVUZfRVJST1IpIHtcXG5cXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbmNvbXBsZXRlIGRpc3RhbmNlIHRyZWVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHJlc3VsdCAhPSBaX01FTV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImVtcHR5IGRpc3RhbmNlIHRyZWUgd2l0aCBsZW5ndGhzXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQgPSBaX0RBVEFfRVJST1I7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdEluZlRyZWUuaW5mbGF0ZV90cmVlc19maXhlZCA9IGZ1bmN0aW9uKGJsLCAvLyBsaXRlcmFsIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxcblxcdGJkLCAvLyBkaXN0YW5jZSBkZXNpcmVkL2FjdHVhbCBiaXQgZGVwdGhcXG5cXHR0bCwvLyBsaXRlcmFsL2xlbmd0aCB0cmVlIHJlc3VsdFxcblxcdHRkLy8gZGlzdGFuY2UgdHJlZSByZXN1bHRcXG5cXHQpIHtcXG5cXHRcXHRibFswXSA9IGZpeGVkX2JsO1xcblxcdFxcdGJkWzBdID0gZml4ZWRfYmQ7XFxuXFx0XFx0dGxbMF0gPSBmaXhlZF90bDtcXG5cXHRcXHR0ZFswXSA9IGZpeGVkX3RkO1xcblxcdFxcdHJldHVybiBaX09LO1xcblxcdH07XFxuXFxuXFx0Ly8gSW5mQ29kZXNcXG5cXG5cXHQvLyB3YWl0aW5nIGZvciBcXFwiaTpcXFwiPWlucHV0LFxcblxcdC8vIFxcXCJvOlxcXCI9b3V0cHV0LFxcblxcdC8vIFxcXCJ4OlxcXCI9bm90aGluZ1xcblxcdHZhciBTVEFSVCA9IDA7IC8vIHg6IHNldCB1cCBmb3IgTEVOXFxuXFx0dmFyIExFTiA9IDE7IC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxcblxcdHZhciBMRU5FWFQgPSAyOyAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxcblxcdHZhciBESVNUID0gMzsgLy8gaTogZ2V0IGRpc3RhbmNlIG5leHRcXG5cXHR2YXIgRElTVEVYVCA9IDQ7Ly8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxcblxcdHZhciBDT1BZID0gNTsgLy8gbzogY29weWluZyBieXRlcyBpbiB3aW5kb3csIHdhaXRpbmdcXG5cXHQvLyBmb3Igc3BhY2VcXG5cXHR2YXIgTElUID0gNjsgLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dFxcblxcdC8vIHNwYWNlXFxuXFx0dmFyIFdBU0ggPSA3OyAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBzdGlsbCBvdXRwdXRcXG5cXHQvLyB3YWl0aW5nXFxuXFx0dmFyIEVORCA9IDg7IC8vIHg6IGdvdCBlb2IgYW5kIGFsbCBkYXRhIGZsdXNoZWRcXG5cXHR2YXIgQkFEQ09ERSA9IDk7Ly8geDogZ290IGVycm9yXFxuXFxuXFx0ZnVuY3Rpb24gSW5mQ29kZXMoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdHZhciBtb2RlOyAvLyBjdXJyZW50IGluZmxhdGVfY29kZXMgbW9kZVxcblxcblxcdFxcdC8vIG1vZGUgZGVwZW5kZW50IGluZm9ybWF0aW9uXFxuXFx0XFx0dmFyIGxlbiA9IDA7XFxuXFxuXFx0XFx0dmFyIHRyZWU7IC8vIHBvaW50ZXIgaW50byB0cmVlXFxuXFx0XFx0dmFyIHRyZWVfaW5kZXggPSAwO1xcblxcdFxcdHZhciBuZWVkID0gMDsgLy8gYml0cyBuZWVkZWRcXG5cXG5cXHRcXHR2YXIgbGl0ID0gMDtcXG5cXG5cXHRcXHQvLyBpZiBFWFQgb3IgQ09QWSwgd2hlcmUgYW5kIGhvdyBtdWNoXFxuXFx0XFx0dmFyIGdldCA9IDA7IC8vIGJpdHMgdG8gZ2V0IGZvciBleHRyYVxcblxcdFxcdHZhciBkaXN0ID0gMDsgLy8gZGlzdGFuY2UgYmFjayB0byBjb3B5IGZyb21cXG5cXG5cXHRcXHR2YXIgbGJpdHMgPSAwOyAvLyBsdHJlZSBiaXRzIGRlY29kZWQgcGVyIGJyYW5jaFxcblxcdFxcdHZhciBkYml0cyA9IDA7IC8vIGR0cmVlIGJpdHMgZGVjb2RlciBwZXIgYnJhbmNoXFxuXFx0XFx0dmFyIGx0cmVlOyAvLyBsaXRlcmFsL2xlbmd0aC9lb2IgdHJlZVxcblxcdFxcdHZhciBsdHJlZV9pbmRleCA9IDA7IC8vIGxpdGVyYWwvbGVuZ3RoL2VvYiB0cmVlXFxuXFx0XFx0dmFyIGR0cmVlOyAvLyBkaXN0YW5jZSB0cmVlXFxuXFx0XFx0dmFyIGR0cmVlX2luZGV4ID0gMDsgLy8gZGlzdGFuY2UgdHJlZVxcblxcblxcdFxcdC8vIENhbGxlZCB3aXRoIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIHdyaXRlIGluIHdpbmRvdyBhdCBsZWFzdCAyNThcXG5cXHRcXHQvLyAodGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aCkgYW5kIG51bWJlciBvZiBpbnB1dCBieXRlcyBhdmFpbGFibGVcXG5cXHRcXHQvLyBhdCBsZWFzdCB0ZW4uIFRoZSB0ZW4gYnl0ZXMgYXJlIHNpeCBieXRlcyBmb3IgdGhlIGxvbmdlc3QgbGVuZ3RoL1xcblxcdFxcdC8vIGRpc3RhbmNlIHBhaXIgcGx1cyBmb3VyIGJ5dGVzIGZvciBvdmVybG9hZGluZyB0aGUgYml0IGJ1ZmZlci5cXG5cXG5cXHRcXHRmdW5jdGlvbiBpbmZsYXRlX2Zhc3QoYmwsIGJkLCB0bCwgdGxfaW5kZXgsIHRkLCB0ZF9pbmRleCwgcywgeikge1xcblxcdFxcdFxcdHZhciB0OyAvLyB0ZW1wb3JhcnkgcG9pbnRlclxcblxcdFxcdFxcdHZhciB0cDsgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgdHBfaW5kZXg7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIGU7IC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXFxuXFx0XFx0XFx0dmFyIGI7IC8vIGJpdCBidWZmZXJcXG5cXHRcXHRcXHR2YXIgazsgLy8gYml0cyBpbiBiaXQgYnVmZmVyXFxuXFx0XFx0XFx0dmFyIHA7IC8vIGlucHV0IGRhdGEgcG9pbnRlclxcblxcdFxcdFxcdHZhciBuOyAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcXG5cXHRcXHRcXHR2YXIgcTsgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG07IC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG1sOyAvLyBtYXNrIGZvciBsaXRlcmFsL2xlbmd0aCB0cmVlXFxuXFx0XFx0XFx0dmFyIG1kOyAvLyBtYXNrIGZvciBkaXN0YW5jZSB0cmVlXFxuXFx0XFx0XFx0dmFyIGM7IC8vIGJ5dGVzIHRvIGNvcHlcXG5cXHRcXHRcXHR2YXIgZDsgLy8gZGlzdGFuY2UgYmFjayB0byBjb3B5IGZyb21cXG5cXHRcXHRcXHR2YXIgcjsgLy8gY29weSBzb3VyY2UgcG9pbnRlclxcblxcblxcdFxcdFxcdHZhciB0cF9pbmRleF90XzM7IC8vICh0cF9pbmRleCt0KSozXFxuXFxuXFx0XFx0XFx0Ly8gbG9hZCBpbnB1dCwgb3V0cHV0LCBiaXQgdmFsdWVzXFxuXFx0XFx0XFx0cCA9IHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRuID0gei5hdmFpbF9pbjtcXG5cXHRcXHRcXHRiID0gcy5iaXRiO1xcblxcdFxcdFxcdGsgPSBzLmJpdGs7XFxuXFx0XFx0XFx0cSA9IHMud3JpdGU7XFxuXFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXG5cXHRcXHRcXHQvLyBpbml0aWFsaXplIG1hc2tzXFxuXFx0XFx0XFx0bWwgPSBpbmZsYXRlX21hc2tbYmxdO1xcblxcdFxcdFxcdG1kID0gaW5mbGF0ZV9tYXNrW2JkXTtcXG5cXG5cXHRcXHRcXHQvLyBkbyB1bnRpbCBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBzcGFjZSBmb3IgZmFzdCBsb29wXFxuXFx0XFx0XFx0ZG8geyAvLyBhc3N1bWUgY2FsbGVkIHdpdGggbSA+PSAyNTggJiYgbiA+PSAxMFxcblxcdFxcdFxcdFxcdC8vIGdldCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxuXFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoMjApKSB7IC8vIG1heCBiaXRzIGZvciBsaXRlcmFsL2xlbmd0aCBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dCA9IGIgJiBtbDtcXG5cXHRcXHRcXHRcXHR0cCA9IHRsO1xcblxcdFxcdFxcdFxcdHRwX2luZGV4ID0gdGxfaW5kZXg7XFxuXFx0XFx0XFx0XFx0dHBfaW5kZXhfdF8zID0gKHRwX2luZGV4ICsgdCkgKiAzO1xcblxcdFxcdFxcdFxcdGlmICgoZSA9IHRwW3RwX2luZGV4X3RfM10pID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXHRcXHRcXHRcXHRcXHRrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cy53aW5kb3dbcSsrXSA9IC8qIChieXRlKSAqL3RwW3RwX2luZGV4X3RfMyArIDJdO1xcblxcdFxcdFxcdFxcdFxcdG0tLTtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdFxcdFxcdGIgPj49ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFx0XFx0XFx0XFx0XFx0ayAtPSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICgoZSAmIDE2KSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGUgJj0gMTU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHRwW3RwX2luZGV4X3RfMyArIDJdICsgKC8qIChpbnQpICovYiAmIGluZmxhdGVfbWFza1tlXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj0gZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09IGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVjb2RlIGRpc3RhbmNlIGJhc2Ugb2YgYmxvY2sgdG8gY29weVxcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKDE1KSkgeyAvLyBtYXggYml0cyBmb3IgZGlzdGFuY2UgY29kZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBiICYgbWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHAgPSB0ZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cF9pbmRleCA9IHRkX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRwX2luZGV4X3RfMyA9ICh0cF9pbmRleCArIHQpICogMztcXG5cXHRcXHRcXHRcXHRcXHRcXHRlID0gdHBbdHBfaW5kZXhfdF8zXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrIC09ICh0cFt0cF9pbmRleF90XzMgKyAxXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKChlICYgMTYpICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZ2V0IGV4dHJhIGJpdHMgdG8gYWRkIHRvIGRpc3RhbmNlIGJhc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlICY9IDE1O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKGUpKSB7IC8vIGdldCBleHRyYSBiaXRzICh1cCB0byAxMylcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkID0gdHBbdHBfaW5kZXhfdF8zICsgMl0gKyAoYiAmIGluZmxhdGVfbWFza1tlXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj0gKGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKGUpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGRvIHRoZSBjb3B5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSAtPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChxID49IGQpIHsgLy8gb2Zmc2V0IGJlZm9yZSBkZXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8ganVzdCBjb3B5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IHEgLSBkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChxIC0gciA+IDAgJiYgMiA+IChxIC0gcikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTsgLy8gbWluaW11bVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvdW50IGlzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGhyZWUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107IC8vIHNvIHVucm9sbFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxvb3AgYVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxpdHRsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgLT0gMjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShyLCByICsgMiksIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgKz0gMjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyICs9IDI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyAtPSAyO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgeyAvLyBlbHNlIG9mZnNldCBhZnRlciBkZXN0aW5hdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBxIC0gZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciArPSBzLmVuZDsgLy8gZm9yY2UgcG9pbnRlciBpbiB3aW5kb3dcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlIChyIDwgMCk7IC8vIGNvdmVycyBpbnZhbGlkIGRpc3RhbmNlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGUgPSBzLmVuZCAtIHI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGMgPiBlKSB7IC8vIGlmIHNvdXJjZSBjcm9zc2VzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgLT0gZTsgLy8gd3JhcHBlZCBjb3B5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgLSByID4gMCAmJiBlID4gKHEgLSByKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gcy53aW5kb3dbcisrXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgtLWUgIT09IDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHIsIHIgKyBlKSwgcSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSArPSBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgKz0gZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IDA7IC8vIGNvcHkgcmVzdCBmcm9tIHN0YXJ0IG9mIHdpbmRvd1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gY29weSBhbGwgb3Igd2hhdCdzIGxlZnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocSAtIHIgPiAwICYmIGMgPiAocSAtIHIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0tYyAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkociwgciArIGMpLCBxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRxICs9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciArPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKChlICYgNjQpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dCArPSB0cFt0cF9pbmRleF90XzMgKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZSA9IHRwW3RwX2luZGV4X3RfM107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSB6LmF2YWlsX2luIC0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuICs9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cCAtPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gYyA8PCAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlICh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgNjQpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dCArPSB0cFt0cF9pbmRleF90XzMgKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cF9pbmRleF90XzMgPSAodHBfaW5kZXggKyB0KSAqIDM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKChlID0gdHBbdHBfaW5kZXhfdF8zXSkgPT09IDApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID4+PSAodHBbdHBfaW5kZXhfdF8zICsgMV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKHRwW3RwX2luZGV4X3RfMyArIDFdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gLyogKGJ5dGUpICovdHBbdHBfaW5kZXhfdF8zICsgMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bS0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKChlICYgMzIpICE9PSAwKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHouYXZhaWxfaW4gLSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSAoayA+PiAzKSA8IGMgPyBrID4+IDMgOiBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdG4gKz0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRwIC09IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSBjIDw8IDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FTkQ7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSB6LmF2YWlsX2luIC0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gKGsgPj4gMykgPCBjID8gayA+PiAzIDogYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRuICs9IGM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cCAtPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gYyA8PCAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IHdoaWxlICh0cnVlKTtcXG5cXHRcXHRcXHR9IHdoaWxlIChtID49IDI1OCAmJiBuID49IDEwKTtcXG5cXG5cXHRcXHRcXHQvLyBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dC0tcmVzdG9yZSBwb2ludGVycyBhbmQgcmV0dXJuXFxuXFx0XFx0XFx0YyA9IHouYXZhaWxfaW4gLSBuO1xcblxcdFxcdFxcdGMgPSAoayA+PiAzKSA8IGMgPyBrID4+IDMgOiBjO1xcblxcdFxcdFxcdG4gKz0gYztcXG5cXHRcXHRcXHRwIC09IGM7XFxuXFx0XFx0XFx0ayAtPSBjIDw8IDM7XFxuXFxuXFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGF0LmluaXQgPSBmdW5jdGlvbihibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4KSB7XFxuXFx0XFx0XFx0bW9kZSA9IFNUQVJUO1xcblxcdFxcdFxcdGxiaXRzID0gLyogKGJ5dGUpICovYmw7XFxuXFx0XFx0XFx0ZGJpdHMgPSAvKiAoYnl0ZSkgKi9iZDtcXG5cXHRcXHRcXHRsdHJlZSA9IHRsO1xcblxcdFxcdFxcdGx0cmVlX2luZGV4ID0gdGxfaW5kZXg7XFxuXFx0XFx0XFx0ZHRyZWUgPSB0ZDtcXG5cXHRcXHRcXHRkdHJlZV9pbmRleCA9IHRkX2luZGV4O1xcblxcdFxcdFxcdHRyZWUgPSBudWxsO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5wcm9jID0gZnVuY3Rpb24ocywgeiwgcikge1xcblxcdFxcdFxcdHZhciBqOyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcblxcdFxcdFxcdHZhciB0aW5kZXg7IC8vIHRlbXBvcmFyeSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIGU7IC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXFxuXFx0XFx0XFx0dmFyIGIgPSAwOyAvLyBiaXQgYnVmZmVyXFxuXFx0XFx0XFx0dmFyIGsgPSAwOyAvLyBiaXRzIGluIGJpdCBidWZmZXJcXG5cXHRcXHRcXHR2YXIgcCA9IDA7IC8vIGlucHV0IGRhdGEgcG9pbnRlclxcblxcdFxcdFxcdHZhciBuOyAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcXG5cXHRcXHRcXHR2YXIgcTsgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIG07IC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXFxuXFx0XFx0XFx0dmFyIGY7IC8vIHBvaW50ZXIgdG8gY29weSBzdHJpbmdzIGZyb21cXG5cXG5cXHRcXHRcXHQvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcXG5cXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdG4gPSB6LmF2YWlsX2luO1xcblxcdFxcdFxcdGIgPSBzLmJpdGI7XFxuXFx0XFx0XFx0ayA9IHMuYml0aztcXG5cXHRcXHRcXHRxID0gcy53cml0ZTtcXG5cXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcblxcdFxcdFxcdC8vIHByb2Nlc3MgaW5wdXQgYW5kIG91dHB1dCBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKG1vZGUpIHtcXG5cXHRcXHRcXHRcXHQvLyB3YWl0aW5nIGZvciBcXFwiaTpcXFwiPWlucHV0LCBcXFwibzpcXFwiPW91dHB1dCwgXFxcIng6XFxcIj1ub3RoaW5nXFxuXFx0XFx0XFx0XFx0Y2FzZSBTVEFSVDogLy8geDogc2V0IHVwIGZvciBMRU5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobSA+PSAyNTggJiYgbiA+PSAxMCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gaW5mbGF0ZV9mYXN0KGxiaXRzLCBkYml0cywgbHRyZWUsIGx0cmVlX2luZGV4LCBkdHJlZSwgZHRyZWVfaW5kZXgsIHMsIHopO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHAgPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0biA9IHouYXZhaWxfaW47XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA9IHMuYml0YjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrID0gcy5iaXRrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHIgIT0gWl9PSykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSByID09IFpfU1RSRUFNX0VORCA/IFdBU0ggOiBCQURDT0RFO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bmVlZCA9IGxiaXRzO1xcblxcdFxcdFxcdFxcdFxcdHRyZWUgPSBsdHJlZTtcXG5cXHRcXHRcXHRcXHRcXHR0cmVlX2luZGV4ID0gbHRyZWVfaW5kZXg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IExFTjtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBMRU46IC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxcblxcdFxcdFxcdFxcdFxcdGogPSBuZWVkO1xcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKGopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj49ICh0cmVlW3RpbmRleCArIDFdKTtcXG5cXHRcXHRcXHRcXHRcXHRrIC09ICh0cmVlW3RpbmRleCArIDFdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlID0gdHJlZVt0aW5kZXhdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChlID09PSAwKSB7IC8vIGxpdGVyYWxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaXQgPSB0cmVlW3RpbmRleCArIDJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBMSVQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgoZSAmIDE2KSAhPT0gMCkgeyAvLyBsZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXQgPSBlICYgMTU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVuID0gdHJlZVt0aW5kZXggKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gTEVORVhUO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGUgJiA2NCkgPT09IDApIHsgLy8gbmV4dCB0YWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdG5lZWQgPSBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyZWVfaW5kZXggPSB0aW5kZXggLyAzICsgdHJlZVt0aW5kZXggKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgMzIpICE9PSAwKSB7IC8vIGVuZCBvZiBibG9ja1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBXQVNIO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQ09ERTsgLy8gaW52YWxpZCBjb2RlXFxuXFx0XFx0XFx0XFx0XFx0ei5tc2cgPSBcXFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9EQVRBX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgTEVORVhUOiAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxcblxcdFxcdFxcdFxcdFxcdGogPSBnZXQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGVuICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRiID4+PSBqO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gajtcXG5cXG5cXHRcXHRcXHRcXHRcXHRuZWVkID0gZGJpdHM7XFxuXFx0XFx0XFx0XFx0XFx0dHJlZSA9IGR0cmVlO1xcblxcdFxcdFxcdFxcdFxcdHRyZWVfaW5kZXggPSBkdHJlZV9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRElTVDtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBESVNUOiAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxcblxcdFxcdFxcdFxcdFxcdGogPSBuZWVkO1xcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKGopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRpbmRleCA9ICh0cmVlX2luZGV4ICsgKGIgJiBpbmZsYXRlX21hc2tbal0pKSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YiA+Pj0gdHJlZVt0aW5kZXggKyAxXTtcXG5cXHRcXHRcXHRcXHRcXHRrIC09IHRyZWVbdGluZGV4ICsgMV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZSA9ICh0cmVlW3RpbmRleF0pO1xcblxcdFxcdFxcdFxcdFxcdGlmICgoZSAmIDE2KSAhPT0gMCkgeyAvLyBkaXN0YW5jZVxcblxcdFxcdFxcdFxcdFxcdFxcdGdldCA9IGUgJiAxNTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXN0ID0gdHJlZVt0aW5kZXggKyAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gRElTVEVYVDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKChlICYgNjQpID09PSAwKSB7IC8vIG5leHQgdGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZWVkID0gZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cmVlX2luZGV4ID0gdGluZGV4IC8gMyArIHRyZWVbdGluZGV4ICsgMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCQURDT0RFOyAvLyBpbnZhbGlkIGNvZGVcXG5cXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHMud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBESVNURVhUOiAvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXFxuXFx0XFx0XFx0XFx0XFx0aiA9IGdldDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8IChqKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRkaXN0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRiID4+PSBqO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gajtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gQ09QWTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBDT1BZOiAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcXG5cXHRcXHRcXHRcXHRcXHRmID0gcSAtIGRpc3Q7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGYgPCAwKSB7IC8vIG1vZHVsbyB3aW5kb3cgc2l6ZS1cXFwid2hpbGVcXFwiIGluc3RlYWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRmICs9IHMuZW5kOyAvLyBvZiBcXFwiaWZcXFwiIGhhbmRsZXMgaW52YWxpZCBkaXN0YW5jZXNcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGxlbiAhPT0gMCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gcy53aW5kb3dbZisrXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtLS07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGYgPT0gcy5lbmQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVuLS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBTVEFSVDtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIExJVDogLy8gbzogZ290IGxpdGVyYWwsIHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZVxcblxcdFxcdFxcdFxcdFxcdGlmIChtID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSBzLndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSBxIDwgcy5yZWFkID8gcy5yZWFkIC0gcSAtIDEgOiBzLmVuZCAtIHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHEgPT0gcy5lbmQgJiYgcy5yZWFkICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bSA9IHEgPCBzLnJlYWQgPyBzLnJlYWQgLSBxIC0gMSA6IHMuZW5kIC0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLndpbmRvd1txKytdID0gLyogKGJ5dGUpICovbGl0O1xcblxcdFxcdFxcdFxcdFxcdG0tLTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gU1RBUlQ7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBXQVNIOiAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBtb3JlIG91dHB1dFxcblxcdFxcdFxcdFxcdFxcdGlmIChrID4gNykgeyAvLyByZXR1cm4gdW51c2VkIGJ5dGUsIGlmIGFueVxcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuKys7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cC0tOyAvLyBjYW4gYWx3YXlzIHJldHVybiBvbmVcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRxID0gcy53cml0ZTtcXG5cXHRcXHRcXHRcXHRcXHRtID0gcSA8IHMucmVhZCA/IHMucmVhZCAtIHEgLSAxIDogcy5lbmQgLSBxO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChzLnJlYWQgIT0gcy53cml0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRU5EO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIEVORDpcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9TVFJFQU1fRU5EO1xcblxcdFxcdFxcdFxcdFxcdHMuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0cy5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRzLndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgQkFEQ09ERTogLy8geDogZ290IGVycm9yXFxuXFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXG5cXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX1NUUkVBTV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzLmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHMuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0cy53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5mcmVlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Ly8gWkZSRUUoeiwgYyk7XFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gSW5mQmxvY2tzXFxuXFxuXFx0Ly8gVGFibGUgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxcblxcdHZhciBib3JkZXIgPSBbIC8vIE9yZGVyIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGUgbGVuZ3Roc1xcblxcdDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcXG5cXG5cXHR2YXIgVFlQRSA9IDA7IC8vIGdldCB0eXBlIGJpdHMgKDMsIGluY2x1ZGluZyBlbmQgYml0KVxcblxcdHZhciBMRU5TID0gMTsgLy8gZ2V0IGxlbmd0aHMgZm9yIHN0b3JlZFxcblxcdHZhciBTVE9SRUQgPSAyOy8vIHByb2Nlc3Npbmcgc3RvcmVkIGJsb2NrXFxuXFx0dmFyIFRBQkxFID0gMzsgLy8gZ2V0IHRhYmxlIGxlbmd0aHNcXG5cXHR2YXIgQlRSRUUgPSA0OyAvLyBnZXQgYml0IGxlbmd0aHMgdHJlZSBmb3IgYSBkeW5hbWljXFxuXFx0Ly8gYmxvY2tcXG5cXHR2YXIgRFRSRUUgPSA1OyAvLyBnZXQgbGVuZ3RoLCBkaXN0YW5jZSB0cmVlcyBmb3IgYVxcblxcdC8vIGR5bmFtaWMgYmxvY2tcXG5cXHR2YXIgQ09ERVMgPSA2OyAvLyBwcm9jZXNzaW5nIGZpeGVkIG9yIGR5bmFtaWMgYmxvY2tcXG5cXHR2YXIgRFJZID0gNzsgLy8gb3V0cHV0IHJlbWFpbmluZyB3aW5kb3cgYnl0ZXNcXG5cXHR2YXIgRE9ORUxPQ0tTID0gODsgLy8gZmluaXNoZWQgbGFzdCBibG9jaywgZG9uZVxcblxcdHZhciBCQURCTE9DS1MgPSA5OyAvLyBvdCBhIGRhdGEgZXJyb3ItLXN0dWNrIGhlcmVcXG5cXG5cXHRmdW5jdGlvbiBJbmZCbG9ja3Moeiwgdykge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHR2YXIgbW9kZSA9IFRZUEU7IC8vIGN1cnJlbnQgaW5mbGF0ZV9ibG9jayBtb2RlXFxuXFxuXFx0XFx0dmFyIGxlZnQgPSAwOyAvLyBpZiBTVE9SRUQsIGJ5dGVzIGxlZnQgdG8gY29weVxcblxcblxcdFxcdHZhciB0YWJsZSA9IDA7IC8vIHRhYmxlIGxlbmd0aHMgKDE0IGJpdHMpXFxuXFx0XFx0dmFyIGluZGV4ID0gMDsgLy8gaW5kZXggaW50byBibGVucyAob3IgYm9yZGVyKVxcblxcdFxcdHZhciBibGVuczsgLy8gYml0IGxlbmd0aHMgb2YgY29kZXNcXG5cXHRcXHR2YXIgYmIgPSBbIDAgXTsgLy8gYml0IGxlbmd0aCB0cmVlIGRlcHRoXFxuXFx0XFx0dmFyIHRiID0gWyAwIF07IC8vIGJpdCBsZW5ndGggZGVjb2RpbmcgdHJlZVxcblxcblxcdFxcdHZhciBjb2RlcyA9IG5ldyBJbmZDb2RlcygpOyAvLyBpZiBDT0RFUywgY3VycmVudCBzdGF0ZVxcblxcblxcdFxcdHZhciBsYXN0ID0gMDsgLy8gdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIHRoZSBsYXN0IGJsb2NrXFxuXFxuXFx0XFx0dmFyIGh1ZnRzID0gbmV3IEludDMyQXJyYXkoTUFOWSAqIDMpOyAvLyBzaW5nbGUgbWFsbG9jIGZvciB0cmVlIHNwYWNlXFxuXFx0XFx0dmFyIGNoZWNrID0gMDsgLy8gY2hlY2sgb24gb3V0cHV0XFxuXFx0XFx0dmFyIGluZnRyZWUgPSBuZXcgSW5mVHJlZSgpO1xcblxcblxcdFxcdHRoYXQuYml0ayA9IDA7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcblxcdFxcdHRoYXQuYml0YiA9IDA7IC8vIGJpdCBidWZmZXJcXG5cXHRcXHR0aGF0LndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHcpOyAvLyBzbGlkaW5nIHdpbmRvd1xcblxcdFxcdHRoYXQuZW5kID0gdzsgLy8gb25lIGJ5dGUgYWZ0ZXIgc2xpZGluZyB3aW5kb3dcXG5cXHRcXHR0aGF0LnJlYWQgPSAwOyAvLyB3aW5kb3cgcmVhZCBwb2ludGVyXFxuXFx0XFx0dGhhdC53cml0ZSA9IDA7IC8vIHdpbmRvdyB3cml0ZSBwb2ludGVyXFxuXFxuXFx0XFx0dGhhdC5yZXNldCA9IGZ1bmN0aW9uKHosIGMpIHtcXG5cXHRcXHRcXHRpZiAoYylcXG5cXHRcXHRcXHRcXHRjWzBdID0gY2hlY2s7XFxuXFx0XFx0XFx0Ly8gaWYgKG1vZGUgPT0gQlRSRUUgfHwgbW9kZSA9PSBEVFJFRSkge1xcblxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRpZiAobW9kZSA9PSBDT0RFUykge1xcblxcdFxcdFxcdFxcdGNvZGVzLmZyZWUoeik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1vZGUgPSBUWVBFO1xcblxcdFxcdFxcdHRoYXQuYml0ayA9IDA7XFxuXFx0XFx0XFx0dGhhdC5iaXRiID0gMDtcXG5cXHRcXHRcXHR0aGF0LnJlYWQgPSB0aGF0LndyaXRlID0gMDtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQucmVzZXQoeiwgbnVsbCk7XFxuXFxuXFx0XFx0Ly8gY29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIHNsaWRpbmcgd2luZG93IHRvIHRoZSBvdXRwdXQgYXJlYVxcblxcdFxcdHRoYXQuaW5mbGF0ZV9mbHVzaCA9IGZ1bmN0aW9uKHosIHIpIHtcXG5cXHRcXHRcXHR2YXIgbjtcXG5cXHRcXHRcXHR2YXIgcDtcXG5cXHRcXHRcXHR2YXIgcTtcXG5cXG5cXHRcXHRcXHQvLyBsb2NhbCBjb3BpZXMgb2Ygc291cmNlIGFuZCBkZXN0aW5hdGlvbiBwb2ludGVyc1xcblxcdFxcdFxcdHAgPSB6Lm5leHRfb3V0X2luZGV4O1xcblxcdFxcdFxcdHEgPSB0aGF0LnJlYWQ7XFxuXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xcblxcdFxcdFxcdG4gPSAvKiAoaW50KSAqLygocSA8PSB0aGF0LndyaXRlID8gdGhhdC53cml0ZSA6IHRoYXQuZW5kKSAtIHEpO1xcblxcdFxcdFxcdGlmIChuID4gei5hdmFpbF9vdXQpXFxuXFx0XFx0XFx0XFx0biA9IHouYXZhaWxfb3V0O1xcblxcdFxcdFxcdGlmIChuICE9PSAwICYmIHIgPT0gWl9CVUZfRVJST1IpXFxuXFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIGNvdW50ZXJzXFxuXFx0XFx0XFx0ei5hdmFpbF9vdXQgLT0gbjtcXG5cXHRcXHRcXHR6LnRvdGFsX291dCArPSBuO1xcblxcblxcdFxcdFxcdC8vIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcXG5cXHRcXHRcXHR6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcblxcdFxcdFxcdHAgKz0gbjtcXG5cXHRcXHRcXHRxICs9IG47XFxuXFxuXFx0XFx0XFx0Ly8gc2VlIGlmIG1vcmUgdG8gY29weSBhdCBiZWdpbm5pbmcgb2Ygd2luZG93XFxuXFx0XFx0XFx0aWYgKHEgPT0gdGhhdC5lbmQpIHtcXG5cXHRcXHRcXHRcXHQvLyB3cmFwIHBvaW50ZXJzXFxuXFx0XFx0XFx0XFx0cSA9IDA7XFxuXFx0XFx0XFx0XFx0aWYgKHRoYXQud3JpdGUgPT0gdGhhdC5lbmQpXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY29tcHV0ZSBieXRlcyB0byBjb3B5XFxuXFx0XFx0XFx0XFx0biA9IHRoYXQud3JpdGUgLSBxO1xcblxcdFxcdFxcdFxcdGlmIChuID4gei5hdmFpbF9vdXQpXFxuXFx0XFx0XFx0XFx0XFx0biA9IHouYXZhaWxfb3V0O1xcblxcdFxcdFxcdFxcdGlmIChuICE9PSAwICYmIHIgPT0gWl9CVUZfRVJST1IpXFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXBkYXRlIGNvdW50ZXJzXFxuXFx0XFx0XFx0XFx0ei5hdmFpbF9vdXQgLT0gbjtcXG5cXHRcXHRcXHRcXHR6LnRvdGFsX291dCArPSBuO1xcblxcblxcdFxcdFxcdFxcdC8vIGNvcHlcXG5cXHRcXHRcXHRcXHR6Lm5leHRfb3V0LnNldCh0aGF0LndpbmRvdy5zdWJhcnJheShxLCBxICsgbiksIHApO1xcblxcdFxcdFxcdFxcdHAgKz0gbjtcXG5cXHRcXHRcXHRcXHRxICs9IG47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSBwb2ludGVyc1xcblxcdFxcdFxcdHoubmV4dF9vdXRfaW5kZXggPSBwO1xcblxcdFxcdFxcdHRoYXQucmVhZCA9IHE7XFxuXFxuXFx0XFx0XFx0Ly8gZG9uZVxcblxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5wcm9jID0gZnVuY3Rpb24oeiwgcikge1xcblxcdFxcdFxcdHZhciB0OyAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxcblxcdFxcdFxcdHZhciBiOyAvLyBiaXQgYnVmZmVyXFxuXFx0XFx0XFx0dmFyIGs7IC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxcblxcdFxcdFxcdHZhciBwOyAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcXG5cXHRcXHRcXHR2YXIgbjsgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXFxuXFx0XFx0XFx0dmFyIHE7IC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxcblxcdFxcdFxcdHZhciBtOyAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxcblxcblxcdFxcdFxcdHZhciBpO1xcblxcblxcdFxcdFxcdC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxcblxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdG4gPSB6LmF2YWlsX2luO1xcblxcdFxcdFxcdGIgPSB0aGF0LmJpdGI7XFxuXFx0XFx0XFx0ayA9IHRoYXQuYml0aztcXG5cXHRcXHRcXHQvLyB9XFxuXFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdHEgPSB0aGF0LndyaXRlO1xcblxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdC8vIH1cXG5cXG5cXHRcXHRcXHQvLyBwcm9jZXNzIGlucHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcXG5cXHRcXHRcXHQvLyBERUJVRyBkdHJlZVxcblxcdFxcdFxcdHdoaWxlICh0cnVlKSB7XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChtb2RlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBUWVBFOlxcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKDMpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0ID0gLyogKGludCkgKi8oYiAmIDcpO1xcblxcdFxcdFxcdFxcdFxcdGxhc3QgPSB0ICYgMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKHQgPj4+IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDA6IC8vIHN0b3JlZFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ID0gayAmIDc7IC8vIGdvIHRvIGJ5dGUgYm91bmRhcnlcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49ICh0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09ICh0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IExFTlM7IC8vIGdldCBsZW5ndGggb2Ygc3RvcmVkIGJsb2NrXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAxOiAvLyBmaXhlZFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYmwgPSBbXTsgLy8gbmV3IEFycmF5KDEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBiZCA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRsID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRkID0gWyBbXSBdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0SW5mVHJlZS5pbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGxbMF0sIDAsIHRkWzBdLCAwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAoMyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBDT0RFUztcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDI6IC8vIGR5bmFtaWNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49ICgzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRrIC09ICgzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IFRBQkxFO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzogLy8gaWxsZWdhbFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgYmxvY2sgdHlwZVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBMRU5TOlxcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChrIDwgKDMyKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCgoKH5iKSA+Pj4gMTYpICYgMHhmZmZmKSAhPSAoYiAmIDB4ZmZmZikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHNcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGxlZnQgPSAoYiAmIDB4ZmZmZik7XFxuXFx0XFx0XFx0XFx0XFx0YiA9IGsgPSAwOyAvLyBkdW1wIGJpdHNcXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gbGVmdCAhPT0gMCA/IFNUT1JFRCA6IChsYXN0ICE9PSAwID8gRFJZIDogVFlQRSk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBTVE9SRUQ6XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocSA9PSB0aGF0LmVuZCAmJiB0aGF0LnJlYWQgIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRxID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSB0aGF0LndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChxID09IHRoYXQuZW5kICYmIHRoYXQucmVhZCAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHEgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcblxcdFxcdFxcdFxcdFxcdHQgPSBsZWZ0O1xcblxcdFxcdFxcdFxcdFxcdGlmICh0ID4gbilcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodCA+IG0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0dCA9IG07XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53aW5kb3cuc2V0KHoucmVhZF9idWYocCwgdCksIHEpO1xcblxcdFxcdFxcdFxcdFxcdHAgKz0gdDtcXG5cXHRcXHRcXHRcXHRcXHRuIC09IHQ7XFxuXFx0XFx0XFx0XFx0XFx0cSArPSB0O1xcblxcdFxcdFxcdFxcdFxcdG0gLT0gdDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKGxlZnQgLT0gdCkgIT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IGxhc3QgIT09IDAgPyBEUlkgOiBUWVBFO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgVEFCTEU6XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGsgPCAoMTQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG4gIT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9PSztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YiB8PSAoei5yZWFkX2J5dGUocCsrKSAmIDB4ZmYpIDw8IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ayArPSA4O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0YWJsZSA9IHQgPSAoYiAmIDB4M2ZmZik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCh0ICYgMHgxZikgPiAyOSB8fCAoKHQgPj4gNSkgJiAweDFmKSA+IDI5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IEJBREJMT0NLUztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1xcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfREFUQV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dCA9IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWJsZW5zIHx8IGJsZW5zLmxlbmd0aCA8IHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRibGVucyA9IFtdOyAvLyBuZXcgQXJyYXkodCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgdDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmxlbnNbaV0gPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdFxcdFxcdGIgPj4+PSAoMTQpO1xcblxcdFxcdFxcdFxcdFxcdGsgLT0gKDE0KTtcXG5cXHRcXHRcXHRcXHRcXHQvLyB9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBCVFJFRTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBCVFJFRTpcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoaW5kZXggPCA0ICsgKHRhYmxlID4+PiAxMCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8ICgzKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmxlbnNbYm9yZGVyW2luZGV4KytdXSA9IGIgJiA3O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKDMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGluZGV4IDwgMTkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRibGVuc1tib3JkZXJbaW5kZXgrK11dID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmJbMF0gPSA3O1xcblxcdFxcdFxcdFxcdFxcdHQgPSBpbmZ0cmVlLmluZmxhdGVfdHJlZXNfYml0cyhibGVucywgYmIsIHRiLCBodWZ0cywgeik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHQgIT0gWl9PSykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHIgPSB0O1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChyID09IFpfREFUQV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBEVFJFRTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBEVFJFRTpcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAodHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSB0YWJsZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5kZXggPj0gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBqLCBjO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBiYlswXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8ICh0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChuICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bi0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgfD0gKHoucmVhZF9ieXRlKHArKykgJiAweGZmKSA8PCBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgKz0gODtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaWYgKHRiWzBdID09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3lzdGVtLmVyci5wcmludGxuKFxcXCJudWxsLi4uXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHQgPSBodWZ0c1sodGJbMF0gKyAoYiAmIGluZmxhdGVfbWFza1t0XSkpICogMyArIDFdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSBodWZ0c1sodGJbMF0gKyAoYiAmIGluZmxhdGVfbWFza1t0XSkpICogMyArIDJdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjIDwgMTYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID4+Pj0gKHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGsgLT0gKHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zW2luZGV4KytdID0gYztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgeyAvLyBjID09IDE2Li4xOFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBjID09IDE4ID8gNyA6IGMgLSAxNDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqID0gYyA9PSAxOCA/IDExIDogMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoayA8ICh0ICsgaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobiAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHIgPSBaX09LO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG4tLTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiIHw9ICh6LnJlYWRfYnl0ZShwKyspICYgMHhmZikgPDwgaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRrICs9IDg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgPj4+PSAodCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ayAtPSAodCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aiArPSAoYiAmIGluZmxhdGVfbWFza1tpXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA+Pj49IChpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrIC09IChpKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dCA9IHRhYmxlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChpICsgaiA+IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKSB8fCAoYyA9PSAxNiAmJiBpIDwgMSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRibGVucyA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bW9kZSA9IEJBREJMT0NLUztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyID0gWl9EQVRBX0VSUk9SO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gYyA9PSAxNiA/IGJsZW5zW2kgLSAxXSA6IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zW2krK10gPSBjO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKC0taiAhPT0gMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5kZXggPSBpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGJbMF0gPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHQvLyB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJsXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJkXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRsXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRkXyA9IFtdOyAvLyBuZXcgQXJyYXkoMSk7XFxuXFx0XFx0XFx0XFx0XFx0YmxfWzBdID0gOTsgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRiZF9bMF0gPSA2OyAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xcblxcblxcdFxcdFxcdFxcdFxcdHQgPSB0YWJsZTtcXG5cXHRcXHRcXHRcXHRcXHR0ID0gaW5mdHJlZS5pbmZsYXRlX3RyZWVzX2R5bmFtaWMoMjU3ICsgKHQgJiAweDFmKSwgMSArICgodCA+PiA1KSAmIDB4MWYpLCBibGVucywgYmxfLCBiZF8sIHRsXywgdGRfLCBodWZ0cywgeik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHQgIT0gWl9PSykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0ID09IFpfREFUQV9FUlJPUikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJsZW5zID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtb2RlID0gQkFEQkxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Y29kZXMuaW5pdChibF9bMF0sIGJkX1swXSwgaHVmdHMsIHRsX1swXSwgaHVmdHMsIHRkX1swXSk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gfVxcblxcdFxcdFxcdFxcdFxcdG1vZGUgPSBDT0RFUztcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBDT0RFUzpcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGIgPSBiO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuYml0ayA9IGs7XFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbiA9IG47XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbiArPSBwIC0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IHA7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC53cml0ZSA9IHE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChyID0gY29kZXMucHJvYyh0aGF0LCB6LCByKSkgIT0gWl9TVFJFQU1fRU5EKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuaW5mbGF0ZV9mbHVzaCh6LCByKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ciA9IFpfT0s7XFxuXFx0XFx0XFx0XFx0XFx0Y29kZXMuZnJlZSh6KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdFxcdFxcdG4gPSB6LmF2YWlsX2luO1xcblxcdFxcdFxcdFxcdFxcdGIgPSB0aGF0LmJpdGI7XFxuXFx0XFx0XFx0XFx0XFx0ayA9IHRoYXQuYml0aztcXG5cXHRcXHRcXHRcXHRcXHRxID0gdGhhdC53cml0ZTtcXG5cXHRcXHRcXHRcXHRcXHRtID0gLyogKGludCkgKi8ocSA8IHRoYXQucmVhZCA/IHRoYXQucmVhZCAtIHEgLSAxIDogdGhhdC5lbmQgLSBxKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobGFzdCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGUgPSBUWVBFO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRFJZO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERSWTpcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyID0gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdHEgPSB0aGF0LndyaXRlO1xcblxcdFxcdFxcdFxcdFxcdG0gPSAvKiAoaW50KSAqLyhxIDwgdGhhdC5yZWFkID8gdGhhdC5yZWFkIC0gcSAtIDEgOiB0aGF0LmVuZCAtIHEpO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGF0LnJlYWQgIT0gdGhhdC53cml0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtb2RlID0gRE9ORUxPQ0tTO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERPTkVMT0NLUzpcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9TVFJFQU1fRU5EO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoYXQuYml0YiA9IGI7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRrID0gaztcXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LndyaXRlID0gcTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5pbmZsYXRlX2ZsdXNoKHosIHIpO1xcblxcdFxcdFxcdFxcdGNhc2UgQkFEQkxPQ0tTOlxcblxcdFxcdFxcdFxcdFxcdHIgPSBaX0RBVEFfRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRyID0gWl9TVFJFQU1fRVJST1I7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5iaXRiID0gYjtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmJpdGsgPSBrO1xcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4gPSBuO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4gKz0gcCAtIHoubmV4dF9pbl9pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR6Lm5leHRfaW5faW5kZXggPSBwO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQud3JpdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LmluZmxhdGVfZmx1c2goeiwgcik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuZnJlZSA9IGZ1bmN0aW9uKHopIHtcXG5cXHRcXHRcXHR0aGF0LnJlc2V0KHosIG51bGwpO1xcblxcdFxcdFxcdHRoYXQud2luZG93ID0gbnVsbDtcXG5cXHRcXHRcXHRodWZ0cyA9IG51bGw7XFxuXFx0XFx0XFx0Ly8gWkZSRUUoeiwgcyk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LnNldF9kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZCwgc3RhcnQsIG4pIHtcXG5cXHRcXHRcXHR0aGF0LndpbmRvdy5zZXQoZC5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBuKSwgMCk7XFxuXFx0XFx0XFx0dGhhdC5yZWFkID0gdGhhdC53cml0ZSA9IG47XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxcblxcdFxcdC8vIGJ5IFpfU1lOQ19GTFVTSCBvciBaX0ZVTExfRkxVU0guXFxuXFx0XFx0dGhhdC5zeW5jX3BvaW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG1vZGUgPT0gTEVOUyA/IDEgOiAwO1xcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8vIEluZmxhdGVcXG5cXG5cXHQvLyBwcmVzZXQgZGljdGlvbmFyeSBmbGFnIGluIHpsaWIgaGVhZGVyXFxuXFx0dmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcXG5cXG5cXHR2YXIgWl9ERUZMQVRFRCA9IDg7XFxuXFxuXFx0dmFyIE1FVEhPRCA9IDA7IC8vIHdhaXRpbmcgZm9yIG1ldGhvZCBieXRlXFxuXFx0dmFyIEZMQUcgPSAxOyAvLyB3YWl0aW5nIGZvciBmbGFnIGJ5dGVcXG5cXHR2YXIgRElDVDQgPSAyOyAvLyBmb3VyIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cXG5cXHR2YXIgRElDVDMgPSAzOyAvLyB0aHJlZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXFxuXFx0dmFyIERJQ1QyID0gNDsgLy8gdHdvIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cXG5cXHR2YXIgRElDVDEgPSA1OyAvLyBvbmUgZGljdGlvbmFyeSBjaGVjayBieXRlIHRvIGdvXFxuXFx0dmFyIERJQ1QwID0gNjsgLy8gd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnlcXG5cXHR2YXIgQkxPQ0tTID0gNzsgLy8gZGVjb21wcmVzc2luZyBibG9ja3NcXG5cXHR2YXIgRE9ORSA9IDEyOyAvLyBmaW5pc2hlZCBjaGVjaywgZG9uZVxcblxcdHZhciBCQUQgPSAxMzsgLy8gZ290IGFuIGVycm9yLS1zdGF5IGhlcmVcXG5cXG5cXHR2YXIgbWFyayA9IFsgMCwgMCwgMHhmZiwgMHhmZiBdO1xcblxcblxcdGZ1bmN0aW9uIEluZmxhdGUoKSB7XFxuXFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdHRoYXQubW9kZSA9IDA7IC8vIGN1cnJlbnQgaW5mbGF0ZSBtb2RlXFxuXFxuXFx0XFx0Ly8gbW9kZSBkZXBlbmRlbnQgaW5mb3JtYXRpb25cXG5cXHRcXHR0aGF0Lm1ldGhvZCA9IDA7IC8vIGlmIEZMQUdTLCBtZXRob2QgYnl0ZVxcblxcblxcdFxcdC8vIGlmIENIRUNLLCBjaGVjayB2YWx1ZXMgdG8gY29tcGFyZVxcblxcdFxcdHRoYXQud2FzID0gWyAwIF07IC8vIG5ldyBBcnJheSgxKTsgLy8gY29tcHV0ZWQgY2hlY2sgdmFsdWVcXG5cXHRcXHR0aGF0Lm5lZWQgPSAwOyAvLyBzdHJlYW0gY2hlY2sgdmFsdWVcXG5cXG5cXHRcXHQvLyBpZiBCQUQsIGluZmxhdGVTeW5jJ3MgbWFya2VyIGJ5dGVzIGNvdW50XFxuXFx0XFx0dGhhdC5tYXJrZXIgPSAwO1xcblxcblxcdFxcdC8vIG1vZGUgaW5kZXBlbmRlbnQgaW5mb3JtYXRpb25cXG5cXHRcXHR0aGF0LndiaXRzID0gMDsgLy8gbG9nMih3aW5kb3cgc2l6ZSkgKDguLjE1LCBkZWZhdWx0cyB0byAxNSlcXG5cXG5cXHRcXHQvLyB0aGlzLmJsb2NrczsgLy8gY3VycmVudCBpbmZsYXRlX2Jsb2NrcyBzdGF0ZVxcblxcblxcdFxcdGZ1bmN0aW9uIGluZmxhdGVSZXNldCh6KSB7XFxuXFx0XFx0XFx0aWYgKCF6IHx8ICF6LmlzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFxuXFx0XFx0XFx0ei50b3RhbF9pbiA9IHoudG90YWxfb3V0ID0gMDtcXG5cXHRcXHRcXHR6Lm1zZyA9IG51bGw7XFxuXFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHR6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgbnVsbCk7XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoYXQuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKHopIHtcXG5cXHRcXHRcXHRpZiAodGhhdC5ibG9ja3MpXFxuXFx0XFx0XFx0XFx0dGhhdC5ibG9ja3MuZnJlZSh6KTtcXG5cXHRcXHRcXHR0aGF0LmJsb2NrcyA9IG51bGw7XFxuXFx0XFx0XFx0Ly8gWkZSRUUoeiwgei0+c3RhdGUpO1xcblxcdFxcdFxcdHJldHVybiBaX09LO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhhdC5pbmZsYXRlSW5pdCA9IGZ1bmN0aW9uKHosIHcpIHtcXG5cXHRcXHRcXHR6Lm1zZyA9IG51bGw7XFxuXFx0XFx0XFx0dGhhdC5ibG9ja3MgPSBudWxsO1xcblxcblxcdFxcdFxcdC8vIHNldCB3aW5kb3cgc2l6ZVxcblxcdFxcdFxcdGlmICh3IDwgOCB8fCB3ID4gMTUpIHtcXG5cXHRcXHRcXHRcXHR0aGF0LmluZmxhdGVFbmQoeik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGF0LndiaXRzID0gdztcXG5cXG5cXHRcXHRcXHR6LmlzdGF0ZS5ibG9ja3MgPSBuZXcgSW5mQmxvY2tzKHosIDEgPDwgdyk7XFxuXFxuXFx0XFx0XFx0Ly8gcmVzZXQgc3RhdGVcXG5cXHRcXHRcXHRpbmZsYXRlUmVzZXQoeik7XFxuXFx0XFx0XFx0cmV0dXJuIFpfT0s7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmluZmxhdGUgPSBmdW5jdGlvbih6LCBmKSB7XFxuXFx0XFx0XFx0dmFyIHI7XFxuXFx0XFx0XFx0dmFyIGI7XFxuXFxuXFx0XFx0XFx0aWYgKCF6IHx8ICF6LmlzdGF0ZSB8fCAhei5uZXh0X2luKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRmID0gZiA9PSBaX0ZJTklTSCA/IFpfQlVGX0VSUk9SIDogWl9PSztcXG5cXHRcXHRcXHRyID0gWl9CVUZfRVJST1I7XFxuXFx0XFx0XFx0d2hpbGUgKHRydWUpIHtcXG5cXHRcXHRcXHRcXHQvLyBTeXN0ZW0ub3V0LnByaW50bG4oXFxcIm1vZGU6IFxcXCIrei5pc3RhdGUubW9kZSk7XFxuXFx0XFx0XFx0XFx0c3dpdGNoICh6LmlzdGF0ZS5tb2RlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBNRVRIT0Q6XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHouYXZhaWxfaW4gPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IGY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbi0tO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4rKztcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKCh6LmlzdGF0ZS5tZXRob2QgPSB6LnJlYWRfYnl0ZSh6Lm5leHRfaW5faW5kZXgrKykpICYgMHhmKSAhPSBaX0RFRkxBVEVEKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubWFya2VyID0gNTsgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgoei5pc3RhdGUubWV0aG9kID4+IDQpICsgOCA+IHouaXN0YXRlLndiaXRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbnZhbGlkIHdpbmRvdyBzaXplXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSA1OyAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEZMQUc7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRkxBRzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luLS07XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbisrO1xcblxcdFxcdFxcdFxcdFxcdGIgPSAoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspKSAmIDB4ZmY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCgoKHouaXN0YXRlLm1ldGhvZCA8PCA4KSArIGIpICUgMzEpICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6Lm1zZyA9IFxcXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSA1OyAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChiICYgUFJFU0VUX0RJQ1QpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IERJQ1Q0O1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERJQ1Q0OlxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh6LmF2YWlsX2luID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4tLTtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luKys7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubmVlZCA9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMjQpICYgMHhmZjAwMDAwMDtcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gRElDVDM7XFxuXFx0XFx0XFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdFxcdGNhc2UgRElDVDM6XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHouYXZhaWxfaW4gPT09IDApXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0ciA9IGY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ei5hdmFpbF9pbi0tO1xcblxcdFxcdFxcdFxcdFxcdHoudG90YWxfaW4rKztcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5uZWVkICs9ICgoei5yZWFkX2J5dGUoei5uZXh0X2luX2luZGV4KyspICYgMHhmZikgPDwgMTYpICYgMHhmZjAwMDA7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IERJQ1QyO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERJQ1QyOlxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh6LmF2YWlsX2luID09PSAwKVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByO1xcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcblxcdFxcdFxcdFxcdFxcdHouYXZhaWxfaW4tLTtcXG5cXHRcXHRcXHRcXHRcXHR6LnRvdGFsX2luKys7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubmVlZCArPSAoKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpIDw8IDgpICYgMHhmZjAwO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBESUNUMTtcXG5cXHRcXHRcXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0XFx0Y2FzZSBESUNUMTpcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiA9PT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcjtcXG5cXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR6LmF2YWlsX2luLS07XFxuXFx0XFx0XFx0XFx0XFx0ei50b3RhbF9pbisrO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm5lZWQgKz0gKHoucmVhZF9ieXRlKHoubmV4dF9pbl9pbmRleCsrKSAmIDB4ZmYpO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBESUNUMDtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9ORUVEX0RJQ1Q7XFxuXFx0XFx0XFx0XFx0Y2FzZSBESUNUMDpcXG5cXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdFxcdHoubXNnID0gXFxcIm5lZWQgZGljdGlvbmFyeVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubWFya2VyID0gMDsgLy8gY2FuIHRyeSBpbmZsYXRlU3luY1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRcXHRjYXNlIEJMT0NLUzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyID0gei5pc3RhdGUuYmxvY2tzLnByb2Moeiwgcik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHIgPT0gWl9EQVRBX0VSUk9SKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJBRDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSAwOyAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChyID09IFpfT0spIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyID0gZjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHIgIT0gWl9TVFJFQU1fRU5EKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHIgPSBmO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLmJsb2Nrcy5yZXNldCh6LCB6LmlzdGF0ZS53YXMpO1xcblxcdFxcdFxcdFxcdFxcdHouaXN0YXRlLm1vZGUgPSBET05FO1xcblxcdFxcdFxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRcXHRjYXNlIERPTkU6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VORDtcXG5cXHRcXHRcXHRcXHRjYXNlIEJBRDpcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gWl9EQVRBX0VSUk9SO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGF0LmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oeiwgZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xcblxcdFxcdFxcdHZhciBpbmRleCA9IDA7XFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IGRpY3RMZW5ndGg7XFxuXFx0XFx0XFx0aWYgKCF6IHx8ICF6LmlzdGF0ZSB8fCB6LmlzdGF0ZS5tb2RlICE9IERJQ1QwKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXG5cXHRcXHRcXHRpZiAobGVuZ3RoID49ICgxIDw8IHouaXN0YXRlLndiaXRzKSkge1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9ICgxIDw8IHouaXN0YXRlLndiaXRzKSAtIDE7XFxuXFx0XFx0XFx0XFx0aW5kZXggPSBkaWN0TGVuZ3RoIC0gbGVuZ3RoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR6LmlzdGF0ZS5ibG9ja3Muc2V0X2RpY3Rpb25hcnkoZGljdGlvbmFyeSwgaW5kZXgsIGxlbmd0aCk7XFxuXFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoYXQuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbih6KSB7XFxuXFx0XFx0XFx0dmFyIG47IC8vIG51bWJlciBvZiBieXRlcyB0byBsb29rIGF0XFxuXFx0XFx0XFx0dmFyIHA7IC8vIHBvaW50ZXIgdG8gYnl0ZXNcXG5cXHRcXHRcXHR2YXIgbTsgLy8gbnVtYmVyIG9mIG1hcmtlciBieXRlcyBmb3VuZCBpbiBhIHJvd1xcblxcdFxcdFxcdHZhciByLCB3OyAvLyB0ZW1wb3JhcmllcyB0byBzYXZlIHRvdGFsX2luIGFuZCB0b3RhbF9vdXRcXG5cXG5cXHRcXHRcXHQvLyBzZXQgdXBcXG5cXHRcXHRcXHRpZiAoIXogfHwgIXouaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRpZiAoei5pc3RhdGUubW9kZSAhPSBCQUQpIHtcXG5cXHRcXHRcXHRcXHR6LmlzdGF0ZS5tb2RlID0gQkFEO1xcblxcdFxcdFxcdFxcdHouaXN0YXRlLm1hcmtlciA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgobiA9IHouYXZhaWxfaW4pID09PSAwKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX0JVRl9FUlJPUjtcXG5cXHRcXHRcXHRwID0gei5uZXh0X2luX2luZGV4O1xcblxcdFxcdFxcdG0gPSB6LmlzdGF0ZS5tYXJrZXI7XFxuXFxuXFx0XFx0XFx0Ly8gc2VhcmNoXFxuXFx0XFx0XFx0d2hpbGUgKG4gIT09IDAgJiYgbSA8IDQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoei5yZWFkX2J5dGUocCkgPT0gbWFya1ttXSkge1xcblxcdFxcdFxcdFxcdFxcdG0rKztcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHoucmVhZF9ieXRlKHApICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0bSA9IDA7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRtID0gNCAtIG07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHArKztcXG5cXHRcXHRcXHRcXHRuLS07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHJlc3RvcmVcXG5cXHRcXHRcXHR6LnRvdGFsX2luICs9IHAgLSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0ei5uZXh0X2luX2luZGV4ID0gcDtcXG5cXHRcXHRcXHR6LmF2YWlsX2luID0gbjtcXG5cXHRcXHRcXHR6LmlzdGF0ZS5tYXJrZXIgPSBtO1xcblxcblxcdFxcdFxcdC8vIHJldHVybiBubyBqb3kgb3Igc2V0IHVwIHRvIHJlc3RhcnQgb24gYSBuZXcgYmxvY2tcXG5cXHRcXHRcXHRpZiAobSAhPSA0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFpfREFUQV9FUlJPUjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ciA9IHoudG90YWxfaW47XFxuXFx0XFx0XFx0dyA9IHoudG90YWxfb3V0O1xcblxcdFxcdFxcdGluZmxhdGVSZXNldCh6KTtcXG5cXHRcXHRcXHR6LnRvdGFsX2luID0gcjtcXG5cXHRcXHRcXHR6LnRvdGFsX291dCA9IHc7XFxuXFx0XFx0XFx0ei5pc3RhdGUubW9kZSA9IEJMT0NLUztcXG5cXHRcXHRcXHRyZXR1cm4gWl9PSztcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFJldHVybnMgdHJ1ZSBpZiBpbmZsYXRlIGlzIGN1cnJlbnRseSBhdCB0aGUgZW5kIG9mIGEgYmxvY2sgZ2VuZXJhdGVkXFxuXFx0XFx0Ly8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG9uZSBQUFBcXG5cXHRcXHQvLyBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLiBQUFAgdXNlc1xcblxcdFxcdC8vIFpfU1lOQ19GTFVTSFxcblxcdFxcdC8vIGJ1dCByZW1vdmVzIHRoZSBsZW5ndGggYnl0ZXMgb2YgdGhlIHJlc3VsdGluZyBlbXB0eSBzdG9yZWQgYmxvY2suIFdoZW5cXG5cXHRcXHQvLyBkZWNvbXByZXNzaW5nLCBQUFAgY2hlY2tzIHRoYXQgYXQgdGhlIGVuZCBvZiBpbnB1dCBwYWNrZXQsIGluZmxhdGUgaXNcXG5cXHRcXHQvLyB3YWl0aW5nIGZvciB0aGVzZSBsZW5ndGggYnl0ZXMuXFxuXFx0XFx0dGhhdC5pbmZsYXRlU3luY1BvaW50ID0gZnVuY3Rpb24oeikge1xcblxcdFxcdFxcdGlmICgheiB8fCAhei5pc3RhdGUgfHwgIXouaXN0YXRlLmJsb2NrcylcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0cmV0dXJuIHouaXN0YXRlLmJsb2Nrcy5zeW5jX3BvaW50KCk7XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gWlN0cmVhbVxcblxcblxcdGZ1bmN0aW9uIFpTdHJlYW0oKSB7XFxuXFx0fVxcblxcblxcdFpTdHJlYW0ucHJvdG90eXBlID0ge1xcblxcdFxcdGluZmxhdGVJbml0IDogZnVuY3Rpb24oYml0cykge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHR0aGF0LmlzdGF0ZSA9IG5ldyBJbmZsYXRlKCk7XFxuXFx0XFx0XFx0aWYgKCFiaXRzKVxcblxcdFxcdFxcdFxcdGJpdHMgPSBNQVhfQklUUztcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZUluaXQodGhhdCwgYml0cyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbmZsYXRlIDogZnVuY3Rpb24oZikge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZSh0aGF0LCBmKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGluZmxhdGVFbmQgOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmlzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0dmFyIHJldCA9IHRoYXQuaXN0YXRlLmluZmxhdGVFbmQodGhhdCk7XFxuXFx0XFx0XFx0dGhhdC5pc3RhdGUgPSBudWxsO1xcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbmZsYXRlU3luYyA6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHRcXHRpZiAoIXRoYXQuaXN0YXRlKVxcblxcdFxcdFxcdFxcdHJldHVybiBaX1NUUkVBTV9FUlJPUjtcXG5cXHRcXHRcXHRyZXR1cm4gdGhhdC5pc3RhdGUuaW5mbGF0ZVN5bmModGhhdCk7XFxuXFx0XFx0fSxcXG5cXHRcXHRpbmZsYXRlU2V0RGljdGlvbmFyeSA6IGZ1bmN0aW9uKGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0aWYgKCF0aGF0LmlzdGF0ZSlcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWl9TVFJFQU1fRVJST1I7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQuaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoYXQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xcblxcdFxcdH0sXFxuXFx0XFx0cmVhZF9ieXRlIDogZnVuY3Rpb24oc3RhcnQpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQubmV4dF9pbi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyAxKVswXTtcXG5cXHRcXHR9LFxcblxcdFxcdHJlYWRfYnVmIDogZnVuY3Rpb24oc3RhcnQsIHNpemUpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0cmV0dXJuIHRoYXQubmV4dF9pbi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBzaXplKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvLyBJbmZsYXRlclxcblxcblxcdGZ1bmN0aW9uIEluZmxhdGVyKCkge1xcblxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXHRcXHR2YXIgeiA9IG5ldyBaU3RyZWFtKCk7XFxuXFx0XFx0dmFyIGJ1ZnNpemUgPSA1MTI7XFxuXFx0XFx0dmFyIGZsdXNoID0gWl9OT19GTFVTSDtcXG5cXHRcXHR2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmc2l6ZSk7XFxuXFx0XFx0dmFyIG5vbW9yZWlucHV0ID0gZmFsc2U7XFxuXFxuXFx0XFx0ei5pbmZsYXRlSW5pdCgpO1xcblxcdFxcdHoubmV4dF9vdXQgPSBidWY7XFxuXFxuXFx0XFx0dGhhdC5hcHBlbmQgPSBmdW5jdGlvbihkYXRhLCBvbnByb2dyZXNzKSB7XFxuXFx0XFx0XFx0dmFyIGVyciwgYnVmZmVycyA9IFtdLCBsYXN0SW5kZXggPSAwLCBidWZmZXJJbmRleCA9IDAsIGJ1ZmZlclNpemUgPSAwLCBhcnJheTtcXG5cXHRcXHRcXHRpZiAoZGF0YS5sZW5ndGggPT09IDApXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IDA7XFxuXFx0XFx0XFx0ei5uZXh0X2luID0gZGF0YTtcXG5cXHRcXHRcXHR6LmF2YWlsX2luID0gZGF0YS5sZW5ndGg7XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdHoubmV4dF9vdXRfaW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdHouYXZhaWxfb3V0ID0gYnVmc2l6ZTtcXG5cXHRcXHRcXHRcXHRpZiAoKHouYXZhaWxfaW4gPT09IDApICYmICghbm9tb3JlaW5wdXQpKSB7IC8vIGlmIGJ1ZmZlciBpcyBlbXB0eSBhbmQgbW9yZSBpbnB1dCBpcyBhdmFpbGFibGUsIHJlZmlsbCBpdFxcblxcdFxcdFxcdFxcdFxcdHoubmV4dF9pbl9pbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0bm9tb3JlaW5wdXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRlcnIgPSB6LmluZmxhdGUoZmx1c2gpO1xcblxcdFxcdFxcdFxcdGlmIChub21vcmVpbnB1dCAmJiAoZXJyID09PSBaX0JVRl9FUlJPUikpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoei5hdmFpbF9pbiAhPT0gMClcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcImluZmxhdGluZzogYmFkIGlucHV0XFxcIik7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChlcnIgIT09IFpfT0sgJiYgZXJyICE9PSBaX1NUUkVBTV9FTkQpXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJpbmZsYXRpbmc6IFxcXCIgKyB6Lm1zZyk7XFxuXFx0XFx0XFx0XFx0aWYgKChub21vcmVpbnB1dCB8fCBlcnIgPT09IFpfU1RSRUFNX0VORCkgJiYgKHouYXZhaWxfaW4gPT09IGRhdGEubGVuZ3RoKSlcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcImluZmxhdGluZzogYmFkIGlucHV0XFxcIik7XFxuXFx0XFx0XFx0XFx0aWYgKHoubmV4dF9vdXRfaW5kZXgpXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHoubmV4dF9vdXRfaW5kZXggPT09IGJ1ZnNpemUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpO1xcblxcdFxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYnVmLnN1YmFycmF5KDAsIHoubmV4dF9vdXRfaW5kZXgpKSk7XFxuXFx0XFx0XFx0XFx0YnVmZmVyU2l6ZSArPSB6Lm5leHRfb3V0X2luZGV4O1xcblxcdFxcdFxcdFxcdGlmIChvbnByb2dyZXNzICYmIHoubmV4dF9pbl9pbmRleCA+IDAgJiYgei5uZXh0X2luX2luZGV4ICE9IGxhc3RJbmRleCkge1xcblxcdFxcdFxcdFxcdFxcdG9ucHJvZ3Jlc3Moei5uZXh0X2luX2luZGV4KTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0SW5kZXggPSB6Lm5leHRfaW5faW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gd2hpbGUgKHouYXZhaWxfaW4gPiAwIHx8IHouYXZhaWxfb3V0ID09PSAwKTtcXG5cXHRcXHRcXHRhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclNpemUpO1xcblxcdFxcdFxcdGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xcblxcdFxcdFxcdFxcdGFycmF5LnNldChjaHVuaywgYnVmZmVySW5kZXgpO1xcblxcdFxcdFxcdFxcdGJ1ZmZlckluZGV4ICs9IGNodW5rLmxlbmd0aDtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGF0LmZsdXNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0ei5pbmZsYXRlRW5kKCk7XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gJ3ppcCcgbWF5IG5vdCBiZSBkZWZpbmVkIGluIHotd29ya2VyIGFuZCBzb21lIHRlc3RzXFxuXFx0dmFyIGVudiA9IGdsb2JhbC56aXAgfHwgZ2xvYmFsO1xcblxcdGVudi5JbmZsYXRlciA9IGVudi5fanpsaWJfSW5mbGF0ZXIgPSBJbmZsYXRlcjtcXG59KSh0aGlzKTtcXG5cIildXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHppcDtcblxuIiwiOyB2YXIgX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fPXJlcXVpcmU7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLypcbiBDb3B5cmlnaHQgKGMpIDIwMTMgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW5cbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuIDMuIFRoZSBuYW1lcyBvZiB0aGUgYXV0aG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NFRCBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXG4gSU5DLiBPUiBBTlkgQ09OVFJJQlVUT1JTIFRPIFRISVMgU09GVFdBUkUgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXG4gT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxuIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuKGZ1bmN0aW9uKG9iaikge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgRVJSX0JBRF9GT1JNQVQgPSBcIkZpbGUgZm9ybWF0IGlzIG5vdCByZWNvZ25pemVkLlwiO1xuXHR2YXIgRVJSX0NSQyA9IFwiQ1JDIGZhaWxlZC5cIjtcblx0dmFyIEVSUl9FTkNSWVBURUQgPSBcIkZpbGUgY29udGFpbnMgZW5jcnlwdGVkIGVudHJ5LlwiO1xuXHR2YXIgRVJSX1pJUDY0ID0gXCJGaWxlIGlzIHVzaW5nIFppcDY0ICg0Z2IrIGZpbGUgc2l6ZSkuXCI7XG5cdHZhciBFUlJfUkVBRCA9IFwiRXJyb3Igd2hpbGUgcmVhZGluZyB6aXAgZmlsZS5cIjtcblx0dmFyIEVSUl9XUklURSA9IFwiRXJyb3Igd2hpbGUgd3JpdGluZyB6aXAgZmlsZS5cIjtcblx0dmFyIEVSUl9XUklURV9EQVRBID0gXCJFcnJvciB3aGlsZSB3cml0aW5nIGZpbGUgZGF0YS5cIjtcblx0dmFyIEVSUl9SRUFEX0RBVEEgPSBcIkVycm9yIHdoaWxlIHJlYWRpbmcgZmlsZSBkYXRhLlwiO1xuXHR2YXIgRVJSX0RVUExJQ0FURURfTkFNRSA9IFwiRmlsZSBhbHJlYWR5IGV4aXN0cy5cIjtcblx0dmFyIENIVU5LX1NJWkUgPSA1MTIgKiAxMDI0O1xuXHRcblx0dmFyIFRFWFRfUExBSU4gPSBcInRleHQvcGxhaW5cIjtcblxuXHR2YXIgYXBwZW5kQUJWaWV3U3VwcG9ydGVkO1xuXHR0cnkge1xuXHRcdGFwcGVuZEFCVmlld1N1cHBvcnRlZCA9IG5ldyBCbG9iKFsgbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSkgXSkuc2l6ZSA9PT0gMDtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG5cblx0ZnVuY3Rpb24gQ3JjMzIoKSB7XG5cdFx0dGhpcy5jcmMgPSAtMTtcblx0fVxuXHRDcmMzMi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGRhdGEpIHtcblx0XHR2YXIgY3JjID0gdGhpcy5jcmMgfCAwLCB0YWJsZSA9IHRoaXMudGFibGU7XG5cdFx0Zm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gZGF0YS5sZW5ndGggfCAwOyBvZmZzZXQgPCBsZW47IG9mZnNldCsrKVxuXHRcdFx0Y3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtvZmZzZXRdKSAmIDB4RkZdO1xuXHRcdHRoaXMuY3JjID0gY3JjO1xuXHR9O1xuXHRDcmMzMi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuXHRcdHJldHVybiB+dGhpcy5jcmM7XG5cdH07XG5cdENyYzMyLnByb3RvdHlwZS50YWJsZSA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgaiwgdCwgdGFibGUgPSBbXTsgLy8gVWludDMyQXJyYXkgaXMgYWN0dWFsbHkgc2xvd2VyIHRoYW4gW11cblx0XHRmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0XHRcdHQgPSBpO1xuXHRcdFx0Zm9yIChqID0gMDsgaiA8IDg7IGorKylcblx0XHRcdFx0aWYgKHQgJiAxKVxuXHRcdFx0XHRcdHQgPSAodCA+Pj4gMSkgXiAweEVEQjg4MzIwO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dCA9IHQgPj4+IDE7XG5cdFx0XHR0YWJsZVtpXSA9IHQ7XG5cdFx0fVxuXHRcdHJldHVybiB0YWJsZTtcblx0fSkoKTtcblx0XG5cdC8vIFwibm8tb3BcIiBjb2RlY1xuXHRmdW5jdGlvbiBOT09QKCkge31cblx0Tk9PUC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGJ5dGVzLCBvbnByb2dyZXNzKSB7XG5cdFx0cmV0dXJuIGJ5dGVzO1xuXHR9O1xuXHROT09QLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge307XG5cblx0ZnVuY3Rpb24gYmxvYlNsaWNlKGJsb2IsIGluZGV4LCBsZW5ndGgpIHtcblx0XHRpZiAoaW5kZXggPCAwIHx8IGxlbmd0aCA8IDAgfHwgaW5kZXggKyBsZW5ndGggPiBibG9iLnNpemUpXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0OicgKyBpbmRleCArICcsIGxlbmd0aDonICsgbGVuZ3RoICsgJywgc2l6ZTonICsgYmxvYi5zaXplKTtcblx0XHRpZiAoYmxvYi5zbGljZSlcblx0XHRcdHJldHVybiBibG9iLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG5cdFx0ZWxzZSBpZiAoYmxvYi53ZWJraXRTbGljZSlcblx0XHRcdHJldHVybiBibG9iLndlYmtpdFNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG5cdFx0ZWxzZSBpZiAoYmxvYi5tb3pTbGljZSlcblx0XHRcdHJldHVybiBibG9iLm1velNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG5cdFx0ZWxzZSBpZiAoYmxvYi5tc1NsaWNlKVxuXHRcdFx0cmV0dXJuIGJsb2IubXNTbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGF0YUhlbHBlcihieXRlTGVuZ3RoLCBieXRlcykge1xuXHRcdHZhciBkYXRhQnVmZmVyLCBkYXRhQXJyYXk7XG5cdFx0ZGF0YUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcblx0XHRkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhQnVmZmVyKTtcblx0XHRpZiAoYnl0ZXMpXG5cdFx0XHRkYXRhQXJyYXkuc2V0KGJ5dGVzLCAwKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YnVmZmVyIDogZGF0YUJ1ZmZlcixcblx0XHRcdGFycmF5IDogZGF0YUFycmF5LFxuXHRcdFx0dmlldyA6IG5ldyBEYXRhVmlldyhkYXRhQnVmZmVyKVxuXHRcdH07XG5cdH1cblxuXHQvLyBSZWFkZXJzXG5cdGZ1bmN0aW9uIFJlYWRlcigpIHtcblx0fVxuXG5cdGZ1bmN0aW9uIFRleHRSZWFkZXIodGV4dCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcywgYmxvYlJlYWRlcjtcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2ssIG9uZXJyb3IpIHtcblx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoWyB0ZXh0IF0sIHtcblx0XHRcdFx0dHlwZSA6IFRFWFRfUExBSU5cblx0XHRcdH0pO1xuXHRcdFx0YmxvYlJlYWRlciA9IG5ldyBCbG9iUmVhZGVyKGJsb2IpO1xuXHRcdFx0YmxvYlJlYWRlci5pbml0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0LnNpemUgPSBibG9iUmVhZGVyLnNpemU7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9LCBvbmVycm9yKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdFx0YmxvYlJlYWRlci5yZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaywgb25lcnJvcik7XG5cdFx0fVxuXG5cdFx0dGhhdC5zaXplID0gMDtcblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQucmVhZFVpbnQ4QXJyYXkgPSByZWFkVWludDhBcnJheTtcblx0fVxuXHRUZXh0UmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcblx0VGV4dFJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0UmVhZGVyO1xuXG5cdGZ1bmN0aW9uIERhdGE2NFVSSVJlYWRlcihkYXRhVVJJKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLCBkYXRhU3RhcnQ7XG5cblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZGF0YUVuZCA9IGRhdGFVUkkubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGRhdGFVUkkuY2hhckF0KGRhdGFFbmQgLSAxKSA9PSBcIj1cIilcblx0XHRcdFx0ZGF0YUVuZC0tO1xuXHRcdFx0ZGF0YVN0YXJ0ID0gZGF0YVVSSS5pbmRleE9mKFwiLFwiKSArIDE7XG5cdFx0XHR0aGF0LnNpemUgPSBNYXRoLmZsb29yKChkYXRhRW5kIC0gZGF0YVN0YXJ0KSAqIDAuNzUpO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGksIGRhdGEgPSBnZXREYXRhSGVscGVyKGxlbmd0aCk7XG5cdFx0XHR2YXIgc3RhcnQgPSBNYXRoLmZsb29yKGluZGV4IC8gMykgKiA0O1xuXHRcdFx0dmFyIGVuZCA9IE1hdGguY2VpbCgoaW5kZXggKyBsZW5ndGgpIC8gMykgKiA0O1xuXHRcdFx0dmFyIGJ5dGVzID0gb2JqLmF0b2IoZGF0YVVSSS5zdWJzdHJpbmcoc3RhcnQgKyBkYXRhU3RhcnQsIGVuZCArIGRhdGFTdGFydCkpO1xuXHRcdFx0dmFyIGRlbHRhID0gaW5kZXggLSBNYXRoLmZsb29yKHN0YXJ0IC8gNCkgKiAzO1xuXHRcdFx0Zm9yIChpID0gZGVsdGE7IGkgPCBkZWx0YSArIGxlbmd0aDsgaSsrKVxuXHRcdFx0XHRkYXRhLmFycmF5W2kgLSBkZWx0YV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0Y2FsbGJhY2soZGF0YS5hcnJheSk7XG5cdFx0fVxuXG5cdFx0dGhhdC5zaXplID0gMDtcblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQucmVhZFVpbnQ4QXJyYXkgPSByZWFkVWludDhBcnJheTtcblx0fVxuXHREYXRhNjRVUklSZWFkZXIucHJvdG90eXBlID0gbmV3IFJlYWRlcigpO1xuXHREYXRhNjRVUklSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGF0YTY0VVJJUmVhZGVyO1xuXG5cdGZ1bmN0aW9uIEJsb2JSZWFkZXIoYmxvYikge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdHRoYXQuc2l6ZSA9IGJsb2Iuc2l6ZTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IFVpbnQ4QXJyYXkoZS50YXJnZXQucmVzdWx0KSk7XG5cdFx0XHR9O1xuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBvbmVycm9yO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2JTbGljZShibG9iLCBpbmRleCwgbGVuZ3RoKSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9uZXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhhdC5zaXplID0gMDtcblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQucmVhZFVpbnQ4QXJyYXkgPSByZWFkVWludDhBcnJheTtcblx0fVxuXHRCbG9iUmVhZGVyLnByb3RvdHlwZSA9IG5ldyBSZWFkZXIoKTtcblx0QmxvYlJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbG9iUmVhZGVyO1xuXG5cdC8vIFdyaXRlcnNcblxuXHRmdW5jdGlvbiBXcml0ZXIoKSB7XG5cdH1cblx0V3JpdGVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayh0aGlzLmRhdGEpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFRleHRXcml0ZXIoZW5jb2RpbmcpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsIGJsb2I7XG5cblx0XHRmdW5jdGlvbiBpbml0KGNhbGxiYWNrKSB7XG5cdFx0XHRibG9iID0gbmV3IEJsb2IoW10sIHtcblx0XHRcdFx0dHlwZSA6IFRFWFRfUExBSU5cblx0XHRcdH0pO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG5cdFx0XHRibG9iID0gbmV3IEJsb2IoWyBibG9iLCBhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPyBhcnJheSA6IGFycmF5LmJ1ZmZlciBdLCB7XG5cdFx0XHRcdHR5cGUgOiBURVhUX1BMQUlOXG5cdFx0XHR9KTtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGF0YShjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRjYWxsYmFjayhlLnRhcmdldC5yZXN1bHQpO1xuXHRcdFx0fTtcblx0XHRcdHJlYWRlci5vbmVycm9yID0gb25lcnJvcjtcblx0XHRcdHJlYWRlci5yZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKTtcblx0XHR9XG5cblx0XHR0aGF0LmluaXQgPSBpbml0O1xuXHRcdHRoYXQud3JpdGVVaW50OEFycmF5ID0gd3JpdGVVaW50OEFycmF5O1xuXHRcdHRoYXQuZ2V0RGF0YSA9IGdldERhdGE7XG5cdH1cblx0VGV4dFdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XG5cdFRleHRXcml0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dFdyaXRlcjtcblxuXHRmdW5jdGlvbiBEYXRhNjRVUklXcml0ZXIoY29udGVudFR5cGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSBcIlwiLCBwZW5kaW5nID0gXCJcIjtcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdGRhdGEgKz0gXCJkYXRhOlwiICsgKGNvbnRlbnRUeXBlIHx8IFwiXCIpICsgXCI7YmFzZTY0LFwiO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaSwgZGVsdGEgPSBwZW5kaW5nLmxlbmd0aCwgZGF0YVN0cmluZyA9IHBlbmRpbmc7XG5cdFx0XHRwZW5kaW5nID0gXCJcIjtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCAoTWF0aC5mbG9vcigoZGVsdGEgKyBhcnJheS5sZW5ndGgpIC8gMykgKiAzKSAtIGRlbHRhOyBpKyspXG5cdFx0XHRcdGRhdGFTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG5cdFx0XHRmb3IgKDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRwZW5kaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuXHRcdFx0aWYgKGRhdGFTdHJpbmcubGVuZ3RoID4gMilcblx0XHRcdFx0ZGF0YSArPSBvYmouYnRvYShkYXRhU3RyaW5nKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cGVuZGluZyA9IGRhdGFTdHJpbmc7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERhdGEoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKGRhdGEgKyBvYmouYnRvYShwZW5kaW5nKSk7XG5cdFx0fVxuXG5cdFx0dGhhdC5pbml0ID0gaW5pdDtcblx0XHR0aGF0LndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcblx0XHR0aGF0LmdldERhdGEgPSBnZXREYXRhO1xuXHR9XG5cdERhdGE2NFVSSVdyaXRlci5wcm90b3R5cGUgPSBuZXcgV3JpdGVyKCk7XG5cdERhdGE2NFVSSVdyaXRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhNjRVUklXcml0ZXI7XG5cblx0ZnVuY3Rpb24gQmxvYldyaXRlcihjb250ZW50VHlwZSkge1xuXHRcdHZhciBibG9iLCB0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGluaXQoY2FsbGJhY2spIHtcblx0XHRcdGJsb2IgPSBuZXcgQmxvYihbXSwge1xuXHRcdFx0XHR0eXBlIDogY29udGVudFR5cGVcblx0XHRcdH0pO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cml0ZVVpbnQ4QXJyYXkoYXJyYXksIGNhbGxiYWNrKSB7XG5cdFx0XHRibG9iID0gbmV3IEJsb2IoWyBibG9iLCBhcHBlbmRBQlZpZXdTdXBwb3J0ZWQgPyBhcnJheSA6IGFycmF5LmJ1ZmZlciBdLCB7XG5cdFx0XHRcdHR5cGUgOiBjb250ZW50VHlwZVxuXHRcdFx0fSk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERhdGEoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKGJsb2IpO1xuXHRcdH1cblxuXHRcdHRoYXQuaW5pdCA9IGluaXQ7XG5cdFx0dGhhdC53cml0ZVVpbnQ4QXJyYXkgPSB3cml0ZVVpbnQ4QXJyYXk7XG5cdFx0dGhhdC5nZXREYXRhID0gZ2V0RGF0YTtcblx0fVxuXHRCbG9iV3JpdGVyLnByb3RvdHlwZSA9IG5ldyBXcml0ZXIoKTtcblx0QmxvYldyaXRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbG9iV3JpdGVyO1xuXG5cdC8qKiBcblx0ICogaW5mbGF0ZS9kZWZsYXRlIGNvcmUgZnVuY3Rpb25zXG5cdCAqIEBwYXJhbSB3b3JrZXIge1dvcmtlcn0gd2ViIHdvcmtlciBmb3IgdGhlIHRhc2suXG5cdCAqIEBwYXJhbSBpbml0aWFsTWVzc2FnZSB7T2JqZWN0fSBpbml0aWFsIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgd29ya2VyLiBzaG91bGQgY29udGFpblxuXHQgKiAgIHNuKHNlcmlhbCBudW1iZXIgZm9yIGRpc3Rpbmd1aXNoaW5nIG11bHRpcGxlIHRhc2tzIHNlbnQgdG8gdGhlIHdvcmtlciksIGFuZCBjb2RlY0NsYXNzLlxuXHQgKiAgIFRoaXMgZnVuY3Rpb24gbWF5IGFkZCBtb3JlIHByb3BlcnRpZXMgYmVmb3JlIHNlbmRpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiBsYXVuY2hXb3JrZXJQcm9jZXNzKHdvcmtlciwgaW5pdGlhbE1lc3NhZ2UsIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIG9ucHJvZ3Jlc3MsIG9uZW5kLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XG5cdFx0dmFyIGNodW5rSW5kZXggPSAwLCBpbmRleCwgb3V0cHV0U2l6ZSwgc24gPSBpbml0aWFsTWVzc2FnZS5zbiwgY3JjO1xuXG5cdFx0ZnVuY3Rpb24gb25mbHVzaCgpIHtcblx0XHRcdHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHRvbmVuZChvdXRwdXRTaXplLCBjcmMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9ubWVzc2FnZShldmVudCkge1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhLCBkYXRhID0gbWVzc2FnZS5kYXRhLCBlcnIgPSBtZXNzYWdlLmVycm9yO1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRlcnIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnRXJyb3I6ICcgKyB0aGlzLm1lc3NhZ2U7IH07XG5cdFx0XHRcdG9ucmVhZGVycm9yKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChtZXNzYWdlLnNuICE9PSBzbilcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0aWYgKHR5cGVvZiBtZXNzYWdlLmNvZGVjVGltZSA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHdvcmtlci5jb2RlY1RpbWUgKz0gbWVzc2FnZS5jb2RlY1RpbWU7IC8vIHNob3VsZCBiZSBiZWZvcmUgb25mbHVzaCgpXG5cdFx0XHRpZiAodHlwZW9mIG1lc3NhZ2UuY3JjVGltZSA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHdvcmtlci5jcmNUaW1lICs9IG1lc3NhZ2UuY3JjVGltZTtcblxuXHRcdFx0c3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnYXBwZW5kJzpcblx0XHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0b3V0cHV0U2l6ZSArPSBkYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHN0ZXAoKTtcblx0XHRcdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRzdGVwKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ZsdXNoJzpcblx0XHRcdFx0XHRjcmMgPSBtZXNzYWdlLmNyYztcblx0XHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0b3V0cHV0U2l6ZSArPSBkYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdG9uZmx1c2goKTtcblx0XHRcdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRvbmZsdXNoKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3Byb2dyZXNzJzpcblx0XHRcdFx0XHRpZiAob25wcm9ncmVzcylcblx0XHRcdFx0XHRcdG9ucHJvZ3Jlc3MoaW5kZXggKyBtZXNzYWdlLmxvYWRlZCwgc2l6ZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2ltcG9ydFNjcmlwdHMnOiAvL25vIG5lZWQgdG8gaGFuZGxlIGhlcmVcblx0XHRcdFx0Y2FzZSAnbmV3VGFzayc6XG5cdFx0XHRcdGNhc2UgJ2VjaG8nOlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignemlwLmpzOmxhdW5jaFdvcmtlclByb2Nlc3M6IHVua25vd24gbWVzc2FnZTogJywgbWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RlcCgpIHtcblx0XHRcdGluZGV4ID0gY2h1bmtJbmRleCAqIENIVU5LX1NJWkU7XG5cdFx0XHQvLyB1c2UgYDw9YCBpbnN0ZWFkIG9mIGA8YCwgYmVjYXVzZSBgc2l6ZWAgbWF5IGJlIDAuXG5cdFx0XHRpZiAoaW5kZXggPD0gc2l6ZSkge1xuXHRcdFx0XHRyZWFkZXIucmVhZFVpbnQ4QXJyYXkob2Zmc2V0ICsgaW5kZXgsIE1hdGgubWluKENIVU5LX1NJWkUsIHNpemUgLSBpbmRleCksIGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4LCBzaXplKTtcblx0XHRcdFx0XHR2YXIgbXNnID0gaW5kZXggPT09IDAgPyBpbml0aWFsTWVzc2FnZSA6IHtzbiA6IHNufTtcblx0XHRcdFx0XHRtc2cudHlwZSA9ICdhcHBlbmQnO1xuXHRcdFx0XHRcdG1zZy5kYXRhID0gYXJyYXk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gcG9zdGluZyBhIG1lc3NhZ2Ugd2l0aCB0cmFuc2ZlcmFibGVzIHdpbGwgZmFpbCBvbiBJRTEwXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZShtc2csIFthcnJheS5idWZmZXJdKTtcblx0XHRcdFx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UobXNnKTsgLy8gcmV0cnkgd2l0aG91dCB0cmFuc2ZlcmFibGVzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNodW5rSW5kZXgrKztcblx0XHRcdFx0fSwgb25yZWFkZXJyb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0XHRzbjogc24sXG5cdFx0XHRcdFx0dHlwZTogJ2ZsdXNoJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdXRwdXRTaXplID0gMDtcblx0XHR3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdHN0ZXAoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxhdW5jaFByb2Nlc3MocHJvY2VzcywgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgY3JjVHlwZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY2h1bmtJbmRleCA9IDAsIGluZGV4LCBvdXRwdXRTaXplID0gMCxcblx0XHRcdGNyY0lucHV0ID0gY3JjVHlwZSA9PT0gJ2lucHV0Jyxcblx0XHRcdGNyY091dHB1dCA9IGNyY1R5cGUgPT09ICdvdXRwdXQnLFxuXHRcdFx0Y3JjID0gbmV3IENyYzMyKCk7XG5cdFx0ZnVuY3Rpb24gc3RlcCgpIHtcblx0XHRcdHZhciBvdXRwdXREYXRhO1xuXHRcdFx0aW5kZXggPSBjaHVua0luZGV4ICogQ0hVTktfU0laRTtcblx0XHRcdGlmIChpbmRleCA8IHNpemUpXG5cdFx0XHRcdHJlYWRlci5yZWFkVWludDhBcnJheShvZmZzZXQgKyBpbmRleCwgTWF0aC5taW4oQ0hVTktfU0laRSwgc2l6ZSAtIGluZGV4KSwgZnVuY3Rpb24oaW5wdXREYXRhKSB7XG5cdFx0XHRcdFx0dmFyIG91dHB1dERhdGE7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdG91dHB1dERhdGEgPSBwcm9jZXNzLmFwcGVuZChpbnB1dERhdGEsIGZ1bmN0aW9uKGxvYWRlZCkge1xuXHRcdFx0XHRcdFx0XHRpZiAob25wcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4ICsgbG9hZGVkLCBzaXplKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xuXHRcdFx0XHRcdFx0b3V0cHV0U2l6ZSArPSBvdXRwdXREYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdyaXRlci53cml0ZVVpbnQ4QXJyYXkob3V0cHV0RGF0YSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGNodW5rSW5kZXgrKztcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChzdGVwLCAxKTtcblx0XHRcdFx0XHRcdH0sIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0XHRpZiAoY3JjT3V0cHV0KVxuXHRcdFx0XHRcdFx0XHRjcmMuYXBwZW5kKG91dHB1dERhdGEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjaHVua0luZGV4Kys7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3JjSW5wdXQpXG5cdFx0XHRcdFx0XHRjcmMuYXBwZW5kKGlucHV0RGF0YSk7XG5cdFx0XHRcdFx0aWYgKG9ucHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRvbnByb2dyZXNzKGluZGV4LCBzaXplKTtcblx0XHRcdFx0fSwgb25yZWFkZXJyb3IpO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b3V0cHV0RGF0YSA9IHByb2Nlc3MuZmx1c2goKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdG9ucmVhZGVycm9yKGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3V0cHV0RGF0YSkge1xuXHRcdFx0XHRcdGlmIChjcmNPdXRwdXQpXG5cdFx0XHRcdFx0XHRjcmMuYXBwZW5kKG91dHB1dERhdGEpO1xuXHRcdFx0XHRcdG91dHB1dFNpemUgKz0gb3V0cHV0RGF0YS5sZW5ndGg7XG5cdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShvdXRwdXREYXRhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdG9uZW5kKG91dHB1dFNpemUsIGNyYy5nZXQoKSk7XG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0b25lbmQob3V0cHV0U2l6ZSwgY3JjLmdldCgpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGVwKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbmZsYXRlKHdvcmtlciwgc24sIHJlYWRlciwgd3JpdGVyLCBvZmZzZXQsIHNpemUsIGNvbXB1dGVDcmMzMiwgb25lbmQsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY3JjVHlwZSA9IGNvbXB1dGVDcmMzMiA/ICdvdXRwdXQnIDogJ25vbmUnO1xuXHRcdGlmIChvYmouemlwLnVzZVdlYldvcmtlcnMpIHtcblx0XHRcdHZhciBpbml0aWFsTWVzc2FnZSA9IHtcblx0XHRcdFx0c246IHNuLFxuXHRcdFx0XHRjb2RlY0NsYXNzOiAnSW5mbGF0ZXInLFxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxuXHRcdFx0fTtcblx0XHRcdGxhdW5jaFdvcmtlclByb2Nlc3Mod29ya2VyLCBpbml0aWFsTWVzc2FnZSwgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHRcdH0gZWxzZVxuXHRcdFx0bGF1bmNoUHJvY2VzcyhuZXcgb2JqLnppcC5JbmZsYXRlcigpLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWZsYXRlKHdvcmtlciwgc24sIHJlYWRlciwgd3JpdGVyLCBsZXZlbCwgb25lbmQsIG9ucHJvZ3Jlc3MsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpIHtcblx0XHR2YXIgY3JjVHlwZSA9ICdpbnB1dCc7XG5cdFx0aWYgKG9iai56aXAudXNlV2ViV29ya2Vycykge1xuXHRcdFx0dmFyIGluaXRpYWxNZXNzYWdlID0ge1xuXHRcdFx0XHRzbjogc24sXG5cdFx0XHRcdG9wdGlvbnM6IHtsZXZlbDogbGV2ZWx9LFxuXHRcdFx0XHRjb2RlY0NsYXNzOiAnRGVmbGF0ZXInLFxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxuXHRcdFx0fTtcblx0XHRcdGxhdW5jaFdvcmtlclByb2Nlc3Mod29ya2VyLCBpbml0aWFsTWVzc2FnZSwgcmVhZGVyLCB3cml0ZXIsIDAsIHJlYWRlci5zaXplLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0fSBlbHNlXG5cdFx0XHRsYXVuY2hQcm9jZXNzKG5ldyBvYmouemlwLkRlZmxhdGVyKCksIHJlYWRlciwgd3JpdGVyLCAwLCByZWFkZXIuc2l6ZSwgY3JjVHlwZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29weSh3b3JrZXIsIHNuLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjb21wdXRlQ3JjMzIsIG9uZW5kLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKSB7XG5cdFx0dmFyIGNyY1R5cGUgPSAnaW5wdXQnO1xuXHRcdGlmIChvYmouemlwLnVzZVdlYldvcmtlcnMgJiYgY29tcHV0ZUNyYzMyKSB7XG5cdFx0XHR2YXIgaW5pdGlhbE1lc3NhZ2UgPSB7XG5cdFx0XHRcdHNuOiBzbixcblx0XHRcdFx0Y29kZWNDbGFzczogJ05PT1AnLFxuXHRcdFx0XHRjcmNUeXBlOiBjcmNUeXBlLFxuXHRcdFx0fTtcblx0XHRcdGxhdW5jaFdvcmtlclByb2Nlc3Mod29ya2VyLCBpbml0aWFsTWVzc2FnZSwgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgc2l6ZSwgb25wcm9ncmVzcywgb25lbmQsIG9ucmVhZGVycm9yLCBvbndyaXRlZXJyb3IpO1xuXHRcdH0gZWxzZVxuXHRcdFx0bGF1bmNoUHJvY2VzcyhuZXcgTk9PUCgpLCByZWFkZXIsIHdyaXRlciwgb2Zmc2V0LCBzaXplLCBjcmNUeXBlLCBvbnByb2dyZXNzLCBvbmVuZCwgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdH1cblxuXHQvLyBaaXBSZWFkZXJcblxuXHRmdW5jdGlvbiBkZWNvZGVBU0NJSShzdHIpIHtcblx0XHR2YXIgaSwgb3V0ID0gXCJcIiwgY2hhckNvZGUsIGV4dGVuZGVkQVNDSUkgPSBbICdcXHUwMEM3JywgJ1xcdTAwRkMnLCAnXFx1MDBFOScsICdcXHUwMEUyJywgJ1xcdTAwRTQnLCAnXFx1MDBFMCcsICdcXHUwMEU1JywgJ1xcdTAwRTcnLCAnXFx1MDBFQScsICdcXHUwMEVCJyxcblx0XHRcdFx0J1xcdTAwRTgnLCAnXFx1MDBFRicsICdcXHUwMEVFJywgJ1xcdTAwRUMnLCAnXFx1MDBDNCcsICdcXHUwMEM1JywgJ1xcdTAwQzknLCAnXFx1MDBFNicsICdcXHUwMEM2JywgJ1xcdTAwRjQnLCAnXFx1MDBGNicsICdcXHUwMEYyJywgJ1xcdTAwRkInLCAnXFx1MDBGOScsXG5cdFx0XHRcdCdcXHUwMEZGJywgJ1xcdTAwRDYnLCAnXFx1MDBEQycsICdcXHUwMEY4JywgJ1xcdTAwQTMnLCAnXFx1MDBEOCcsICdcXHUwMEQ3JywgJ1xcdTAxOTInLCAnXFx1MDBFMScsICdcXHUwMEVEJywgJ1xcdTAwRjMnLCAnXFx1MDBGQScsICdcXHUwMEYxJywgJ1xcdTAwRDEnLFxuXHRcdFx0XHQnXFx1MDBBQScsICdcXHUwMEJBJywgJ1xcdTAwQkYnLCAnXFx1MDBBRScsICdcXHUwMEFDJywgJ1xcdTAwQkQnLCAnXFx1MDBCQycsICdcXHUwMEExJywgJ1xcdTAwQUInLCAnXFx1MDBCQicsICdfJywgJ18nLCAnXycsICdcXHUwMEE2JywgJ1xcdTAwQTYnLFxuXHRcdFx0XHQnXFx1MDBDMScsICdcXHUwMEMyJywgJ1xcdTAwQzAnLCAnXFx1MDBBOScsICdcXHUwMEE2JywgJ1xcdTAwQTYnLCAnKycsICcrJywgJ1xcdTAwQTInLCAnXFx1MDBBNScsICcrJywgJysnLCAnLScsICctJywgJysnLCAnLScsICcrJywgJ1xcdTAwRTMnLFxuXHRcdFx0XHQnXFx1MDBDMycsICcrJywgJysnLCAnLScsICctJywgJ1xcdTAwQTYnLCAnLScsICcrJywgJ1xcdTAwQTQnLCAnXFx1MDBGMCcsICdcXHUwMEQwJywgJ1xcdTAwQ0EnLCAnXFx1MDBDQicsICdcXHUwMEM4JywgJ2knLCAnXFx1MDBDRCcsICdcXHUwMENFJyxcblx0XHRcdFx0J1xcdTAwQ0YnLCAnKycsICcrJywgJ18nLCAnXycsICdcXHUwMEE2JywgJ1xcdTAwQ0MnLCAnXycsICdcXHUwMEQzJywgJ1xcdTAwREYnLCAnXFx1MDBENCcsICdcXHUwMEQyJywgJ1xcdTAwRjUnLCAnXFx1MDBENScsICdcXHUwMEI1JywgJ1xcdTAwRkUnLFxuXHRcdFx0XHQnXFx1MDBERScsICdcXHUwMERBJywgJ1xcdTAwREInLCAnXFx1MDBEOScsICdcXHUwMEZEJywgJ1xcdTAwREQnLCAnXFx1MDBBRicsICdcXHUwMEI0JywgJ1xcdTAwQUQnLCAnXFx1MDBCMScsICdfJywgJ1xcdTAwQkUnLCAnXFx1MDBCNicsICdcXHUwMEE3Jyxcblx0XHRcdFx0J1xcdTAwRjcnLCAnXFx1MDBCOCcsICdcXHUwMEIwJywgJ1xcdTAwQTgnLCAnXFx1MDBCNycsICdcXHUwMEI5JywgJ1xcdTAwQjMnLCAnXFx1MDBCMicsICdfJywgJyAnIF07XG5cdFx0Zm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG5cdFx0XHRpZiAoY2hhckNvZGUgPiAxMjcpXG5cdFx0XHRcdG91dCArPSBleHRlbmRlZEFTQ0lJW2NoYXJDb2RlIC0gMTI4XTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0b3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlVVRGOChzdHJpbmcpIHtcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHJpbmcpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFN0cmluZyhieXRlcykge1xuXHRcdHZhciBpLCBzdHIgPSBcIlwiO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcblx0XHRcdHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGF0ZSh0aW1lUmF3KSB7XG5cdFx0dmFyIGRhdGUgPSAodGltZVJhdyAmIDB4ZmZmZjAwMDApID4+IDE2LCB0aW1lID0gdGltZVJhdyAmIDB4MDAwMGZmZmY7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBuZXcgRGF0ZSgxOTgwICsgKChkYXRlICYgMHhGRTAwKSA+PiA5KSwgKChkYXRlICYgMHgwMUUwKSA+PiA1KSAtIDEsIGRhdGUgJiAweDAwMUYsICh0aW1lICYgMHhGODAwKSA+PiAxMSwgKHRpbWUgJiAweDA3RTApID4+IDUsXG5cdFx0XHRcdFx0KHRpbWUgJiAweDAwMUYpICogMiwgMCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlYWRDb21tb25IZWFkZXIoZW50cnksIGRhdGEsIGluZGV4LCBjZW50cmFsRGlyZWN0b3J5LCBvbmVycm9yKSB7XG5cdFx0ZW50cnkudmVyc2lvbiA9IGRhdGEudmlldy5nZXRVaW50MTYoaW5kZXgsIHRydWUpO1xuXHRcdGVudHJ5LmJpdEZsYWcgPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMiwgdHJ1ZSk7XG5cdFx0ZW50cnkuY29tcHJlc3Npb25NZXRob2QgPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgNCwgdHJ1ZSk7XG5cdFx0ZW50cnkubGFzdE1vZERhdGVSYXcgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgNiwgdHJ1ZSk7XG5cdFx0ZW50cnkubGFzdE1vZERhdGUgPSBnZXREYXRlKGVudHJ5Lmxhc3RNb2REYXRlUmF3KTtcblx0XHRpZiAoKGVudHJ5LmJpdEZsYWcgJiAweDAxKSA9PT0gMHgwMSkge1xuXHRcdFx0b25lcnJvcihFUlJfRU5DUllQVEVEKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKGNlbnRyYWxEaXJlY3RvcnkgfHwgKGVudHJ5LmJpdEZsYWcgJiAweDAwMDgpICE9IDB4MDAwOCkge1xuXHRcdFx0ZW50cnkuY3JjMzIgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTAsIHRydWUpO1xuXHRcdFx0ZW50cnkuY29tcHJlc3NlZFNpemUgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgMTQsIHRydWUpO1xuXHRcdFx0ZW50cnkudW5jb21wcmVzc2VkU2l6ZSA9IGRhdGEudmlldy5nZXRVaW50MzIoaW5kZXggKyAxOCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGlmIChlbnRyeS5jb21wcmVzc2VkU2l6ZSA9PT0gMHhGRkZGRkZGRiB8fCBlbnRyeS51bmNvbXByZXNzZWRTaXplID09PSAweEZGRkZGRkZGKSB7XG5cdFx0XHRvbmVycm9yKEVSUl9aSVA2NCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVudHJ5LmZpbGVuYW1lTGVuZ3RoID0gZGF0YS52aWV3LmdldFVpbnQxNihpbmRleCArIDIyLCB0cnVlKTtcblx0XHRlbnRyeS5leHRyYUZpZWxkTGVuZ3RoID0gZGF0YS52aWV3LmdldFVpbnQxNihpbmRleCArIDI0LCB0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKSB7XG5cdFx0dmFyIGluZmxhdGVTTiA9IDA7XG5cblx0XHRmdW5jdGlvbiBFbnRyeSgpIHtcblx0XHR9XG5cblx0XHRFbnRyeS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKHdyaXRlciwgb25lbmQsIG9ucHJvZ3Jlc3MsIGNoZWNrQ3JjMzIpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdFx0ZnVuY3Rpb24gdGVzdENyYzMyKGNyYzMyKSB7XG5cdFx0XHRcdHZhciBkYXRhQ3JjMzIgPSBnZXREYXRhSGVscGVyKDQpO1xuXHRcdFx0XHRkYXRhQ3JjMzIudmlldy5zZXRVaW50MzIoMCwgY3JjMzIpO1xuXHRcdFx0XHRyZXR1cm4gdGhhdC5jcmMzMiA9PSBkYXRhQ3JjMzIudmlldy5nZXRVaW50MzIoMCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFdyaXRlckRhdGEodW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIpIHtcblx0XHRcdFx0aWYgKGNoZWNrQ3JjMzIgJiYgIXRlc3RDcmMzMihjcmMzMikpXG5cdFx0XHRcdFx0b25lcnJvcihFUlJfQ1JDKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHdyaXRlci5nZXREYXRhKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHRcdG9uZW5kKGRhdGEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvbnJlYWRlcnJvcihlcnIpIHtcblx0XHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1JFQURfREFUQSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9ud3JpdGVlcnJvcihlcnIpIHtcblx0XHRcdFx0b25lcnJvcihlcnIgfHwgRVJSX1dSSVRFX0RBVEEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWFkZXIucmVhZFVpbnQ4QXJyYXkodGhhdC5vZmZzZXQsIDMwLCBmdW5jdGlvbihieXRlcykge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGdldERhdGFIZWxwZXIoYnl0ZXMubGVuZ3RoLCBieXRlcyksIGRhdGFPZmZzZXQ7XG5cdFx0XHRcdGlmIChkYXRhLnZpZXcuZ2V0VWludDMyKDApICE9IDB4NTA0YjAzMDQpIHtcblx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVhZENvbW1vbkhlYWRlcih0aGF0LCBkYXRhLCA0LCBmYWxzZSwgb25lcnJvcik7XG5cdFx0XHRcdGRhdGFPZmZzZXQgPSB0aGF0Lm9mZnNldCArIDMwICsgdGhhdC5maWxlbmFtZUxlbmd0aCArIHRoYXQuZXh0cmFGaWVsZExlbmd0aDtcblx0XHRcdFx0d3JpdGVyLmluaXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKHRoYXQuY29tcHJlc3Npb25NZXRob2QgPT09IDApXG5cdFx0XHRcdFx0XHRjb3B5KHRoYXQuX3dvcmtlciwgaW5mbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBkYXRhT2Zmc2V0LCB0aGF0LmNvbXByZXNzZWRTaXplLCBjaGVja0NyYzMyLCBnZXRXcml0ZXJEYXRhLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRpbmZsYXRlKHRoYXQuX3dvcmtlciwgaW5mbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBkYXRhT2Zmc2V0LCB0aGF0LmNvbXByZXNzZWRTaXplLCBjaGVja0NyYzMyLCBnZXRXcml0ZXJEYXRhLCBvbnByb2dyZXNzLCBvbnJlYWRlcnJvciwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdH0sIG9ucmVhZGVycm9yKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gc2Vla0VPQ0RSKGVvY2RyQ2FsbGJhY2spIHtcblx0XHRcdC8vIFwiRW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZFwiIGlzIHRoZSBsYXN0IHBhcnQgb2YgYSB6aXAgYXJjaGl2ZSwgYW5kIGlzIGF0IGxlYXN0IDIyIGJ5dGVzIGxvbmcuXG5cdFx0XHQvLyBaaXAgZmlsZSBjb21tZW50IGlzIHRoZSBsYXN0IHBhcnQgb2YgRU9DRFIgYW5kIGhhcyBtYXggbGVuZ3RoIG9mIDY0S0IsXG5cdFx0XHQvLyBzbyB3ZSBvbmx5IGhhdmUgdG8gc2VhcmNoIHRoZSBsYXN0IDY0SyArIDIyIGJ5dGVzIG9mIGEgYXJjaGl2ZSBmb3IgRU9DRFIgc2lnbmF0dXJlICgweDA2MDU0YjUwKS5cblx0XHRcdHZhciBFT0NEUl9NSU4gPSAyMjtcblx0XHRcdGlmIChyZWFkZXIuc2l6ZSA8IEVPQ0RSX01JTikge1xuXHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIFpJUF9DT01NRU5UX01BWCA9IDI1NiAqIDI1NiwgRU9DRFJfTUFYID0gRU9DRFJfTUlOICsgWklQX0NPTU1FTlRfTUFYO1xuXG5cdFx0XHQvLyBJbiBtb3N0IGNhc2VzLCB0aGUgRU9DRFIgaXMgRU9DRFJfTUlOIGJ5dGVzIGxvbmdcblx0XHRcdGRvU2VlayhFT0NEUl9NSU4sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBJZiBub3QgZm91bmQsIHRyeSB3aXRoaW4gRU9DRFJfTUFYIGJ5dGVzXG5cdFx0XHRcdGRvU2VlayhNYXRoLm1pbihFT0NEUl9NQVgsIHJlYWRlci5zaXplKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHNlZWsgbGFzdCBsZW5ndGggYnl0ZXMgb2YgZmlsZSBmb3IgRU9DRFJcblx0XHRcdGZ1bmN0aW9uIGRvU2VlayhsZW5ndGgsIGVvY2RyTm90Rm91bmRDYWxsYmFjaykge1xuXHRcdFx0XHRyZWFkZXIucmVhZFVpbnQ4QXJyYXkocmVhZGVyLnNpemUgLSBsZW5ndGgsIGxlbmd0aCwgZnVuY3Rpb24oYnl0ZXMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gYnl0ZXMubGVuZ3RoIC0gRU9DRFJfTUlOOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0aWYgKGJ5dGVzW2ldID09PSAweDUwICYmIGJ5dGVzW2kgKyAxXSA9PT0gMHg0YiAmJiBieXRlc1tpICsgMl0gPT09IDB4MDUgJiYgYnl0ZXNbaSArIDNdID09PSAweDA2KSB7XG5cdFx0XHRcdFx0XHRcdGVvY2RyQ2FsbGJhY2sobmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgaSwgRU9DRFJfTUlOKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW9jZHJOb3RGb3VuZENhbGxiYWNrKCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG9uZXJyb3IoRVJSX1JFQUQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgemlwUmVhZGVyID0ge1xuXHRcdFx0Z2V0RW50cmllcyA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciB3b3JrZXIgPSB0aGlzLl93b3JrZXI7XG5cdFx0XHRcdC8vIGxvb2sgZm9yIEVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmRcblx0XHRcdFx0c2Vla0VPQ0RSKGZ1bmN0aW9uKGRhdGFWaWV3KSB7XG5cdFx0XHRcdFx0dmFyIGRhdGFsZW5ndGgsIGZpbGVzbGVuZ3RoO1xuXHRcdFx0XHRcdGRhdGFsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoMTYsIHRydWUpO1xuXHRcdFx0XHRcdGZpbGVzbGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KDgsIHRydWUpO1xuXHRcdFx0XHRcdGlmIChkYXRhbGVuZ3RoIDwgMCB8fCBkYXRhbGVuZ3RoID49IHJlYWRlci5zaXplKSB7XG5cdFx0XHRcdFx0XHRvbmVycm9yKEVSUl9CQURfRk9STUFUKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRVaW50OEFycmF5KGRhdGFsZW5ndGgsIHJlYWRlci5zaXplIC0gZGF0YWxlbmd0aCwgZnVuY3Rpb24oYnl0ZXMpIHtcblx0XHRcdFx0XHRcdHZhciBpLCBpbmRleCA9IDAsIGVudHJpZXMgPSBbXSwgZW50cnksIGZpbGVuYW1lLCBjb21tZW50LCBkYXRhID0gZ2V0RGF0YUhlbHBlcihieXRlcy5sZW5ndGgsIGJ5dGVzKTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWxlc2xlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGVudHJ5ID0gbmV3IEVudHJ5KCk7XG5cdFx0XHRcdFx0XHRcdGVudHJ5Ll93b3JrZXIgPSB3b3JrZXI7XG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4KSAhPSAweDUwNGIwMTAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0b25lcnJvcihFUlJfQkFEX0ZPUk1BVCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJlYWRDb21tb25IZWFkZXIoZW50cnksIGRhdGEsIGluZGV4ICsgNiwgdHJ1ZSwgb25lcnJvcik7XG5cdFx0XHRcdFx0XHRcdGVudHJ5LmNvbW1lbnRMZW5ndGggPSBkYXRhLnZpZXcuZ2V0VWludDE2KGluZGV4ICsgMzIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRlbnRyeS5kaXJlY3RvcnkgPSAoKGRhdGEudmlldy5nZXRVaW50OChpbmRleCArIDM4KSAmIDB4MTApID09IDB4MTApO1xuXHRcdFx0XHRcdFx0XHRlbnRyeS5vZmZzZXQgPSBkYXRhLnZpZXcuZ2V0VWludDMyKGluZGV4ICsgNDIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRmaWxlbmFtZSA9IGdldFN0cmluZyhkYXRhLmFycmF5LnN1YmFycmF5KGluZGV4ICsgNDYsIGluZGV4ICsgNDYgKyBlbnRyeS5maWxlbmFtZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRlbnRyeS5maWxlbmFtZSA9ICgoZW50cnkuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMCkgPyBkZWNvZGVVVEY4KGZpbGVuYW1lKSA6IGRlY29kZUFTQ0lJKGZpbGVuYW1lKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnRyeS5kaXJlY3RvcnkgJiYgZW50cnkuZmlsZW5hbWUuY2hhckF0KGVudHJ5LmZpbGVuYW1lLmxlbmd0aCAtIDEpID09IFwiL1wiKVxuXHRcdFx0XHRcdFx0XHRcdGVudHJ5LmRpcmVjdG9yeSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGNvbW1lbnQgPSBnZXRTdHJpbmcoZGF0YS5hcnJheS5zdWJhcnJheShpbmRleCArIDQ2ICsgZW50cnkuZmlsZW5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoLCBpbmRleCArIDQ2XG5cdFx0XHRcdFx0XHRcdFx0XHQrIGVudHJ5LmZpbGVuYW1lTGVuZ3RoICsgZW50cnkuZXh0cmFGaWVsZExlbmd0aCArIGVudHJ5LmNvbW1lbnRMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0ZW50cnkuY29tbWVudCA9ICgoZW50cnkuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMCkgPyBkZWNvZGVVVEY4KGNvbW1lbnQpIDogZGVjb2RlQVNDSUkoY29tbWVudCk7XG5cdFx0XHRcdFx0XHRcdGVudHJpZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdFx0XHRcdGluZGV4ICs9IDQ2ICsgZW50cnkuZmlsZW5hbWVMZW5ndGggKyBlbnRyeS5leHRyYUZpZWxkTGVuZ3RoICsgZW50cnkuY29tbWVudExlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhbGxiYWNrKGVudHJpZXMpO1xuXHRcdFx0XHRcdH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0b25lcnJvcihFUlJfUkVBRCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGNsb3NlIDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHRoaXMuX3dvcmtlcikge1xuXHRcdFx0XHRcdHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcblx0XHRcdFx0XHR0aGlzLl93b3JrZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsYmFjaylcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fSxcblx0XHRcdF93b3JrZXI6IG51bGxcblx0XHR9O1xuXG5cdFx0aWYgKCFvYmouemlwLnVzZVdlYldvcmtlcnMpXG5cdFx0XHRjYWxsYmFjayh6aXBSZWFkZXIpO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y3JlYXRlV29ya2VyKCdpbmZsYXRlcicsXG5cdFx0XHRcdGZ1bmN0aW9uKHdvcmtlcikge1xuXHRcdFx0XHRcdHppcFJlYWRlci5fd29ya2VyID0gd29ya2VyO1xuXHRcdFx0XHRcdGNhbGxiYWNrKHppcFJlYWRlcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdG9uZXJyb3IoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvLyBaaXBXcml0ZXJcblxuXHRmdW5jdGlvbiBlbmNvZGVVVEY4KHN0cmluZykge1xuXHRcdHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCeXRlcyhzdHIpIHtcblx0XHR2YXIgaSwgYXJyYXkgPSBbXTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuXHRcdFx0YXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlWmlwV3JpdGVyKHdyaXRlciwgY2FsbGJhY2ssIG9uZXJyb3IsIGRvbnREZWZsYXRlKSB7XG5cdFx0dmFyIGZpbGVzID0ge30sIGZpbGVuYW1lcyA9IFtdLCBkYXRhbGVuZ3RoID0gMDtcblx0XHR2YXIgZGVmbGF0ZVNOID0gMDtcblxuXHRcdGZ1bmN0aW9uIG9ud3JpdGVlcnJvcihlcnIpIHtcblx0XHRcdG9uZXJyb3IoZXJyIHx8IEVSUl9XUklURSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25yZWFkZXJyb3IoZXJyKSB7XG5cdFx0XHRvbmVycm9yKGVyciB8fCBFUlJfUkVBRF9EQVRBKTtcblx0XHR9XG5cblx0XHR2YXIgemlwV3JpdGVyID0ge1xuXHRcdFx0YWRkIDogZnVuY3Rpb24obmFtZSwgcmVhZGVyLCBvbmVuZCwgb25wcm9ncmVzcywgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgaGVhZGVyLCBmaWxlbmFtZSwgZGF0ZTtcblx0XHRcdFx0dmFyIHdvcmtlciA9IHRoaXMuX3dvcmtlcjtcblxuXHRcdFx0XHRmdW5jdGlvbiB3cml0ZUhlYWRlcihjYWxsYmFjaykge1xuXHRcdFx0XHRcdHZhciBkYXRhO1xuXHRcdFx0XHRcdGRhdGUgPSBvcHRpb25zLmxhc3RNb2REYXRlIHx8IG5ldyBEYXRlKCk7XG5cdFx0XHRcdFx0aGVhZGVyID0gZ2V0RGF0YUhlbHBlcigyNik7XG5cdFx0XHRcdFx0ZmlsZXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJBcnJheSA6IGhlYWRlci5hcnJheSxcblx0XHRcdFx0XHRcdGRpcmVjdG9yeSA6IG9wdGlvbnMuZGlyZWN0b3J5LFxuXHRcdFx0XHRcdFx0ZmlsZW5hbWUgOiBmaWxlbmFtZSxcblx0XHRcdFx0XHRcdG9mZnNldCA6IGRhdGFsZW5ndGgsXG5cdFx0XHRcdFx0XHRjb21tZW50IDogZ2V0Qnl0ZXMoZW5jb2RlVVRGOChvcHRpb25zLmNvbW1lbnQgfHwgXCJcIikpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMCwgMHgxNDAwMDgwOCk7XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMudmVyc2lvbilcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQ4KDAsIG9wdGlvbnMudmVyc2lvbik7XG5cdFx0XHRcdFx0aWYgKCFkb250RGVmbGF0ZSAmJiBvcHRpb25zLmxldmVsICE9PSAwICYmICFvcHRpb25zLmRpcmVjdG9yeSlcblx0XHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig0LCAweDA4MDApO1xuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig2LCAoKChkYXRlLmdldEhvdXJzKCkgPDwgNikgfCBkYXRlLmdldE1pbnV0ZXMoKSkgPDwgNSkgfCBkYXRlLmdldFNlY29uZHMoKSAvIDIsIHRydWUpO1xuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNig4LCAoKCgoZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTk4MCkgPDwgNCkgfCAoZGF0ZS5nZXRNb250aCgpICsgMSkpIDw8IDUpIHwgZGF0ZS5nZXREYXRlKCksIHRydWUpO1xuXHRcdFx0XHRcdGhlYWRlci52aWV3LnNldFVpbnQxNigyMiwgZmlsZW5hbWUubGVuZ3RoLCB0cnVlKTtcblx0XHRcdFx0XHRkYXRhID0gZ2V0RGF0YUhlbHBlcigzMCArIGZpbGVuYW1lLmxlbmd0aCk7XG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMigwLCAweDUwNGIwMzA0KTtcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChoZWFkZXIuYXJyYXksIDQpO1xuXHRcdFx0XHRcdGRhdGEuYXJyYXkuc2V0KGZpbGVuYW1lLCAzMCk7XG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBkYXRhLmFycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEuYXJyYXksIGNhbGxiYWNrLCBvbndyaXRlZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gd3JpdGVGb290ZXIoY29tcHJlc3NlZExlbmd0aCwgY3JjMzIpIHtcblx0XHRcdFx0XHR2YXIgZm9vdGVyID0gZ2V0RGF0YUhlbHBlcigxNik7XG5cdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSBjb21wcmVzc2VkTGVuZ3RoIHx8IDA7XG5cdFx0XHRcdFx0Zm9vdGVyLnZpZXcuc2V0VWludDMyKDAsIDB4NTA0YjA3MDgpO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgY3JjMzIgIT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRcdFx0aGVhZGVyLnZpZXcuc2V0VWludDMyKDEwLCBjcmMzMiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoNCwgY3JjMzIsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocmVhZGVyKSB7XG5cdFx0XHRcdFx0XHRmb290ZXIudmlldy5zZXRVaW50MzIoOCwgY29tcHJlc3NlZExlbmd0aCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMTQsIGNvbXByZXNzZWRMZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRcdFx0Zm9vdGVyLnZpZXcuc2V0VWludDMyKDEyLCByZWFkZXIuc2l6ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRoZWFkZXIudmlldy5zZXRVaW50MzIoMTgsIHJlYWRlci5zaXplLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d3JpdGVyLndyaXRlVWludDhBcnJheShmb290ZXIuYXJyYXksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGF0YWxlbmd0aCArPSAxNjtcblx0XHRcdFx0XHRcdG9uZW5kKCk7XG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIHdyaXRlRmlsZSgpIHtcblx0XHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0XHRuYW1lID0gbmFtZS50cmltKCk7XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuZGlyZWN0b3J5ICYmIG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgIT0gXCIvXCIpXG5cdFx0XHRcdFx0XHRuYW1lICs9IFwiL1wiO1xuXHRcdFx0XHRcdGlmIChmaWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdFx0b25lcnJvcihFUlJfRFVQTElDQVRFRF9OQU1FKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmlsZW5hbWUgPSBnZXRCeXRlcyhlbmNvZGVVVEY4KG5hbWUpKTtcblx0XHRcdFx0XHRmaWxlbmFtZXMucHVzaChuYW1lKTtcblx0XHRcdFx0XHR3cml0ZUhlYWRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmIChyZWFkZXIpXG5cdFx0XHRcdFx0XHRcdGlmIChkb250RGVmbGF0ZSB8fCBvcHRpb25zLmxldmVsID09PSAwKVxuXHRcdFx0XHRcdFx0XHRcdGNvcHkod29ya2VyLCBkZWZsYXRlU04rKywgcmVhZGVyLCB3cml0ZXIsIDAsIHJlYWRlci5zaXplLCB0cnVlLCB3cml0ZUZvb3Rlciwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRkZWZsYXRlKHdvcmtlciwgZGVmbGF0ZVNOKyssIHJlYWRlciwgd3JpdGVyLCBvcHRpb25zLmxldmVsLCB3cml0ZUZvb3Rlciwgb25wcm9ncmVzcywgb25yZWFkZXJyb3IsIG9ud3JpdGVlcnJvcik7XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdHdyaXRlRm9vdGVyKCk7XG5cdFx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZWFkZXIpXG5cdFx0XHRcdFx0cmVhZGVyLmluaXQod3JpdGVGaWxlLCBvbnJlYWRlcnJvcik7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR3cml0ZUZpbGUoKTtcblx0XHRcdH0sXG5cdFx0XHRjbG9zZSA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmICh0aGlzLl93b3JrZXIpIHtcblx0XHRcdFx0XHR0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5fd29ya2VyID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRhLCBsZW5ndGggPSAwLCBpbmRleCA9IDAsIGluZGV4RmlsZW5hbWUsIGZpbGU7XG5cdFx0XHRcdGZvciAoaW5kZXhGaWxlbmFtZSA9IDA7IGluZGV4RmlsZW5hbWUgPCBmaWxlbmFtZXMubGVuZ3RoOyBpbmRleEZpbGVuYW1lKyspIHtcblx0XHRcdFx0XHRmaWxlID0gZmlsZXNbZmlsZW5hbWVzW2luZGV4RmlsZW5hbWVdXTtcblx0XHRcdFx0XHRsZW5ndGggKz0gNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCArIGZpbGUuY29tbWVudC5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YSA9IGdldERhdGFIZWxwZXIobGVuZ3RoICsgMjIpO1xuXHRcdFx0XHRmb3IgKGluZGV4RmlsZW5hbWUgPSAwOyBpbmRleEZpbGVuYW1lIDwgZmlsZW5hbWVzLmxlbmd0aDsgaW5kZXhGaWxlbmFtZSsrKSB7XG5cdFx0XHRcdFx0ZmlsZSA9IGZpbGVzW2ZpbGVuYW1lc1tpbmRleEZpbGVuYW1lXV07XG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCwgMHg1MDRiMDEwMik7XG5cdFx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDQsIDB4MTQwMCk7XG5cdFx0XHRcdFx0ZGF0YS5hcnJheS5zZXQoZmlsZS5oZWFkZXJBcnJheSwgaW5kZXggKyA2KTtcblx0XHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDE2KGluZGV4ICsgMzIsIGZpbGUuY29tbWVudC5sZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRcdGlmIChmaWxlLmRpcmVjdG9yeSlcblx0XHRcdFx0XHRcdGRhdGEudmlldy5zZXRVaW50OChpbmRleCArIDM4LCAweDEwKTtcblx0XHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4ICsgNDIsIGZpbGUub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmZpbGVuYW1lLCBpbmRleCArIDQ2KTtcblx0XHRcdFx0XHRkYXRhLmFycmF5LnNldChmaWxlLmNvbW1lbnQsIGluZGV4ICsgNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCk7XG5cdFx0XHRcdFx0aW5kZXggKz0gNDYgKyBmaWxlLmZpbGVuYW1lLmxlbmd0aCArIGZpbGUuY29tbWVudC5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCwgMHg1MDRiMDUwNik7XG5cdFx0XHRcdGRhdGEudmlldy5zZXRVaW50MTYoaW5kZXggKyA4LCBmaWxlbmFtZXMubGVuZ3RoLCB0cnVlKTtcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQxNihpbmRleCArIDEwLCBmaWxlbmFtZXMubGVuZ3RoLCB0cnVlKTtcblx0XHRcdFx0ZGF0YS52aWV3LnNldFVpbnQzMihpbmRleCArIDEyLCBsZW5ndGgsIHRydWUpO1xuXHRcdFx0XHRkYXRhLnZpZXcuc2V0VWludDMyKGluZGV4ICsgMTYsIGRhdGFsZW5ndGgsIHRydWUpO1xuXHRcdFx0XHR3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGEuYXJyYXksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHdyaXRlci5nZXREYXRhKGNhbGxiYWNrKTtcblx0XHRcdFx0fSwgb253cml0ZWVycm9yKTtcblx0XHRcdH0sXG5cdFx0XHRfd29ya2VyOiBudWxsXG5cdFx0fTtcblxuXHRcdGlmICghb2JqLnppcC51c2VXZWJXb3JrZXJzKVxuXHRcdFx0Y2FsbGJhY2soemlwV3JpdGVyKTtcblx0XHRlbHNlIHtcblx0XHRcdGNyZWF0ZVdvcmtlcignZGVmbGF0ZXInLFxuXHRcdFx0XHRmdW5jdGlvbih3b3JrZXIpIHtcblx0XHRcdFx0XHR6aXBXcml0ZXIuX3dvcmtlciA9IHdvcmtlcjtcblx0XHRcdFx0XHRjYWxsYmFjayh6aXBXcml0ZXIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRvbmVycm9yKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZVVSTHModXJscykge1xuXHRcdHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdHJldHVybiB1cmxzLm1hcChmdW5jdGlvbih1cmwpIHtcblx0XHRcdGEuaHJlZiA9IHVybDtcblx0XHRcdHJldHVybiBhLmhyZWY7XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgREVGQVVMVF9XT1JLRVJfU0NSSVBUUyA9IHtcblx0XHRkZWZsYXRlcjogWyd6LXdvcmtlci5qcycsICdkZWZsYXRlLmpzJ10sXG5cdFx0aW5mbGF0ZXI6IFsnei13b3JrZXIuanMnLCAnaW5mbGF0ZS5qcyddXG5cdH07XG5cdGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcih0eXBlLCBjYWxsYmFjaywgb25lcnJvcikge1xuXHRcdGlmIChvYmouemlwLndvcmtlclNjcmlwdHMgIT09IG51bGwgJiYgb2JqLnppcC53b3JrZXJTY3JpcHRzUGF0aCAhPT0gbnVsbCkge1xuXHRcdFx0b25lcnJvcihuZXcgRXJyb3IoJ0VpdGhlciB6aXAud29ya2VyU2NyaXB0cyBvciB6aXAud29ya2VyU2NyaXB0c1BhdGggbWF5IGJlIHNldCwgbm90IGJvdGguJykpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgc2NyaXB0cztcblx0XHRpZiAob2JqLnppcC53b3JrZXJTY3JpcHRzKSB7XG5cdFx0XHRzY3JpcHRzID0gb2JqLnppcC53b3JrZXJTY3JpcHRzW3R5cGVdO1xuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHNjcmlwdHMpKSB7XG5cdFx0XHRcdG9uZXJyb3IobmV3IEVycm9yKCd6aXAud29ya2VyU2NyaXB0cy4nICsgdHlwZSArICcgaXMgbm90IGFuIGFycmF5IScpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2NyaXB0cyA9IHJlc29sdmVVUkxzKHNjcmlwdHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzY3JpcHRzID0gREVGQVVMVF9XT1JLRVJfU0NSSVBUU1t0eXBlXS5zbGljZSgwKTtcblx0XHRcdHNjcmlwdHNbMF0gPSAob2JqLnppcC53b3JrZXJTY3JpcHRzUGF0aCB8fCAnJykgKyBzY3JpcHRzWzBdO1xuXHRcdH1cblx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihzY3JpcHRzWzBdKTtcblx0XHQvLyByZWNvcmQgdG90YWwgY29uc3VtZWQgdGltZSBieSBpbmZsYXRlci9kZWZsYXRlci9jcmMzMiBpbiB0aGlzIHdvcmtlclxuXHRcdHdvcmtlci5jb2RlY1RpbWUgPSB3b3JrZXIuY3JjVGltZSA9IDA7XG5cdFx0d29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogJ2ltcG9ydFNjcmlwdHMnLCBzY3JpcHRzOiBzY3JpcHRzLnNsaWNlKDEpIH0pO1xuXHRcdHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlKTtcblx0XHRmdW5jdGlvbiBvbm1lc3NhZ2UoZXYpIHtcblx0XHRcdHZhciBtc2cgPSBldi5kYXRhO1xuXHRcdFx0aWYgKG1zZy5lcnJvcikge1xuXHRcdFx0XHR3b3JrZXIudGVybWluYXRlKCk7IC8vIHNob3VsZCBiZWZvcmUgb25lcnJvcigpLCBiZWNhdXNlIG9uZXJyb3IoKSBtYXkgdGhyb3cuXG5cdFx0XHRcdG9uZXJyb3IobXNnLmVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1zZy50eXBlID09PSAnaW1wb3J0U2NyaXB0cycpIHtcblx0XHRcdFx0d29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UpO1xuXHRcdFx0XHR3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuXHRcdFx0XHRjYWxsYmFjayh3b3JrZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjYXRjaCBlbnRyeSBzY3JpcHQgbG9hZGluZyBlcnJvciBhbmQgb3RoZXIgdW5oYW5kbGVkIGVycm9yc1xuXHRcdHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG5cdFx0ZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGVycikge1xuXHRcdFx0d29ya2VyLnRlcm1pbmF0ZSgpO1xuXHRcdFx0b25lcnJvcihlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG9uZXJyb3JfZGVmYXVsdChlcnJvcikge1xuXHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuXHR9XG5cdG9iai56aXAgPSB7XG5cdFx0UmVhZGVyIDogUmVhZGVyLFxuXHRcdFdyaXRlciA6IFdyaXRlcixcblx0XHRCbG9iUmVhZGVyIDogQmxvYlJlYWRlcixcblx0XHREYXRhNjRVUklSZWFkZXIgOiBEYXRhNjRVUklSZWFkZXIsXG5cdFx0VGV4dFJlYWRlciA6IFRleHRSZWFkZXIsXG5cdFx0QmxvYldyaXRlciA6IEJsb2JXcml0ZXIsXG5cdFx0RGF0YTY0VVJJV3JpdGVyIDogRGF0YTY0VVJJV3JpdGVyLFxuXHRcdFRleHRXcml0ZXIgOiBUZXh0V3JpdGVyLFxuXHRcdGNyZWF0ZVJlYWRlciA6IGZ1bmN0aW9uKHJlYWRlciwgY2FsbGJhY2ssIG9uZXJyb3IpIHtcblx0XHRcdG9uZXJyb3IgPSBvbmVycm9yIHx8IG9uZXJyb3JfZGVmYXVsdDtcblxuXHRcdFx0cmVhZGVyLmluaXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNyZWF0ZVppcFJlYWRlcihyZWFkZXIsIGNhbGxiYWNrLCBvbmVycm9yKTtcblx0XHRcdH0sIG9uZXJyb3IpO1xuXHRcdH0sXG5cdFx0Y3JlYXRlV3JpdGVyIDogZnVuY3Rpb24od3JpdGVyLCBjYWxsYmFjaywgb25lcnJvciwgZG9udERlZmxhdGUpIHtcblx0XHRcdG9uZXJyb3IgPSBvbmVycm9yIHx8IG9uZXJyb3JfZGVmYXVsdDtcblx0XHRcdGRvbnREZWZsYXRlID0gISFkb250RGVmbGF0ZTtcblxuXHRcdFx0d3JpdGVyLmluaXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNyZWF0ZVppcFdyaXRlcih3cml0ZXIsIGNhbGxiYWNrLCBvbmVycm9yLCBkb250RGVmbGF0ZSk7XG5cdFx0XHR9LCBvbmVycm9yKTtcblx0XHR9LFxuXHRcdHVzZVdlYldvcmtlcnMgOiB0cnVlLFxuXHRcdC8qKlxuXHRcdCAqIERpcmVjdG9yeSBjb250YWluaW5nIHRoZSBkZWZhdWx0IHdvcmtlciBzY3JpcHRzICh6LXdvcmtlci5qcywgZGVmbGF0ZS5qcywgYW5kIGluZmxhdGUuanMpLCByZWxhdGl2ZSB0byBjdXJyZW50IGJhc2UgdXJsLlxuXHRcdCAqIEUuZy46IHppcC53b3JrZXJTY3JpcHRzID0gJy4vJztcblx0XHQgKi9cblx0XHR3b3JrZXJTY3JpcHRzUGF0aCA6IG51bGwsXG5cdFx0LyoqXG5cdFx0ICogQWR2YW5jZWQgb3B0aW9uIHRvIGNvbnRyb2wgd2hpY2ggc2NyaXB0cyBhcmUgbG9hZGVkIGluIHRoZSBXZWIgd29ya2VyLiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZW4gd29ya2VyU2NyaXB0c1BhdGggbXVzdCBub3QgYmUgc2V0LlxuXHRcdCAqIHdvcmtlclNjcmlwdHMuZGVmbGF0ZXIvd29ya2VyU2NyaXB0cy5pbmZsYXRlciBzaG91bGQgYmUgYXJyYXlzIG9mIHVybHMgdG8gc2NyaXB0cyBmb3IgZGVmbGF0ZXIvaW5mbGF0ZXIsIHJlc3BlY3RpdmVseS5cblx0XHQgKiBTY3JpcHRzIGluIHRoZSBhcnJheSBhcmUgZXhlY3V0ZWQgaW4gb3JkZXIsIGFuZCB0aGUgZmlyc3Qgb25lIHNob3VsZCBiZSB6LXdvcmtlci5qcywgd2hpY2ggaXMgdXNlZCB0byBzdGFydCB0aGUgd29ya2VyLlxuXHRcdCAqIEFsbCB1cmxzIGFyZSByZWxhdGl2ZSB0byBjdXJyZW50IGJhc2UgdXJsLlxuXHRcdCAqIEUuZy46XG5cdFx0ICogemlwLndvcmtlclNjcmlwdHMgPSB7XG5cdFx0ICogICBkZWZsYXRlcjogWyd6LXdvcmtlci5qcycsICdkZWZsYXRlLmpzJ10sXG5cdFx0ICogICBpbmZsYXRlcjogWyd6LXdvcmtlci5qcycsICdpbmZsYXRlLmpzJ11cblx0XHQgKiB9O1xuXHRcdCAqL1xuXHRcdHdvcmtlclNjcmlwdHMgOiBudWxsLFxuXHR9O1xuXG59KSh0aGlzKTtcblxuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgemlwICE9IFwidW5kZWZpbmVkXCIgPyB6aXAgOiB3aW5kb3cuemlwKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuIl19
